//;******************************************************************************
//;* Copyright (c) 1983-2011, Insyde Software Corporation. All Rights Reserved.
//;*
//;* You may not reproduce, distribute, publish, display, perform, modify, adapt,
//;* transmit, broadcast, present, recite, release, license or otherwise exploit
//;* any part of this publication in any form, by any means, without the prior
//;* written permission of Insyde Software Corporation.
//;*
//;******************************************************************************
/*++

Module Name:

  BsUsbStatusCode.c

Abstract:

  Lib to provide USB port status code reporting Routines. This routine
  does not use PPI's but is monolithic.

  In general you should use PPI's, but some times a monolithic driver
  is better. The best justification for monolithic code is debug.

--*/

#include "BsUsbStatusCode.h"
#include "Misc.h"
//
// All of the lookup tables are only needed in debug.
//
#ifdef EFI_DEBUG

typedef struct {
  UINT32  Value;
  CHAR8   *Token;
} STATUS_CODE_LOOKUP_TABLE;

STATUS_CODE_LOOKUP_TABLE  mSeverityTokens[] = {
  {
    EFI_ERROR_MINOR,
    "ERROR_MINOR"
  },
  {
    EFI_ERROR_MAJOR,
    "ERROR_MAJOR"
  },
  {
    EFI_ERROR_UNRECOVERED,
    "ERROR_UNRECOVERED"
  },
  {
    EFI_ERROR_UNCONTAINED,
    "ERROR_UNCONTAINED"
  },
  {
    0xFFFFFFFF,
    "ERROR_UNRECOGNIZED"
  }
};
STATUS_CODE_LOOKUP_TABLE  mClassSubClassTokens[] = {
  {
    EFI_COMPUTING_UNIT_UNSPECIFIED,
    "COMPUTING_UNIT_UNSPECIFIED"
  },
  {
    EFI_COMPUTING_UNIT_HOST_PROCESSOR,
    "COMPUTING_UNIT_HOST_PROCESSOR"
  },
  {
    EFI_COMPUTING_UNIT_FIRMWARE_PROCESSOR,
    "COMPUTING_UNIT_FIRMWARE_PROCESSOR"
  },
  {
    EFI_COMPUTING_UNIT_IO_PROCESSOR,
    "COMPUTING_UNIT_IO_PROCESSOR"
  },
  {
    EFI_COMPUTING_UNIT_CACHE,
    "COMPUTING_UNIT_CACHE"
  },
  {
    EFI_COMPUTING_UNIT_MEMORY,
    "COMPUTING_UNIT_MEMORY"
  },
  {
    EFI_COMPUTING_UNIT_CHIPSET,
    "COMPUTING_UNIT_CHIPSET"
  },
  {
    EFI_PERIPHERAL_UNSPECIFIED,
    "PERIPHERAL_UNSPECIFIED"
  },
  {
    EFI_PERIPHERAL_KEYBOARD,
    "PERIPHERAL_KEYBOARD"
  },
  {
    EFI_PERIPHERAL_MOUSE,
    "PERIPHERAL_MOUSE"
  },
  {
    EFI_PERIPHERAL_LOCAL_CONSOLE,
    "PERIPHERAL_LOCAL_CONSOLE"
  },
  {
    EFI_PERIPHERAL_REMOTE_CONSOLE,
    "PERIPHERAL_REMOTE_CONSOLE"
  },
  {
    EFI_PERIPHERAL_SERIAL_PORT,
    "PERIPHERAL_SERIAL_PORT"
  },
  {
    EFI_PERIPHERAL_PARALLEL_PORT,
    "PERIPHERAL_PARALLEL_PORT"
  },
  {
    EFI_PERIPHERAL_FIXED_MEDIA,
    "PERIPHERAL_FIXED_MEDIA"
  },
  {
    EFI_PERIPHERAL_REMOVABLE_MEDIA,
    "PERIPHERAL_REMOVABLE_MEDIA"
  },
  {
    EFI_PERIPHERAL_AUDIO_INPUT,
    "PERIPHERAL_AUDIO_INPUT"
  },
  {
    EFI_PERIPHERAL_AUDIO_OUTPUT,
    "PERIPHERAL_AUDIO_OUTPUT"
  },
  {
    EFI_PERIPHERAL_LCD_DEVICE,
    "PERIPHERAL_LCD_DEVICE"
  },
  {
    EFI_IO_BUS_UNSPECIFIED,
    "IO_BUS_UNSPECIFIED"
  },
  {
    EFI_IO_BUS_PCI,
    "IO_BUS_PCI"
  },
  {
    EFI_IO_BUS_USB,
    "IO_BUS_USB"
  },
  {
    EFI_IO_BUS_IBA,
    "IO_BUS_IBA"
  },
  {
    EFI_IO_BUS_AGP,
    "IO_BUS_AGP"
  },
  {
    EFI_IO_BUS_PC_CARD,
    "IO_BUS_PC_CARD"
  },
  {
    EFI_IO_BUS_LPC,
    "IO_BUS_LPC"
  },
  {
    EFI_IO_BUS_SCSI,
    "IO_BUS_SCSI"
  },
  {
    EFI_IO_BUS_ATA_ATAPI,
    "IO_BUS_ATA_ATAPI"
  },
  {
    EFI_IO_BUS_FC,
    "IO_BUS_FC"
  },
  {
    EFI_IO_BUS_IP_NETWORK,
    "IO_BUS_IP_NETWORK"
  },
  {
    EFI_IO_BUS_SMBUS,
    "IO_BUS_SMBUS"
  },
  {
    EFI_IO_BUS_I2C,
    "IO_BUS_I2C"
  },
  {
    EFI_SOFTWARE_UNSPECIFIED,
    "SOFTWARE_UNSPECIFIED"
  },
  {
    EFI_SOFTWARE_SEC,
    "SOFTWARE_EFI_SEC"
  },
  {
    EFI_SOFTWARE_PEI_CORE,
    "SOFTWARE_EFI_PEI_CORE"
  },
  {
    EFI_SOFTWARE_PEI_MODULE,
    "SOFTWARE_EFI_PEI_MODULE"
  },
  {
    EFI_SOFTWARE_DXE_CORE,
    "SOFTWARE_EFI_DXE_CORE"
  },
  {
    EFI_SOFTWARE_EFI_BOOT_SERVICE,
    "SOFTWARE_EFI_BOOT_SERVICE"
  },
  {
    EFI_SOFTWARE_EFI_RUNTIME_SERVICE,
    "SOFTWARE_EFI_RUNTIME_SERVICE"
  },
  {
    EFI_SOFTWARE_DXE_BS_DRIVER,
    "SOFTWARE_DXE_BS_DRIVER"
  },
  {
    EFI_SOFTWARE_DXE_RT_DRIVER,
    "SOFTWARE_DXE_RT_DRIVER"
  },
  {
    EFI_SOFTWARE_SMM_DRIVER,
    "SOFTWARE_SMM_DRIVER"
  },
  {
    EFI_SOFTWARE_RT,
    "SOFTWARE_RT"
  },
  {
    EFI_SOFTWARE_AL,
    "SOFTWARE_AL"
  },
  {
    EFI_SOFTWARE_EFI_APPLICATION,
    "SOFTWARE_EFI_APPLICATION"
  },
  {
    EFI_SOFTWARE_EFI_OS_LOADER,
    "SOFTWARE_EFI_OS_LOADER"
  },
  {
    0xFFFFFFFF,
    "ERROR_UNRECOGNIZED"
  }
};

STATUS_CODE_LOOKUP_TABLE  mOperationTokens[] = {
  {
    EFI_COMPUTING_UNIT_UNSPECIFIED | EFI_CU_EC_NON_SPECIFIC,
    "NON_SPECIFIC"
  },
  {
    EFI_COMPUTING_UNIT_UNSPECIFIED | EFI_CU_EC_DISABLED,
    "DISABLED"
  },
  {
    EFI_COMPUTING_UNIT_UNSPECIFIED | EFI_CU_EC_NOT_SUPPORTED,
    "NOT_SUPPORTED"
  },
  {
    EFI_COMPUTING_UNIT_UNSPECIFIED | EFI_CU_EC_NOT_DETECTED,
    "NOT_DETECTED"
  },
  {
    EFI_COMPUTING_UNIT_UNSPECIFIED | EFI_CU_EC_NOT_CONFIGURED,
    "NOT_CONFIGURED"
  },
  {
    EFI_COMPUTING_UNIT_HOST_PROCESSOR | EFI_CU_EC_NON_SPECIFIC,
    "NON_SPECIFIC"
  },
  {
    EFI_COMPUTING_UNIT_HOST_PROCESSOR | EFI_CU_EC_DISABLED,
    "DISABLED"
  },
  {
    EFI_COMPUTING_UNIT_HOST_PROCESSOR | EFI_CU_EC_NOT_SUPPORTED,
    "NOT_SUPPORTED"
  },
  {
    EFI_COMPUTING_UNIT_HOST_PROCESSOR | EFI_CU_EC_NOT_DETECTED,
    "NOT_DETECTED"
  },
  {
    EFI_COMPUTING_UNIT_HOST_PROCESSOR | EFI_CU_EC_NOT_CONFIGURED,
    "NOT_CONFIGURED"
  },
  {
    EFI_COMPUTING_UNIT_HOST_PROCESSOR | EFI_CU_HP_EC_INVALID_TYPE,
    "INVALID_TYPE"
  },
  {
    EFI_COMPUTING_UNIT_HOST_PROCESSOR | EFI_CU_HP_EC_INVALID_SPEED,
    "INVALID_SPEED"
  },
  {
    EFI_COMPUTING_UNIT_HOST_PROCESSOR | EFI_CU_HP_EC_MISMATCH,
    "MISMATCH"
  },
  {
    EFI_COMPUTING_UNIT_HOST_PROCESSOR | EFI_CU_HP_EC_TIMER_EXPIRED,
    "TIMER_EXPIRED"
  },
  {
    EFI_COMPUTING_UNIT_HOST_PROCESSOR | EFI_CU_HP_EC_SELF_TEST,
    "SELF_TEST"
  },
  {
    EFI_COMPUTING_UNIT_HOST_PROCESSOR | EFI_CU_HP_EC_INTERNAL,
    "INTERNAL"
  },
  {
    EFI_COMPUTING_UNIT_HOST_PROCESSOR | EFI_CU_HP_EC_THERMAL,
    "THERMAL"
  },
  {
    EFI_COMPUTING_UNIT_HOST_PROCESSOR | EFI_CU_HP_EC_LOW_VOLTAGE,
    "LOW_VOLTAGE"
  },
  {
    EFI_COMPUTING_UNIT_HOST_PROCESSOR | EFI_CU_HP_EC_HIGH_VOLTAGE,
    "HIGH_VOLTAGE"
  },
  {
    EFI_COMPUTING_UNIT_HOST_PROCESSOR | EFI_CU_HP_EC_CACHE,
    "CACHE"
  },
  {
    EFI_COMPUTING_UNIT_HOST_PROCESSOR | EFI_CU_HP_EC_MICROCODE_UPDATE,
    "MICROCODE_UPDATE"
  },
  {
    EFI_COMPUTING_UNIT_HOST_PROCESSOR | EFI_CU_HP_EC_NO_MICROCODE_UPDATE,
    "NO_MICROCODE_UPDATE"
  },
  {
    EFI_COMPUTING_UNIT_HOST_PROCESSOR | EFI_CU_HP_EC_CORRECTABLE,
    "1XECC"
  },
  {
    EFI_COMPUTING_UNIT_HOST_PROCESSOR | EFI_CU_HP_EC_UNCORRECTABLE,
    "2XECC"
  },
  {
    EFI_COMPUTING_UNIT_FIRMWARE_PROCESSOR | EFI_CU_EC_NON_SPECIFIC,
    "NON_SPECIFIC"
  },
  {
    EFI_COMPUTING_UNIT_FIRMWARE_PROCESSOR | EFI_CU_EC_DISABLED,
    "DISABLED"
  },
  {
    EFI_COMPUTING_UNIT_FIRMWARE_PROCESSOR | EFI_CU_EC_NOT_SUPPORTED,
    "NOT_SUPPORTED"
  },
  {
    EFI_COMPUTING_UNIT_FIRMWARE_PROCESSOR | EFI_CU_EC_NOT_DETECTED,
    "NOT_DETECTED"
  },
  {
    EFI_COMPUTING_UNIT_FIRMWARE_PROCESSOR | EFI_CU_EC_NOT_CONFIGURED,
    "NOT_CONFIGURED"
  },
  {
    EFI_COMPUTING_UNIT_IO_PROCESSOR | EFI_CU_EC_NON_SPECIFIC,
    "NON_SPECIFIC"
  },
  {
    EFI_COMPUTING_UNIT_IO_PROCESSOR | EFI_CU_EC_DISABLED,
    "DISABLED"
  },
  {
    EFI_COMPUTING_UNIT_IO_PROCESSOR | EFI_CU_EC_NOT_SUPPORTED,
    "NOT_SUPPORTED"
  },
  {
    EFI_COMPUTING_UNIT_IO_PROCESSOR | EFI_CU_EC_NOT_DETECTED,
    "NOT_DETECTED"
  },
  {
    EFI_COMPUTING_UNIT_IO_PROCESSOR | EFI_CU_EC_NOT_CONFIGURED,
    "NOT_CONFIGURED"
  },
  {
    EFI_COMPUTING_UNIT_CACHE | EFI_CU_EC_NON_SPECIFIC,
    "NON_SPECIFIC"
  },
  {
    EFI_COMPUTING_UNIT_CACHE | EFI_CU_EC_DISABLED,
    "DISABLED"
  },
  {
    EFI_COMPUTING_UNIT_CACHE | EFI_CU_EC_NOT_SUPPORTED,
    "NOT_SUPPORTED"
  },
  {
    EFI_COMPUTING_UNIT_CACHE | EFI_CU_EC_NOT_DETECTED,
    "NOT_DETECTED"
  },
  {
    EFI_COMPUTING_UNIT_CACHE | EFI_CU_EC_NOT_CONFIGURED,
    "NOT_CONFIGURED"
  },
  {
    EFI_COMPUTING_UNIT_CACHE | EFI_CU_CACHE_EC_INVALID_TYPE,
    "INVALID_TYPE"
  },
  {
    EFI_COMPUTING_UNIT_CACHE | EFI_CU_CACHE_EC_INVALID_SPEED,
    "INVALID_SPEED"
  },
  {
    EFI_COMPUTING_UNIT_CACHE | EFI_CU_CACHE_EC_INVALID_SIZE,
    "INVALID_SIZE"
  },
  {
    EFI_COMPUTING_UNIT_MEMORY | EFI_CU_EC_NON_SPECIFIC,
    "NON_SPECIFIC"
  },
  {
    EFI_COMPUTING_UNIT_MEMORY | EFI_CU_EC_DISABLED,
    "DISABLED"
  },
  {
    EFI_COMPUTING_UNIT_MEMORY | EFI_CU_EC_NOT_SUPPORTED,
    "NOT_SUPPORTED"
  },
  {
    EFI_COMPUTING_UNIT_MEMORY | EFI_CU_EC_NOT_DETECTED,
    "NOT_DETECTED"
  },
  {
    EFI_COMPUTING_UNIT_MEMORY | EFI_CU_EC_NOT_CONFIGURED,
    "NOT_CONFIGURED"
  },
  {
    EFI_COMPUTING_UNIT_MEMORY | EFI_CU_MEMORY_EC_INVALID_TYPE,
    "INVALID_TYPE"
  },
  {
    EFI_COMPUTING_UNIT_MEMORY | EFI_CU_MEMORY_EC_INVALID_SPEED,
    "INVALID_SPEED"
  },
  {
    EFI_COMPUTING_UNIT_MEMORY | EFI_CU_MEMORY_EC_CORRECTABLE,
    "1XECC"
  },
  {
    EFI_COMPUTING_UNIT_MEMORY | EFI_CU_MEMORY_EC_UNCORRECTABLE,
    "2XECC"
  },
  {
    EFI_COMPUTING_UNIT_MEMORY | EFI_CU_MEMORY_EC_SPD_FAIL,
    "SPD_FAIL"
  },
  {
    EFI_COMPUTING_UNIT_MEMORY | EFI_CU_MEMORY_EC_INVALID_SIZE,
    "INVALID_SIZE"
  },
  {
    EFI_COMPUTING_UNIT_MEMORY | EFI_CU_MEMORY_EC_MISMATCH,
    "MISMATCH"
  },
  {
    EFI_COMPUTING_UNIT_MEMORY | EFI_CU_MEMORY_EC_S3_RESUME_FAIL,
    "S3_RESUME_FAIL"
  },
  {
    EFI_COMPUTING_UNIT_MEMORY | EFI_CU_MEMORY_EC_UPDATE_FAIL,
    "UPDATE_FAIL"
  },
  {
    EFI_COMPUTING_UNIT_CHIPSET | EFI_CU_EC_NON_SPECIFIC,
    "NON_SPECIFIC"
  },
  {
    EFI_COMPUTING_UNIT_CHIPSET | EFI_CU_EC_DISABLED,
    "DISABLED"
  },
  {
    EFI_COMPUTING_UNIT_CHIPSET | EFI_CU_EC_NOT_SUPPORTED,
    "NOT_SUPPORTED"
  },
  {
    EFI_COMPUTING_UNIT_CHIPSET | EFI_CU_EC_NOT_DETECTED,
    "NOT_DETECTED"
  },
  {
    EFI_COMPUTING_UNIT_CHIPSET | EFI_CU_EC_NOT_CONFIGURED,
    "NOT_CONFIGURED"
  },
  {
    EFI_PERIPHERAL_UNSPECIFIED | EFI_P_EC_NON_SPECIFIC,
    "NON_SPECIFIC"
  },
  {
    EFI_PERIPHERAL_UNSPECIFIED | EFI_P_EC_DISABLED,
    "DISABLED"
  },
  {
    EFI_PERIPHERAL_UNSPECIFIED | EFI_P_EC_NOT_SUPPORTED,
    "NOT_SUPPORTED"
  },
  {
    EFI_PERIPHERAL_UNSPECIFIED | EFI_P_EC_NOT_DETECTED,
    "NOT_DETECTED"
  },
  {
    EFI_PERIPHERAL_UNSPECIFIED | EFI_P_EC_NOT_CONFIGURED,
    "NOT_CONFIGURED"
  },
  {
    EFI_PERIPHERAL_UNSPECIFIED | EFI_P_EC_INTERFACE_ERROR,
    "INTERFACE_ERROR"
  },
  {
    EFI_PERIPHERAL_UNSPECIFIED | EFI_P_EC_CONTROLLER_ERROR,
    "CONTROLLER_ERROR"
  },
  {
    EFI_PERIPHERAL_UNSPECIFIED | EFI_P_EC_INPUT_ERROR,
    "INPUT_ERROR"
  },
  {
    EFI_PERIPHERAL_UNSPECIFIED | EFI_P_EC_OUTPUT_ERROR,
    "OUTPUT_ERROR"
  },
  {
    EFI_PERIPHERAL_UNSPECIFIED | EFI_P_EC_RESOURCE_CONFLICT,
    "RESOURCE_CONFLICT"
  },
  {
    EFI_PERIPHERAL_KEYBOARD | EFI_P_EC_NON_SPECIFIC,
    "NON_SPECIFIC"
  },
  {
    EFI_PERIPHERAL_KEYBOARD | EFI_P_EC_DISABLED,
    "DISABLED"
  },
  {
    EFI_PERIPHERAL_KEYBOARD | EFI_P_EC_NOT_SUPPORTED,
    "NOT_SUPPORTED"
  },
  {
    EFI_PERIPHERAL_KEYBOARD | EFI_P_EC_NOT_DETECTED,
    "NOT_DETECTED"
  },
  {
    EFI_PERIPHERAL_KEYBOARD | EFI_P_EC_NOT_CONFIGURED,
    "NOT_CONFIGURED"
  },
  {
    EFI_PERIPHERAL_KEYBOARD | EFI_P_EC_INTERFACE_ERROR,
    "INTERFACE_ERROR"
  },
  {
    EFI_PERIPHERAL_KEYBOARD | EFI_P_EC_CONTROLLER_ERROR,
    "CONTROLLER_ERROR"
  },
  {
    EFI_PERIPHERAL_KEYBOARD | EFI_P_EC_INPUT_ERROR,
    "INPUT_ERROR"
  },
  {
    EFI_PERIPHERAL_KEYBOARD | EFI_P_EC_OUTPUT_ERROR,
    "OUTPUT_ERROR"
  },
  {
    EFI_PERIPHERAL_KEYBOARD | EFI_P_EC_RESOURCE_CONFLICT,
    "RESOURCE_CONFLICT"
  },
  {
    EFI_PERIPHERAL_KEYBOARD | EFI_P_KEYBOARD_EC_LOCKED,
    "LOCKED"
  },
  {
    EFI_PERIPHERAL_KEYBOARD | EFI_P_KEYBOARD_EC_STUCK_KEY,
    "STUCK_KEY"
  },
  {
    EFI_PERIPHERAL_MOUSE | EFI_P_EC_NON_SPECIFIC,
    "NON_SPECIFIC"
  },
  {
    EFI_PERIPHERAL_MOUSE | EFI_P_EC_DISABLED,
    "DISABLED"
  },
  {
    EFI_PERIPHERAL_MOUSE | EFI_P_EC_NOT_SUPPORTED,
    "NOT_SUPPORTED"
  },
  {
    EFI_PERIPHERAL_MOUSE | EFI_P_EC_NOT_DETECTED,
    "NOT_DETECTED"
  },
  {
    EFI_PERIPHERAL_MOUSE | EFI_P_EC_NOT_CONFIGURED,
    "NOT_CONFIGURED"
  },
  {
    EFI_PERIPHERAL_MOUSE | EFI_P_EC_INTERFACE_ERROR,
    "INTERFACE_ERROR"
  },
  {
    EFI_PERIPHERAL_MOUSE | EFI_P_EC_CONTROLLER_ERROR,
    "CONTROLLER_ERROR"
  },
  {
    EFI_PERIPHERAL_MOUSE | EFI_P_EC_INPUT_ERROR,
    "INPUT_ERROR"
  },
  {
    EFI_PERIPHERAL_MOUSE | EFI_P_EC_OUTPUT_ERROR,
    "OUTPUT_ERROR"
  },
  {
    EFI_PERIPHERAL_MOUSE | EFI_P_EC_RESOURCE_CONFLICT,
    "RESOURCE_CONFLICT"
  },
  {
    EFI_PERIPHERAL_MOUSE | EFI_P_MOUSE_EC_LOCKED,
    "LOCKED"
  },
  {
    EFI_PERIPHERAL_LOCAL_CONSOLE | EFI_P_EC_NON_SPECIFIC,
    "NON_SPECIFIC"
  },
  {
    EFI_PERIPHERAL_LOCAL_CONSOLE | EFI_P_EC_DISABLED,
    "DISABLED"
  },
  {
    EFI_PERIPHERAL_LOCAL_CONSOLE | EFI_P_EC_NOT_SUPPORTED,
    "NOT_SUPPORTED"
  },
  {
    EFI_PERIPHERAL_LOCAL_CONSOLE | EFI_P_EC_NOT_DETECTED,
    "NOT_DETECTED"
  },
  {
    EFI_PERIPHERAL_LOCAL_CONSOLE | EFI_P_EC_NOT_CONFIGURED,
    "NOT_CONFIGURED"
  },
  {
    EFI_PERIPHERAL_LOCAL_CONSOLE | EFI_P_EC_INTERFACE_ERROR,
    "INTERFACE_ERROR"
  },
  {
    EFI_PERIPHERAL_LOCAL_CONSOLE | EFI_P_EC_CONTROLLER_ERROR,
    "CONTROLLER_ERROR"
  },
  {
    EFI_PERIPHERAL_LOCAL_CONSOLE | EFI_P_EC_INPUT_ERROR,
    "INPUT_ERROR"
  },
  {
    EFI_PERIPHERAL_LOCAL_CONSOLE | EFI_P_EC_OUTPUT_ERROR,
    "OUTPUT_ERROR"
  },
  {
    EFI_PERIPHERAL_LOCAL_CONSOLE | EFI_P_EC_RESOURCE_CONFLICT,
    "RESOURCE_CONFLICT"
  },
  {
    EFI_PERIPHERAL_REMOTE_CONSOLE | EFI_P_EC_NON_SPECIFIC,
    "NON_SPECIFIC"
  },
  {
    EFI_PERIPHERAL_REMOTE_CONSOLE | EFI_P_EC_DISABLED,
    "DISABLED"
  },
  {
    EFI_PERIPHERAL_REMOTE_CONSOLE | EFI_P_EC_NOT_SUPPORTED,
    "NOT_SUPPORTED"
  },
  {
    EFI_PERIPHERAL_REMOTE_CONSOLE | EFI_P_EC_NOT_DETECTED,
    "NOT_DETECTED"
  },
  {
    EFI_PERIPHERAL_REMOTE_CONSOLE | EFI_P_EC_NOT_CONFIGURED,
    "NOT_CONFIGURED"
  },
  {
    EFI_PERIPHERAL_REMOTE_CONSOLE | EFI_P_EC_INTERFACE_ERROR,
    "INTERFACE_ERROR"
  },
  {
    EFI_PERIPHERAL_REMOTE_CONSOLE | EFI_P_EC_CONTROLLER_ERROR,
    "CONTROLLER_ERROR"
  },
  {
    EFI_PERIPHERAL_REMOTE_CONSOLE | EFI_P_EC_INPUT_ERROR,
    "INPUT_ERROR"
  },
  {
    EFI_PERIPHERAL_REMOTE_CONSOLE | EFI_P_EC_OUTPUT_ERROR,
    "OUTPUT_ERROR"
  },
  {
    EFI_PERIPHERAL_REMOTE_CONSOLE | EFI_P_EC_RESOURCE_CONFLICT,
    "RESOURCE_CONFLICT"
  },
  {
    EFI_PERIPHERAL_SERIAL_PORT | EFI_P_EC_NON_SPECIFIC,
    "NON_SPECIFIC"
  },
  {
    EFI_PERIPHERAL_SERIAL_PORT | EFI_P_EC_DISABLED,
    "DISABLED"
  },
  {
    EFI_PERIPHERAL_SERIAL_PORT | EFI_P_EC_NOT_SUPPORTED,
    "NOT_SUPPORTED"
  },
  {
    EFI_PERIPHERAL_SERIAL_PORT | EFI_P_EC_NOT_DETECTED,
    "NOT_DETECTED"
  },
  {
    EFI_PERIPHERAL_SERIAL_PORT | EFI_P_EC_NOT_CONFIGURED,
    "NOT_CONFIGURED"
  },
  {
    EFI_PERIPHERAL_SERIAL_PORT | EFI_P_EC_INTERFACE_ERROR,
    "INTERFACE_ERROR"
  },
  {
    EFI_PERIPHERAL_SERIAL_PORT | EFI_P_EC_CONTROLLER_ERROR,
    "CONTROLLER_ERROR"
  },
  {
    EFI_PERIPHERAL_SERIAL_PORT | EFI_P_EC_INPUT_ERROR,
    "INPUT_ERROR"
  },
  {
    EFI_PERIPHERAL_SERIAL_PORT | EFI_P_EC_OUTPUT_ERROR,
    "OUTPUT_ERROR"
  },
  {
    EFI_PERIPHERAL_SERIAL_PORT | EFI_P_EC_RESOURCE_CONFLICT,
    "RESOURCE_CONFLICT"
  },
  {
    EFI_PERIPHERAL_PARALLEL_PORT | EFI_P_EC_NON_SPECIFIC,
    "NON_SPECIFIC"
  },
  {
    EFI_PERIPHERAL_PARALLEL_PORT | EFI_P_EC_DISABLED,
    "DISABLED"
  },
  {
    EFI_PERIPHERAL_PARALLEL_PORT | EFI_P_EC_NOT_SUPPORTED,
    "NOT_SUPPORTED"
  },
  {
    EFI_PERIPHERAL_PARALLEL_PORT | EFI_P_EC_NOT_DETECTED,
    "NOT_DETECTED"
  },
  {
    EFI_PERIPHERAL_PARALLEL_PORT | EFI_P_EC_NOT_CONFIGURED,
    "NOT_CONFIGURED"
  },
  {
    EFI_PERIPHERAL_PARALLEL_PORT | EFI_P_EC_INTERFACE_ERROR,
    "INTERFACE_ERROR"
  },
  {
    EFI_PERIPHERAL_PARALLEL_PORT | EFI_P_EC_CONTROLLER_ERROR,
    "CONTROLLER_ERROR"
  },
  {
    EFI_PERIPHERAL_PARALLEL_PORT | EFI_P_EC_INPUT_ERROR,
    "INPUT_ERROR"
  },
  {
    EFI_PERIPHERAL_PARALLEL_PORT | EFI_P_EC_OUTPUT_ERROR,
    "OUTPUT_ERROR"
  },
  {
    EFI_PERIPHERAL_PARALLEL_PORT | EFI_P_EC_RESOURCE_CONFLICT,
    "RESOURCE_CONFLICT"
  },
  {
    EFI_PERIPHERAL_FIXED_MEDIA | EFI_P_EC_NON_SPECIFIC,
    "NON_SPECIFIC"
  },
  {
    EFI_PERIPHERAL_FIXED_MEDIA | EFI_P_EC_DISABLED,
    "DISABLED"
  },
  {
    EFI_PERIPHERAL_FIXED_MEDIA | EFI_P_EC_NOT_SUPPORTED,
    "NOT_SUPPORTED"
  },
  {
    EFI_PERIPHERAL_FIXED_MEDIA | EFI_P_EC_NOT_DETECTED,
    "NOT_DETECTED"
  },
  {
    EFI_PERIPHERAL_FIXED_MEDIA | EFI_P_EC_NOT_CONFIGURED,
    "NOT_CONFIGURED"
  },
  {
    EFI_PERIPHERAL_FIXED_MEDIA | EFI_P_EC_INTERFACE_ERROR,
    "INTERFACE_ERROR"
  },
  {
    EFI_PERIPHERAL_FIXED_MEDIA | EFI_P_EC_CONTROLLER_ERROR,
    "CONTROLLER_ERROR"
  },
  {
    EFI_PERIPHERAL_FIXED_MEDIA | EFI_P_EC_INPUT_ERROR,
    "INPUT_ERROR"
  },
  {
    EFI_PERIPHERAL_FIXED_MEDIA | EFI_P_EC_OUTPUT_ERROR,
    "OUTPUT_ERROR"
  },
  {
    EFI_PERIPHERAL_FIXED_MEDIA | EFI_P_EC_RESOURCE_CONFLICT,
    "RESOURCE_CONFLICT"
  },
  {
    EFI_PERIPHERAL_REMOVABLE_MEDIA | EFI_P_EC_NON_SPECIFIC,
    "NON_SPECIFIC"
  },
  {
    EFI_PERIPHERAL_REMOVABLE_MEDIA | EFI_P_EC_DISABLED,
    "DISABLED"
  },
  {
    EFI_PERIPHERAL_REMOVABLE_MEDIA | EFI_P_EC_NOT_SUPPORTED,
    "NOT_SUPPORTED"
  },
  {
    EFI_PERIPHERAL_REMOVABLE_MEDIA | EFI_P_EC_NOT_DETECTED,
    "NOT_DETECTED"
  },
  {
    EFI_PERIPHERAL_REMOVABLE_MEDIA | EFI_P_EC_NOT_CONFIGURED,
    "NOT_CONFIGURED"
  },
  {
    EFI_PERIPHERAL_REMOVABLE_MEDIA | EFI_P_EC_INTERFACE_ERROR,
    "INTERFACE_ERROR"
  },
  {
    EFI_PERIPHERAL_REMOVABLE_MEDIA | EFI_P_EC_CONTROLLER_ERROR,
    "CONTROLLER_ERROR"
  },
  {
    EFI_PERIPHERAL_REMOVABLE_MEDIA | EFI_P_EC_INPUT_ERROR,
    "INPUT_ERROR"
  },
  {
    EFI_PERIPHERAL_REMOVABLE_MEDIA | EFI_P_EC_OUTPUT_ERROR,
    "OUTPUT_ERROR"
  },
  {
    EFI_PERIPHERAL_REMOVABLE_MEDIA | EFI_P_EC_RESOURCE_CONFLICT,
    "RESOURCE_CONFLICT"
  },
  {
    EFI_PERIPHERAL_AUDIO_INPUT | EFI_P_EC_NON_SPECIFIC,
    "NON_SPECIFIC"
  },
  {
    EFI_PERIPHERAL_AUDIO_INPUT | EFI_P_EC_DISABLED,
    "DISABLED"
  },
  {
    EFI_PERIPHERAL_AUDIO_INPUT | EFI_P_EC_NOT_SUPPORTED,
    "NOT_SUPPORTED"
  },
  {
    EFI_PERIPHERAL_AUDIO_INPUT | EFI_P_EC_NOT_DETECTED,
    "NOT_DETECTED"
  },
  {
    EFI_PERIPHERAL_AUDIO_INPUT | EFI_P_EC_NOT_CONFIGURED,
    "NOT_CONFIGURED"
  },
  {
    EFI_PERIPHERAL_AUDIO_INPUT | EFI_P_EC_INTERFACE_ERROR,
    "INTERFACE_ERROR"
  },
  {
    EFI_PERIPHERAL_AUDIO_INPUT | EFI_P_EC_CONTROLLER_ERROR,
    "CONTROLLER_ERROR"
  },
  {
    EFI_PERIPHERAL_AUDIO_INPUT | EFI_P_EC_INPUT_ERROR,
    "INPUT_ERROR"
  },
  {
    EFI_PERIPHERAL_AUDIO_INPUT | EFI_P_EC_OUTPUT_ERROR,
    "OUTPUT_ERROR"
  },
  {
    EFI_PERIPHERAL_AUDIO_INPUT | EFI_P_EC_RESOURCE_CONFLICT,
    "RESOURCE_CONFLICT"
  },
  {
    EFI_PERIPHERAL_AUDIO_OUTPUT | EFI_P_EC_NON_SPECIFIC,
    "NON_SPECIFIC"
  },
  {
    EFI_PERIPHERAL_AUDIO_OUTPUT | EFI_P_EC_DISABLED,
    "DISABLED"
  },
  {
    EFI_PERIPHERAL_AUDIO_OUTPUT | EFI_P_EC_NOT_SUPPORTED,
    "NOT_SUPPORTED"
  },
  {
    EFI_PERIPHERAL_AUDIO_OUTPUT | EFI_P_EC_NOT_DETECTED,
    "NOT_DETECTED"
  },
  {
    EFI_PERIPHERAL_AUDIO_OUTPUT | EFI_P_EC_NOT_CONFIGURED,
    "NOT_CONFIGURED"
  },
  {
    EFI_PERIPHERAL_AUDIO_OUTPUT | EFI_P_EC_INTERFACE_ERROR,
    "INTERFACE_ERROR"
  },
  {
    EFI_PERIPHERAL_AUDIO_OUTPUT | EFI_P_EC_CONTROLLER_ERROR,
    "CONTROLLER_ERROR"
  },
  {
    EFI_PERIPHERAL_AUDIO_OUTPUT | EFI_P_EC_INPUT_ERROR,
    "INPUT_ERROR"
  },
  {
    EFI_PERIPHERAL_AUDIO_OUTPUT | EFI_P_EC_OUTPUT_ERROR,
    "OUTPUT_ERROR"
  },
  {
    EFI_PERIPHERAL_AUDIO_OUTPUT | EFI_P_EC_RESOURCE_CONFLICT,
    "RESOURCE_CONFLICT"
  },
  {
    EFI_PERIPHERAL_LCD_DEVICE | EFI_P_EC_NON_SPECIFIC,
    "NON_SPECIFIC"
  },
  {
    EFI_PERIPHERAL_LCD_DEVICE | EFI_P_EC_DISABLED,
    "DISABLED"
  },
  {
    EFI_PERIPHERAL_LCD_DEVICE | EFI_P_EC_NOT_SUPPORTED,
    "NOT_SUPPORTED"
  },
  {
    EFI_PERIPHERAL_LCD_DEVICE | EFI_P_EC_NOT_DETECTED,
    "NOT_DETECTED"
  },
  {
    EFI_PERIPHERAL_LCD_DEVICE | EFI_P_EC_NOT_CONFIGURED,
    "NOT_CONFIGURED"
  },
  {
    EFI_PERIPHERAL_LCD_DEVICE | EFI_P_EC_INTERFACE_ERROR,
    "INTERFACE_ERROR"
  },
  {
    EFI_PERIPHERAL_LCD_DEVICE | EFI_P_EC_CONTROLLER_ERROR,
    "CONTROLLER_ERROR"
  },
  {
    EFI_PERIPHERAL_LCD_DEVICE | EFI_P_EC_INPUT_ERROR,
    "INPUT_ERROR"
  },
  {
    EFI_PERIPHERAL_LCD_DEVICE | EFI_P_EC_OUTPUT_ERROR,
    "OUTPUT_ERROR"
  },
  {
    EFI_PERIPHERAL_LCD_DEVICE | EFI_P_EC_RESOURCE_CONFLICT,
    "RESOURCE_CONFLICT"
  },
  {
    EFI_IO_BUS_UNSPECIFIED | EFI_IOB_EC_NON_SPECIFIC,
    "NON_SPECIFIC"
  },
  {
    EFI_IO_BUS_UNSPECIFIED | EFI_IOB_EC_DISABLED,
    "DISABLED"
  },
  {
    EFI_IO_BUS_UNSPECIFIED | EFI_IOB_EC_NOT_SUPPORTED,
    "NOT_SUPPORTED"
  },
  {
    EFI_IO_BUS_UNSPECIFIED | EFI_IOB_EC_NOT_DETECTED,
    "NOT_DETECTED"
  },
  {
    EFI_IO_BUS_UNSPECIFIED | EFI_IOB_EC_NOT_CONFIGURED,
    "NOT_CONFIGURED"
  },
  {
    EFI_IO_BUS_UNSPECIFIED | EFI_IOB_EC_INTERFACE_ERROR,
    "INTERFACE_ERROR"
  },
  {
    EFI_IO_BUS_UNSPECIFIED | EFI_IOB_EC_CONTROLLER_ERROR,
    "CONTROLLER_ERROR"
  },
  {
    EFI_IO_BUS_UNSPECIFIED | EFI_IOB_EC_READ_ERROR,
    "READ_ERROR"
  },
  {
    EFI_IO_BUS_UNSPECIFIED | EFI_IOB_EC_WRITE_ERROR,
    "WRITE_ERROR"
  },
  {
    EFI_IO_BUS_UNSPECIFIED | EFI_IOB_EC_RESOURCE_CONFLICT,
    "RESOURCE_CONFLICT"
  },
  {
    EFI_IO_BUS_PCI | EFI_IOB_EC_NON_SPECIFIC,
    "NON_SPECIFIC"
  },
  {
    EFI_IO_BUS_PCI | EFI_IOB_EC_DISABLED,
    "DISABLED"
  },
  {
    EFI_IO_BUS_PCI | EFI_IOB_EC_NOT_SUPPORTED,
    "NOT_SUPPORTED"
  },
  {
    EFI_IO_BUS_PCI | EFI_IOB_EC_NOT_DETECTED,
    "NOT_DETECTED"
  },
  {
    EFI_IO_BUS_PCI | EFI_IOB_EC_NOT_CONFIGURED,
    "NOT_CONFIGURED"
  },
  {
    EFI_IO_BUS_PCI | EFI_IOB_EC_INTERFACE_ERROR,
    "INTERFACE_ERROR"
  },
  {
    EFI_IO_BUS_PCI | EFI_IOB_EC_CONTROLLER_ERROR,
    "CONTROLLER_ERROR"
  },
  {
    EFI_IO_BUS_PCI | EFI_IOB_EC_READ_ERROR,
    "READ_ERROR"
  },
  {
    EFI_IO_BUS_PCI | EFI_IOB_EC_WRITE_ERROR,
    "WRITE_ERROR"
  },
  {
    EFI_IO_BUS_PCI | EFI_IOB_EC_RESOURCE_CONFLICT,
    "RESOURCE_CONFLICT"
  },
  {
    EFI_IO_BUS_PCI | EFI_IOB_PCI_EC_PERR,
    "PERR"
  },
  {
    EFI_IO_BUS_PCI | EFI_IOB_PCI_EC_SERR,
    "SERR"
  },
  {
    EFI_IO_BUS_USB | EFI_IOB_EC_NON_SPECIFIC,
    "NON_SPECIFIC"
  },
  {
    EFI_IO_BUS_USB | EFI_IOB_EC_DISABLED,
    "DISABLED"
  },
  {
    EFI_IO_BUS_USB | EFI_IOB_EC_NOT_SUPPORTED,
    "NOT_SUPPORTED"
  },
  {
    EFI_IO_BUS_USB | EFI_IOB_EC_NOT_DETECTED,
    "NOT_DETECTED"
  },
  {
    EFI_IO_BUS_USB | EFI_IOB_EC_NOT_CONFIGURED,
    "NOT_CONFIGURED"
  },
  {
    EFI_IO_BUS_USB | EFI_IOB_EC_INTERFACE_ERROR,
    "INTERFACE_ERROR"
  },
  {
    EFI_IO_BUS_USB | EFI_IOB_EC_CONTROLLER_ERROR,
    "CONTROLLER_ERROR"
  },
  {
    EFI_IO_BUS_USB | EFI_IOB_EC_READ_ERROR,
    "READ_ERROR"
  },
  {
    EFI_IO_BUS_USB | EFI_IOB_EC_WRITE_ERROR,
    "WRITE_ERROR"
  },
  {
    EFI_IO_BUS_USB | EFI_IOB_EC_RESOURCE_CONFLICT,
    "RESOURCE_CONFLICT"
  },
  {
    EFI_IO_BUS_IBA | EFI_IOB_EC_NON_SPECIFIC,
    "NON_SPECIFIC"
  },
  {
    EFI_IO_BUS_IBA | EFI_IOB_EC_DISABLED,
    "DISABLED"
  },
  {
    EFI_IO_BUS_IBA | EFI_IOB_EC_NOT_SUPPORTED,
    "NOT_SUPPORTED"
  },
  {
    EFI_IO_BUS_IBA | EFI_IOB_EC_NOT_DETECTED,
    "NOT_DETECTED"
  },
  {
    EFI_IO_BUS_IBA | EFI_IOB_EC_NOT_CONFIGURED,
    "NOT_CONFIGURED"
  },
  {
    EFI_IO_BUS_IBA | EFI_IOB_EC_INTERFACE_ERROR,
    "INTERFACE_ERROR"
  },
  {
    EFI_IO_BUS_IBA | EFI_IOB_EC_CONTROLLER_ERROR,
    "CONTROLLER_ERROR"
  },
  {
    EFI_IO_BUS_IBA | EFI_IOB_EC_READ_ERROR,
    "READ_ERROR"
  },
  {
    EFI_IO_BUS_IBA | EFI_IOB_EC_WRITE_ERROR,
    "WRITE_ERROR"
  },
  {
    EFI_IO_BUS_IBA | EFI_IOB_EC_RESOURCE_CONFLICT,
    "RESOURCE_CONFLICT"
  },
  {
    EFI_IO_BUS_AGP | EFI_IOB_EC_NON_SPECIFIC,
    "NON_SPECIFIC"
  },
  {
    EFI_IO_BUS_AGP | EFI_IOB_EC_DISABLED,
    "DISABLED"
  },
  {
    EFI_IO_BUS_AGP | EFI_IOB_EC_NOT_SUPPORTED,
    "NOT_SUPPORTED"
  },
  {
    EFI_IO_BUS_AGP | EFI_IOB_EC_NOT_DETECTED,
    "NOT_DETECTED"
  },
  {
    EFI_IO_BUS_AGP | EFI_IOB_EC_NOT_CONFIGURED,
    "NOT_CONFIGURED"
  },
  {
    EFI_IO_BUS_AGP | EFI_IOB_EC_INTERFACE_ERROR,
    "INTERFACE_ERROR"
  },
  {
    EFI_IO_BUS_AGP | EFI_IOB_EC_CONTROLLER_ERROR,
    "CONTROLLER_ERROR"
  },
  {
    EFI_IO_BUS_AGP | EFI_IOB_EC_READ_ERROR,
    "READ_ERROR"
  },
  {
    EFI_IO_BUS_AGP | EFI_IOB_EC_WRITE_ERROR,
    "WRITE_ERROR"
  },
  {
    EFI_IO_BUS_AGP | EFI_IOB_EC_RESOURCE_CONFLICT,
    "RESOURCE_CONFLICT"
  },
  {
    EFI_IO_BUS_PC_CARD | EFI_IOB_EC_NON_SPECIFIC,
    "NON_SPECIFIC"
  },
  {
    EFI_IO_BUS_PC_CARD | EFI_IOB_EC_DISABLED,
    "DISABLED"
  },
  {
    EFI_IO_BUS_PC_CARD | EFI_IOB_EC_NOT_SUPPORTED,
    "NOT_SUPPORTED"
  },
  {
    EFI_IO_BUS_PC_CARD | EFI_IOB_EC_NOT_DETECTED,
    "NOT_DETECTED"
  },
  {
    EFI_IO_BUS_PC_CARD | EFI_IOB_EC_NOT_CONFIGURED,
    "NOT_CONFIGURED"
  },
  {
    EFI_IO_BUS_PC_CARD | EFI_IOB_EC_INTERFACE_ERROR,
    "INTERFACE_ERROR"
  },
  {
    EFI_IO_BUS_PC_CARD | EFI_IOB_EC_CONTROLLER_ERROR,
    "CONTROLLER_ERROR"
  },
  {
    EFI_IO_BUS_PC_CARD | EFI_IOB_EC_READ_ERROR,
    "READ_ERROR"
  },
  {
    EFI_IO_BUS_PC_CARD | EFI_IOB_EC_WRITE_ERROR,
    "WRITE_ERROR"
  },
  {
    EFI_IO_BUS_PC_CARD | EFI_IOB_EC_RESOURCE_CONFLICT,
    "RESOURCE_CONFLICT"
  },
  {
    EFI_IO_BUS_LPC | EFI_IOB_EC_NON_SPECIFIC,
    "NON_SPECIFIC"
  },
  {
    EFI_IO_BUS_LPC | EFI_IOB_EC_DISABLED,
    "DISABLED"
  },
  {
    EFI_IO_BUS_LPC | EFI_IOB_EC_NOT_SUPPORTED,
    "NOT_SUPPORTED"
  },
  {
    EFI_IO_BUS_LPC | EFI_IOB_EC_NOT_DETECTED,
    "NOT_DETECTED"
  },
  {
    EFI_IO_BUS_LPC | EFI_IOB_EC_NOT_CONFIGURED,
    "NOT_CONFIGURED"
  },
  {
    EFI_IO_BUS_LPC | EFI_IOB_EC_INTERFACE_ERROR,
    "INTERFACE_ERROR"
  },
  {
    EFI_IO_BUS_LPC | EFI_IOB_EC_CONTROLLER_ERROR,
    "CONTROLLER_ERROR"
  },
  {
    EFI_IO_BUS_LPC | EFI_IOB_EC_READ_ERROR,
    "READ_ERROR"
  },
  {
    EFI_IO_BUS_LPC | EFI_IOB_EC_WRITE_ERROR,
    "WRITE_ERROR"
  },
  {
    EFI_IO_BUS_LPC | EFI_IOB_EC_RESOURCE_CONFLICT,
    "RESOURCE_CONFLICT"
  },
  {
    EFI_IO_BUS_SCSI | EFI_IOB_EC_NON_SPECIFIC,
    "NON_SPECIFIC"
  },
  {
    EFI_IO_BUS_SCSI | EFI_IOB_EC_DISABLED,
    "DISABLED"
  },
  {
    EFI_IO_BUS_SCSI | EFI_IOB_EC_NOT_SUPPORTED,
    "NOT_SUPPORTED"
  },
  {
    EFI_IO_BUS_SCSI | EFI_IOB_EC_NOT_DETECTED,
    "NOT_DETECTED"
  },
  {
    EFI_IO_BUS_SCSI | EFI_IOB_EC_NOT_CONFIGURED,
    "NOT_CONFIGURED"
  },
  {
    EFI_IO_BUS_SCSI | EFI_IOB_EC_INTERFACE_ERROR,
    "INTERFACE_ERROR"
  },
  {
    EFI_IO_BUS_SCSI | EFI_IOB_EC_CONTROLLER_ERROR,
    "CONTROLLER_ERROR"
  },
  {
    EFI_IO_BUS_SCSI | EFI_IOB_EC_READ_ERROR,
    "READ_ERROR"
  },
  {
    EFI_IO_BUS_SCSI | EFI_IOB_EC_WRITE_ERROR,
    "WRITE_ERROR"
  },
  {
    EFI_IO_BUS_SCSI | EFI_IOB_EC_RESOURCE_CONFLICT,
    "RESOURCE_CONFLICT"
  },
  {
    EFI_IO_BUS_ATA_ATAPI | EFI_IOB_EC_NON_SPECIFIC,
    "NON_SPECIFIC"
  },
  {
    EFI_IO_BUS_ATA_ATAPI | EFI_IOB_EC_DISABLED,
    "DISABLED"
  },
  {
    EFI_IO_BUS_ATA_ATAPI | EFI_IOB_EC_NOT_SUPPORTED,
    "NOT_SUPPORTED"
  },
  {
    EFI_IO_BUS_ATA_ATAPI | EFI_IOB_EC_NOT_DETECTED,
    "NOT_DETECTED"
  },
  {
    EFI_IO_BUS_ATA_ATAPI | EFI_IOB_EC_NOT_CONFIGURED,
    "NOT_CONFIGURED"
  },
  {
    EFI_IO_BUS_ATA_ATAPI | EFI_IOB_EC_INTERFACE_ERROR,
    "INTERFACE_ERROR"
  },
  {
    EFI_IO_BUS_ATA_ATAPI | EFI_IOB_EC_CONTROLLER_ERROR,
    "CONTROLLER_ERROR"
  },
  {
    EFI_IO_BUS_ATA_ATAPI | EFI_IOB_EC_READ_ERROR,
    "READ_ERROR"
  },
  {
    EFI_IO_BUS_ATA_ATAPI | EFI_IOB_EC_WRITE_ERROR,
    "WRITE_ERROR"
  },
  {
    EFI_IO_BUS_ATA_ATAPI | EFI_IOB_EC_RESOURCE_CONFLICT,
    "RESOURCE_CONFLICT"
  },
  {
    EFI_IO_BUS_FC | EFI_IOB_EC_NON_SPECIFIC,
    "NON_SPECIFIC"
  },
  {
    EFI_IO_BUS_FC | EFI_IOB_EC_DISABLED,
    "DISABLED"
  },
  {
    EFI_IO_BUS_FC | EFI_IOB_EC_NOT_SUPPORTED,
    "NOT_SUPPORTED"
  },
  {
    EFI_IO_BUS_FC | EFI_IOB_EC_NOT_DETECTED,
    "NOT_DETECTED"
  },
  {
    EFI_IO_BUS_FC | EFI_IOB_EC_NOT_CONFIGURED,
    "NOT_CONFIGURED"
  },
  {
    EFI_IO_BUS_FC | EFI_IOB_EC_INTERFACE_ERROR,
    "INTERFACE_ERROR"
  },
  {
    EFI_IO_BUS_FC | EFI_IOB_EC_CONTROLLER_ERROR,
    "CONTROLLER_ERROR"
  },
  {
    EFI_IO_BUS_FC | EFI_IOB_EC_READ_ERROR,
    "READ_ERROR"
  },
  {
    EFI_IO_BUS_FC | EFI_IOB_EC_WRITE_ERROR,
    "WRITE_ERROR"
  },
  {
    EFI_IO_BUS_FC | EFI_IOB_EC_RESOURCE_CONFLICT,
    "RESOURCE_CONFLICT"
  },
  {
    EFI_IO_BUS_IP_NETWORK | EFI_IOB_EC_NON_SPECIFIC,
    "NON_SPECIFIC"
  },
  {
    EFI_IO_BUS_IP_NETWORK | EFI_IOB_EC_DISABLED,
    "DISABLED"
  },
  {
    EFI_IO_BUS_IP_NETWORK | EFI_IOB_EC_NOT_SUPPORTED,
    "NOT_SUPPORTED"
  },
  {
    EFI_IO_BUS_IP_NETWORK | EFI_IOB_EC_NOT_DETECTED,
    "NOT_DETECTED"
  },
  {
    EFI_IO_BUS_IP_NETWORK | EFI_IOB_EC_NOT_CONFIGURED,
    "NOT_CONFIGURED"
  },
  {
    EFI_IO_BUS_IP_NETWORK | EFI_IOB_EC_INTERFACE_ERROR,
    "INTERFACE_ERROR"
  },
  {
    EFI_IO_BUS_IP_NETWORK | EFI_IOB_EC_CONTROLLER_ERROR,
    "CONTROLLER_ERROR"
  },
  {
    EFI_IO_BUS_IP_NETWORK | EFI_IOB_EC_READ_ERROR,
    "READ_ERROR"
  },
  {
    EFI_IO_BUS_IP_NETWORK | EFI_IOB_EC_WRITE_ERROR,
    "WRITE_ERROR"
  },
  {
    EFI_IO_BUS_IP_NETWORK | EFI_IOB_EC_RESOURCE_CONFLICT,
    "RESOURCE_CONFLICT"
  },
  {
    EFI_IO_BUS_SMBUS | EFI_IOB_EC_NON_SPECIFIC,
    "NON_SPECIFIC"
  },
  {
    EFI_IO_BUS_SMBUS | EFI_IOB_EC_DISABLED,
    "DISABLED"
  },
  {
    EFI_IO_BUS_SMBUS | EFI_IOB_EC_NOT_SUPPORTED,
    "NOT_SUPPORTED"
  },
  {
    EFI_IO_BUS_SMBUS | EFI_IOB_EC_NOT_DETECTED,
    "NOT_DETECTED"
  },
  {
    EFI_IO_BUS_SMBUS | EFI_IOB_EC_NOT_CONFIGURED,
    "NOT_CONFIGURED"
  },
  {
    EFI_IO_BUS_SMBUS | EFI_IOB_EC_INTERFACE_ERROR,
    "INTERFACE_ERROR"
  },
  {
    EFI_IO_BUS_SMBUS | EFI_IOB_EC_CONTROLLER_ERROR,
    "CONTROLLER_ERROR"
  },
  {
    EFI_IO_BUS_SMBUS | EFI_IOB_EC_READ_ERROR,
    "READ_ERROR"
  },
  {
    EFI_IO_BUS_SMBUS | EFI_IOB_EC_WRITE_ERROR,
    "WRITE_ERROR"
  },
  {
    EFI_IO_BUS_SMBUS | EFI_IOB_EC_RESOURCE_CONFLICT,
    "RESOURCE_CONFLICT"
  },
  {
    EFI_IO_BUS_I2C | EFI_IOB_EC_NON_SPECIFIC,
    "NON_SPECIFIC"
  },
  {
    EFI_IO_BUS_I2C | EFI_IOB_EC_DISABLED,
    "DISABLED"
  },
  {
    EFI_IO_BUS_I2C | EFI_IOB_EC_NOT_SUPPORTED,
    "NOT_SUPPORTED"
  },
  {
    EFI_IO_BUS_I2C | EFI_IOB_EC_NOT_DETECTED,
    "NOT_DETECTED"
  },
  {
    EFI_IO_BUS_I2C | EFI_IOB_EC_NOT_CONFIGURED,
    "NOT_CONFIGURED"
  },
  {
    EFI_IO_BUS_I2C | EFI_IOB_EC_INTERFACE_ERROR,
    "INTERFACE_ERROR"
  },
  {
    EFI_IO_BUS_I2C | EFI_IOB_EC_CONTROLLER_ERROR,
    "CONTROLLER_ERROR"
  },
  {
    EFI_IO_BUS_I2C | EFI_IOB_EC_READ_ERROR,
    "READ_ERROR"
  },
  {
    EFI_IO_BUS_I2C | EFI_IOB_EC_WRITE_ERROR,
    "WRITE_ERROR"
  },
  {
    EFI_IO_BUS_I2C | EFI_IOB_EC_RESOURCE_CONFLICT,
    "RESOURCE_CONFLICT"
  },
  {
    EFI_SOFTWARE_UNSPECIFIED | EFI_SW_EC_NON_SPECIFIC,
    "NON_SPECIFIC"
  },
  {
    EFI_SOFTWARE_UNSPECIFIED | EFI_SW_EC_LOAD_ERROR,
    "LOAD_ERROR"
  },
  {
    EFI_SOFTWARE_UNSPECIFIED | EFI_SW_EC_INVALID_PARAMETER,
    "INVALID_PARAMETER"
  },
  {
    EFI_SOFTWARE_UNSPECIFIED | EFI_SW_EC_UNSUPPORTED,
    "NOT_SUPPORTED"
  },
  {
    EFI_SOFTWARE_UNSPECIFIED | EFI_SW_EC_INVALID_BUFFER,
    "INVALID_BUFFER"
  },
  {
    EFI_SOFTWARE_UNSPECIFIED | EFI_SW_EC_OUT_OF_RESOURCES,
    "OUT_OF_RESOURCES"
  },
  {
    EFI_SOFTWARE_UNSPECIFIED | EFI_SW_EC_ABORTED,
    "ABORTED"
  },
  {
    EFI_SOFTWARE_UNSPECIFIED | EFI_SW_EC_ILLEGAL_SOFTWARE_STATE,
    "ILLEGAL_SOFTWARE_STATE"
  },
  {
    EFI_SOFTWARE_UNSPECIFIED | EFI_SW_EC_ILLEGAL_HARDWARE_STATE,
    "ILLEGAL_HARDWARE_STATE"
  },
  {
    EFI_SOFTWARE_SEC | EFI_SW_EC_NON_SPECIFIC,
    "NON_SPECIFIC"
  },
  {
    EFI_SOFTWARE_SEC | EFI_SW_EC_LOAD_ERROR,
    "LOAD_ERROR"
  },
  {
    EFI_SOFTWARE_SEC | EFI_SW_EC_INVALID_PARAMETER,
    "INVALID_PARAMETER"
  },
  {
    EFI_SOFTWARE_SEC | EFI_SW_EC_UNSUPPORTED,
    "NOT_SUPPORTED"
  },
  {
    EFI_SOFTWARE_SEC | EFI_SW_EC_INVALID_BUFFER,
    "INVALID_BUFFER"
  },
  {
    EFI_SOFTWARE_SEC | EFI_SW_EC_OUT_OF_RESOURCES,
    "OUT_OF_RESOURCES"
  },
  {
    EFI_SOFTWARE_SEC | EFI_SW_EC_ABORTED,
    "ABORTED"
  },
  {
    EFI_SOFTWARE_SEC | EFI_SW_EC_ILLEGAL_SOFTWARE_STATE,
    "ILLEGAL_SOFTWARE_STATE"
  },
  {
    EFI_SOFTWARE_SEC | EFI_SW_EC_ILLEGAL_HARDWARE_STATE,
    "ILLEGAL_HARDWARE_STATE"
  },
  {
    EFI_SOFTWARE_PEI_CORE | EFI_SW_EC_NON_SPECIFIC,
    "NON_SPECIFIC"
  },
  {
    EFI_SOFTWARE_PEI_CORE | EFI_SW_EC_LOAD_ERROR,
    "LOAD_ERROR"
  },
  {
    EFI_SOFTWARE_PEI_CORE | EFI_SW_EC_INVALID_PARAMETER,
    "INVALID_PARAMETER"
  },
  {
    EFI_SOFTWARE_PEI_CORE | EFI_SW_EC_UNSUPPORTED,
    "NOT_SUPPORTED"
  },
  {
    EFI_SOFTWARE_PEI_CORE | EFI_SW_EC_INVALID_BUFFER,
    "INVALID_BUFFER"
  },
  {
    EFI_SOFTWARE_PEI_CORE | EFI_SW_EC_OUT_OF_RESOURCES,
    "OUT_OF_RESOURCES"
  },
  {
    EFI_SOFTWARE_PEI_CORE | EFI_SW_EC_ABORTED,
    "ABORTED"
  },
  {
    EFI_SOFTWARE_PEI_CORE | EFI_SW_EC_ILLEGAL_SOFTWARE_STATE,
    "ILLEGAL_SOFTWARE_STATE"
  },
  {
    EFI_SOFTWARE_PEI_CORE | EFI_SW_EC_ILLEGAL_HARDWARE_STATE,
    "ILLEGAL_HARDWARE_STATE"
  },
  {
    EFI_SOFTWARE_PEI_MODULE | EFI_SW_EC_NON_SPECIFIC,
    "NON_SPECIFIC"
  },
  {
    EFI_SOFTWARE_PEI_MODULE | EFI_SW_EC_LOAD_ERROR,
    "LOAD_ERROR"
  },
  {
    EFI_SOFTWARE_PEI_MODULE | EFI_SW_EC_INVALID_PARAMETER,
    "INVALID_PARAMETER"
  },
  {
    EFI_SOFTWARE_PEI_MODULE | EFI_SW_EC_UNSUPPORTED,
    "NOT_SUPPORTED"
  },
  {
    EFI_SOFTWARE_PEI_MODULE | EFI_SW_EC_INVALID_BUFFER,
    "INVALID_BUFFER"
  },
  {
    EFI_SOFTWARE_PEI_MODULE | EFI_SW_EC_OUT_OF_RESOURCES,
    "OUT_OF_RESOURCES"
  },
  {
    EFI_SOFTWARE_PEI_MODULE | EFI_SW_EC_ABORTED,
    "ABORTED"
  },
  {
    EFI_SOFTWARE_PEI_MODULE | EFI_SW_EC_ILLEGAL_SOFTWARE_STATE,
    "ILLEGAL_SOFTWARE_STATE"
  },
  {
    EFI_SOFTWARE_PEI_MODULE | EFI_SW_EC_ILLEGAL_HARDWARE_STATE,
    "ILLEGAL_HARDWARE_STATE"
  },
  {
    EFI_SOFTWARE_DXE_CORE | EFI_SW_EC_NON_SPECIFIC,
    "NON_SPECIFIC"
  },
  {
    EFI_SOFTWARE_DXE_CORE | EFI_SW_EC_LOAD_ERROR,
    "LOAD_ERROR"
  },
  {
    EFI_SOFTWARE_DXE_CORE | EFI_SW_EC_INVALID_PARAMETER,
    "INVALID_PARAMETER"
  },
  {
    EFI_SOFTWARE_DXE_CORE | EFI_SW_EC_UNSUPPORTED,
    "NOT_SUPPORTED"
  },
  {
    EFI_SOFTWARE_DXE_CORE | EFI_SW_EC_INVALID_BUFFER,
    "INVALID_BUFFER"
  },
  {
    EFI_SOFTWARE_DXE_CORE | EFI_SW_EC_OUT_OF_RESOURCES,
    "OUT_OF_RESOURCES"
  },
  {
    EFI_SOFTWARE_DXE_CORE | EFI_SW_EC_ABORTED,
    "ABORTED"
  },
  {
    EFI_SOFTWARE_DXE_CORE | EFI_SW_EC_ILLEGAL_SOFTWARE_STATE,
    "ILLEGAL_SOFTWARE_STATE"
  },
  {
    EFI_SOFTWARE_DXE_CORE | EFI_SW_EC_ILLEGAL_HARDWARE_STATE,
    "ILLEGAL_HARDWARE_STATE"
  },
  {
    EFI_SOFTWARE_EFI_BOOT_SERVICE | EFI_SW_EC_NON_SPECIFIC,
    "NON_SPECIFIC"
  },
  {
    EFI_SOFTWARE_EFI_BOOT_SERVICE | EFI_SW_EC_LOAD_ERROR,
    "LOAD_ERROR"
  },
  {
    EFI_SOFTWARE_EFI_BOOT_SERVICE | EFI_SW_EC_INVALID_PARAMETER,
    "INVALID_PARAMETER"
  },
  {
    EFI_SOFTWARE_EFI_BOOT_SERVICE | EFI_SW_EC_UNSUPPORTED,
    "NOT_SUPPORTED"
  },
  {
    EFI_SOFTWARE_EFI_BOOT_SERVICE | EFI_SW_EC_INVALID_BUFFER,
    "INVALID_BUFFER"
  },
  {
    EFI_SOFTWARE_EFI_BOOT_SERVICE | EFI_SW_EC_OUT_OF_RESOURCES,
    "OUT_OF_RESOURCES"
  },
  {
    EFI_SOFTWARE_EFI_BOOT_SERVICE | EFI_SW_EC_ABORTED,
    "ABORTED"
  },
  {
    EFI_SOFTWARE_EFI_BOOT_SERVICE | EFI_SW_EC_ILLEGAL_SOFTWARE_STATE,
    "ILLEGAL_SOFTWARE_STATE"
  },
  {
    EFI_SOFTWARE_EFI_BOOT_SERVICE | EFI_SW_EC_ILLEGAL_HARDWARE_STATE,
    "ILLEGAL_HARDWARE_STATE"
  },
  {
    EFI_SOFTWARE_EFI_RUNTIME_SERVICE | EFI_SW_EC_NON_SPECIFIC,
    "NON_SPECIFIC"
  },
  {
    EFI_SOFTWARE_EFI_RUNTIME_SERVICE | EFI_SW_EC_LOAD_ERROR,
    "LOAD_ERROR"
  },
  {
    EFI_SOFTWARE_EFI_RUNTIME_SERVICE | EFI_SW_EC_INVALID_PARAMETER,
    "INVALID_PARAMETER"
  },
  {
    EFI_SOFTWARE_EFI_RUNTIME_SERVICE | EFI_SW_EC_UNSUPPORTED,
    "NOT_SUPPORTED"
  },
  {
    EFI_SOFTWARE_EFI_RUNTIME_SERVICE | EFI_SW_EC_INVALID_BUFFER,
    "INVALID_BUFFER"
  },
  {
    EFI_SOFTWARE_EFI_RUNTIME_SERVICE | EFI_SW_EC_OUT_OF_RESOURCES,
    "OUT_OF_RESOURCES"
  },
  {
    EFI_SOFTWARE_EFI_RUNTIME_SERVICE | EFI_SW_EC_ABORTED,
    "ABORTED"
  },
  {
    EFI_SOFTWARE_EFI_RUNTIME_SERVICE | EFI_SW_EC_ILLEGAL_SOFTWARE_STATE,
    "ILLEGAL_SOFTWARE_STATE"
  },
  {
    EFI_SOFTWARE_EFI_RUNTIME_SERVICE | EFI_SW_EC_ILLEGAL_HARDWARE_STATE,
    "ILLEGAL_HARDWARE_STATE"
  },
  {
    EFI_SOFTWARE_DXE_BS_DRIVER | EFI_SW_EC_NON_SPECIFIC,
    "NON_SPECIFIC"
  },
  {
    EFI_SOFTWARE_DXE_BS_DRIVER | EFI_SW_EC_LOAD_ERROR,
    "LOAD_ERROR"
  },
  {
    EFI_SOFTWARE_DXE_BS_DRIVER | EFI_SW_EC_INVALID_PARAMETER,
    "INVALID_PARAMETER"
  },
  {
    EFI_SOFTWARE_DXE_BS_DRIVER | EFI_SW_EC_UNSUPPORTED,
    "NOT_SUPPORTED"
  },
  {
    EFI_SOFTWARE_DXE_BS_DRIVER | EFI_SW_EC_INVALID_BUFFER,
    "INVALID_BUFFER"
  },
  {
    EFI_SOFTWARE_DXE_BS_DRIVER | EFI_SW_EC_OUT_OF_RESOURCES,
    "OUT_OF_RESOURCES"
  },
  {
    EFI_SOFTWARE_DXE_BS_DRIVER | EFI_SW_EC_ABORTED,
    "ABORTED"
  },
  {
    EFI_SOFTWARE_DXE_BS_DRIVER | EFI_SW_EC_ILLEGAL_SOFTWARE_STATE,
    "ILLEGAL_SOFTWARE_STATE"
  },
  {
    EFI_SOFTWARE_DXE_BS_DRIVER | EFI_SW_EC_ILLEGAL_HARDWARE_STATE,
    "ILLEGAL_HARDWARE_STATE"
  },
  {
    EFI_SOFTWARE_DXE_RT_DRIVER | EFI_SW_EC_NON_SPECIFIC,
    "NON_SPECIFIC"
  },
  {
    EFI_SOFTWARE_DXE_RT_DRIVER | EFI_SW_EC_LOAD_ERROR,
    "LOAD_ERROR"
  },
  {
    EFI_SOFTWARE_DXE_RT_DRIVER | EFI_SW_EC_INVALID_PARAMETER,
    "INVALID_PARAMETER"
  },
  {
    EFI_SOFTWARE_DXE_RT_DRIVER | EFI_SW_EC_UNSUPPORTED,
    "NOT_SUPPORTED"
  },
  {
    EFI_SOFTWARE_DXE_RT_DRIVER | EFI_SW_EC_INVALID_BUFFER,
    "INVALID_BUFFER"
  },
  {
    EFI_SOFTWARE_DXE_RT_DRIVER | EFI_SW_EC_OUT_OF_RESOURCES,
    "OUT_OF_RESOURCES"
  },
  {
    EFI_SOFTWARE_DXE_RT_DRIVER | EFI_SW_EC_ABORTED,
    "ABORTED"
  },
  {
    EFI_SOFTWARE_DXE_RT_DRIVER | EFI_SW_EC_ILLEGAL_SOFTWARE_STATE,
    "ILLEGAL_SOFTWARE_STATE"
  },
  {
    EFI_SOFTWARE_DXE_RT_DRIVER | EFI_SW_EC_ILLEGAL_HARDWARE_STATE,
    "ILLEGAL_HARDWARE_STATE"
  },
  {
    EFI_SOFTWARE_SMM_DRIVER | EFI_SW_EC_NON_SPECIFIC,
    "NON_SPECIFIC"
  },
  {
    EFI_SOFTWARE_SMM_DRIVER | EFI_SW_EC_LOAD_ERROR,
    "LOAD_ERROR"
  },
  {
    EFI_SOFTWARE_SMM_DRIVER | EFI_SW_EC_INVALID_PARAMETER,
    "INVALID_PARAMETER"
  },
  {
    EFI_SOFTWARE_SMM_DRIVER | EFI_SW_EC_UNSUPPORTED,
    "NOT_SUPPORTED"
  },
  {
    EFI_SOFTWARE_SMM_DRIVER | EFI_SW_EC_INVALID_BUFFER,
    "INVALID_BUFFER"
  },
  {
    EFI_SOFTWARE_SMM_DRIVER | EFI_SW_EC_OUT_OF_RESOURCES,
    "OUT_OF_RESOURCES"
  },
  {
    EFI_SOFTWARE_SMM_DRIVER | EFI_SW_EC_ABORTED,
    "ABORTED"
  },
  {
    EFI_SOFTWARE_SMM_DRIVER | EFI_SW_EC_ILLEGAL_SOFTWARE_STATE,
    "ILLEGAL_SOFTWARE_STATE"
  },
  {
    EFI_SOFTWARE_SMM_DRIVER | EFI_SW_EC_ILLEGAL_HARDWARE_STATE,
    "ILLEGAL_HARDWARE_STATE"
  },
  {
    EFI_SOFTWARE_RT | EFI_SW_EC_NON_SPECIFIC,
    "NON_SPECIFIC"
  },
  {
    EFI_SOFTWARE_RT | EFI_SW_EC_LOAD_ERROR,
    "LOAD_ERROR"
  },
  {
    EFI_SOFTWARE_RT | EFI_SW_EC_INVALID_PARAMETER,
    "INVALID_PARAMETER"
  },
  {
    EFI_SOFTWARE_RT | EFI_SW_EC_UNSUPPORTED,
    "NOT_SUPPORTED"
  },
  {
    EFI_SOFTWARE_RT | EFI_SW_EC_INVALID_BUFFER,
    "INVALID_BUFFER"
  },
  {
    EFI_SOFTWARE_RT | EFI_SW_EC_OUT_OF_RESOURCES,
    "OUT_OF_RESOURCES"
  },
  {
    EFI_SOFTWARE_RT | EFI_SW_EC_ABORTED,
    "ABORTED"
  },
  {
    EFI_SOFTWARE_RT | EFI_SW_EC_ILLEGAL_SOFTWARE_STATE,
    "ILLEGAL_SOFTWARE_STATE"
  },
  {
    EFI_SOFTWARE_RT | EFI_SW_EC_ILLEGAL_HARDWARE_STATE,
    "ILLEGAL_HARDWARE_STATE"
  },
  {
    EFI_SOFTWARE_AL | EFI_SW_EC_NON_SPECIFIC,
    "NON_SPECIFIC"
  },
  {
    EFI_SOFTWARE_AL | EFI_SW_EC_LOAD_ERROR,
    "LOAD_ERROR"
  },
  {
    EFI_SOFTWARE_AL | EFI_SW_EC_INVALID_PARAMETER,
    "INVALID_PARAMETER"
  },
  {
    EFI_SOFTWARE_AL | EFI_SW_EC_UNSUPPORTED,
    "NOT_SUPPORTED"
  },
  {
    EFI_SOFTWARE_AL | EFI_SW_EC_INVALID_BUFFER,
    "INVALID_BUFFER"
  },
  {
    EFI_SOFTWARE_AL | EFI_SW_EC_OUT_OF_RESOURCES,
    "OUT_OF_RESOURCES"
  },
  {
    EFI_SOFTWARE_AL | EFI_SW_EC_ABORTED,
    "ABORTED"
  },
  {
    EFI_SOFTWARE_AL | EFI_SW_EC_ILLEGAL_SOFTWARE_STATE,
    "ILLEGAL_SOFTWARE_STATE"
  },
  {
    EFI_SOFTWARE_AL | EFI_SW_EC_ILLEGAL_HARDWARE_STATE,
    "ILLEGAL_HARDWARE_STATE"
  },
  {
    EFI_SOFTWARE_EFI_APPLICATION | EFI_SW_EC_NON_SPECIFIC,
    "NON_SPECIFIC"
  },
  {
    EFI_SOFTWARE_EFI_APPLICATION | EFI_SW_EC_LOAD_ERROR,
    "LOAD_ERROR"
  },
  {
    EFI_SOFTWARE_EFI_APPLICATION | EFI_SW_EC_INVALID_PARAMETER,
    "INVALID_PARAMETER"
  },
  {
    EFI_SOFTWARE_EFI_APPLICATION | EFI_SW_EC_UNSUPPORTED,
    "NOT_SUPPORTED"
  },
  {
    EFI_SOFTWARE_EFI_APPLICATION | EFI_SW_EC_INVALID_BUFFER,
    "INVALID_BUFFER"
  },
  {
    EFI_SOFTWARE_EFI_APPLICATION | EFI_SW_EC_OUT_OF_RESOURCES,
    "OUT_OF_RESOURCES"
  },
  {
    EFI_SOFTWARE_EFI_APPLICATION | EFI_SW_EC_ABORTED,
    "ABORTED"
  },
  {
    EFI_SOFTWARE_EFI_APPLICATION | EFI_SW_EC_ILLEGAL_SOFTWARE_STATE,
    "ILLEGAL_SOFTWARE_STATE"
  },
  {
    EFI_SOFTWARE_EFI_APPLICATION | EFI_SW_EC_ILLEGAL_HARDWARE_STATE,
    "ILLEGAL_HARDWARE_STATE"
  },
  {
    EFI_SOFTWARE_EFI_OS_LOADER | EFI_SW_EC_NON_SPECIFIC,
    "NON_SPECIFIC"
  },
  {
    EFI_SOFTWARE_EFI_OS_LOADER | EFI_SW_EC_LOAD_ERROR,
    "LOAD_ERROR"
  },
  {
    EFI_SOFTWARE_EFI_OS_LOADER | EFI_SW_EC_INVALID_PARAMETER,
    "INVALID_PARAMETER"
  },
  {
    EFI_SOFTWARE_EFI_OS_LOADER | EFI_SW_EC_UNSUPPORTED,
    "NOT_SUPPORTED"
  },
  {
    EFI_SOFTWARE_EFI_OS_LOADER | EFI_SW_EC_INVALID_BUFFER,
    "INVALID_BUFFER"
  },
  {
    EFI_SOFTWARE_EFI_OS_LOADER | EFI_SW_EC_OUT_OF_RESOURCES,
    "OUT_OF_RESOURCES"
  },
  {
    EFI_SOFTWARE_EFI_OS_LOADER | EFI_SW_EC_ABORTED,
    "ABORTED"
  },
  {
    EFI_SOFTWARE_EFI_OS_LOADER | EFI_SW_EC_ILLEGAL_SOFTWARE_STATE,
    "ILLEGAL_SOFTWARE_STATE"
  },
  {
    EFI_SOFTWARE_EFI_OS_LOADER | EFI_SW_EC_ILLEGAL_HARDWARE_STATE,
    "ILLEGAL_HARDWARE_STATE"
  },
  {
    0xFFFFFFFF,
    "ERROR_UNRECOGNIZED"
  }
};

#endif
//
// Private function declarations
//
//
// Match is only needed for debug.
//
#ifdef EFI_DEBUG

EFI_STATUS
EFIAPI
MatchStrings (
  IN  STATUS_CODE_LOOKUP_TABLE  *Table,
  IN  UINT32                    Value,
  OUT CHAR8                     **Token
  );
#endif

VOID*
EFIAPI
GetDebugCommPrivateData(
  );
//
// Internal Functions
//
STATIC
EFI_STATUS
GetProtocol (
  IN  EFI_HOB_HANDOFF_INFO_TABLE   *HobTable,
  IN  EFI_GUID                     *Guid,
  IN  VOID                         **Interface
  );

STATIC
EFI_STATUS
SetProtocol (
  IN  EFI_HOB_HANDOFF_INFO_TABLE   *HobTable,
  IN  EFI_GUID                     *Guid,
  IN  VOID                         *Interface
  );

STATIC
EFI_USB_DBG_REG*
GetDebugPointer (
  VOID
  );


STATIC
UINT32
ReadBAR (
  VOID
  );

STATIC
EFI_USB_DEVICE_REQUEST GetDeviceDescriptor =
{
  GET_DESC_REQ_TYPE,
  GET_DESC_REQ,
  (DEVICE_TYPE << 8),
  0,
  8
};

STATIC
EFI_USB_DEVICE_REQUEST GetDebugDescriptor =
{
  GET_DESC_REQ_TYPE,
  GET_DESC_REQ,
  (DEBUG_TYPE << 8),
  0,
  4
};

STATIC
EFI_USB_DEVICE_REQUEST SetDeviceAddress =
{
  SET_ADDRESS_REQ_TYPE,
  SET_ADDRESS_REQ,
  DEBUG_DEVICE_ADDR,
  0,
  0
};

STATIC
EFI_USB_DEVICE_REQUEST SetDebugMode =
{
  SET_FEATURE_REQ_TYPE,
  SET_FEATURE_REQ,
  DEBUG_MODE,
  0,
  0
};

STATIC
UINT8 DataPID[2] =
{
  DATA0_PID,
  DATA1_PID
};

typedef struct {
  UINT32 Bypass;
  UINT32 EhciControl;
  UINT32 UsbDebugPort;
  UINT32 DebugPort;
  UINT32 BypassTimeout;
} DEBUGIO_CONFIG;

struct {
  DEBUGIO_CONFIG Config;
  UINT32 EhciBar;
} DebugIoConfig =
{
  { 1,				        // 0:Bypass connection off, 1:Bypass connection on
    EHCI_CONTROL,			// Ehci port
    0,		            // USB debug port
    0x0080,			      // Debug port
    BYPASS_TIMEOUT    // Bypass timeout
  },
  EHCI_BAR
};

struct
{
  UINT16 VenderID;
  UINT8  EhciHcDev[2];
  UINT8  EhciHcFun;
  UINT8  PwrSts;
  UINT8  DbgBase;
  UINT8  DbgPort;
} EhciTable[] =
{
  //
  // Intel ICH
  //
  { 0x8086, { 0x1d, 0x1a }, 0x07, 0x54, 0x5a, 0x00 },
  //
  // SIS 964
  //
  { 0x1039, { 0x03, 0x00 }, 0x03, 0x54, 0x5a, 0x00 },
  //
  // VIA 8251
  //
  { 0x1106, { 0x10, 0x00 }, 0x04, 0x84, 0x8a, 0x00 },
  //
  // ATI SB600
  //
  { 0x1002, { 0x13, 0x00 }, 0x05, 0xc4, 0xe6, 0x00 },
  //
  // ATI SB700
  //
  { 0x1002, { 0x12, 0x13 }, 0x02, 0xc4, 0xe6, 0x00 },
  //
  // AMD Hudson-2/Hudson-3, SB900
  //
  { 0x1022, { 0x12, 0x13 }, 0x02, 0xc4, 0xe6, 0x00 },
  //
  // nVidia MCP
  //
  { 0x10de, { 0x02, 0x00 }, 0x01, 0x84, 0x46, 0x74 },
  //
  // Empty for ending
  //
  { 0x0000, { 0x00, 0x00 }, 0x00, 0x00, 0x00, 0x00 },
};

UINTN  mDetectDevice    = 5;
UINTN  mEhciVender      = 0;
UINT32 mEhciAddress     = 0;
BOOLEAN mGetDebugDevice = FALSE;

//
// Function implemenations
//
//
// Match is only needed for debug.
//
#ifdef EFI_DEBUG

EFI_STATUS
EFIAPI
MatchStrings (
  IN  STATUS_CODE_LOOKUP_TABLE  *Table,
  IN  UINT32                    Value,
  OUT CHAR8                     **Token
  )
/*++

Routine Description:

  Search the input table for a matching value and return the token associated
  with that value.  Well formed tables will have the last value == 0 and will
  return a default token.

Arguments:

  Table     Pointer to first entry in an array of table entries.
  Value     Value to look up.
  Token     String to return.

Returns:

  EFI_SUCCESS   The function always returns success.

--*/
{
  UINTN  Current;

  ASSERT (Table);
  ASSERT (Token);

  Current = 0;
  *Token  = 0;

  while (!*Token) {
    //
    // Found token if values match or current entry is the last entry.
    //
    if ((Table[Current].Value == (-1)) || (Table[Current].Value == Value)) {
      *Token = Table[Current].Token;
    }

    Current++;
  }

  return EFI_SUCCESS;
}
#endif

UINT32
GetEhciDevice (
  IN  UINTN                     Number
  )
{
  UINT32 EhciAddress;
  UINT32 ClassCode;
  UINT16 VenderID;
  UINTN  Dev;
  UINTN  Fun;
  UINTN  HCNum;
  UINTN  Index;
  //
  // EHCI Auto-detection
  //
  for (Dev = 0, HCNum = 0; Dev < 0x20; Dev ++) {
    for (Fun = 0; Fun < 8; Fun ++) {
      EhciAddress = EFI_PCI_ADDRESS(0, Dev, Fun, 0);
      PciRead (
        EfiPciWidthUint32,
        EhciAddress + PLATFORM_USB20_RID,
        &ClassCode
        );
      if ((ClassCode & 0xFFFFFF00) == 0x0C032000) {
        PciRead (
          EfiPciWidthUint16,
          EhciAddress + PLATFORM_USB20_VID,
          &VenderID
          );
        //
        // Check vender ID
        //
        for (Index = 0; EhciTable[Index].VenderID != 0; Index ++) {
          if (EhciTable[Index].VenderID == VenderID) {
            if (VenderID != 0x10de) {
              //
              // Non-nVidia method
              //
              if (EhciTable[Index].EhciHcDev[Number] == Dev) {
                mEhciVender  = Index;
                mEhciAddress = EhciAddress;
                return mEhciAddress;
              }
            } else {
              //
              // nVidia method
              //
              if (HCNum == Number) {
                mEhciVender  = Index;
                mEhciAddress = EhciAddress;
                return mEhciAddress;
              }
            }
          }
        }
        HCNum ++;
      }
    }
  }
  return 0;
}

STATIC
UINT32
GetEhciAddress(
  IN  UINT32                    Register
  )
/*++

Routine Description:

  Get EHCI PCI address.

Arguments:

  Register  - PCI register

Returns:

  None

--*/
{
  if (mEhciAddress) {
    return mEhciAddress + Register;
  }
  return 0;
}

UINT32
ReadBAR (
  VOID
  )
/*++

Routine Description:

  Read BAR address.

Arguments:

  None
Returns:

  None

--*/
{
  UINT32  BarAddress;
  UINT32  PciAddress;

  PciAddress = GetEhciAddress (PLATFORM_USB20_MEMBASE);
  PciRead (EfiPciWidthUint32,
           PciAddress,
           &BarAddress
           );
  if (BarAddress != 0) {
    if (BarAddress == DebugIoConfig.EhciBar) {
      return BarAddress;
    }
    if (BarAddress != DebugIoConfig.EhciBar) {
      if ((*(UINT32*)(UINTN)BarAddress & 0xff000000) == 0x01000000 && (*(UINT32*)(UINTN)BarAddress & 0x000000ff) > 0) return BarAddress;
    }
  }
  PciWrite (EfiPciWidthUint32,
           PciAddress,
           &DebugIoConfig.EhciBar
           );
  return DebugIoConfig.EhciBar;
}

EFI_USB_CTRL_REG*
GetCtrlPointer (
  VOID
  )
/*++

Routine Description:

  GetCtrlPointer 0x20.

Arguments:

  None

return :
  Address - 0x98080400 + 0x20
--*/
{
  UINT32  Address;

  Address = ReadBAR();
  Address += ((EFI_USB_CAP_REG*) (UINTN)Address)->CapLength;
  return  (EFI_USB_CTRL_REG *) (UINTN)Address;
}

EFI_USB_DBG_REG*
GetDebugPointer (
  VOID
  )
/*++

Routine Description:

  GetDebugPointer 0xA0.

Arguments:

  None

return :
  Address - 0x98080400 + 0xA0
--*/
{
  UINT16  Offset;
  UINT32  Address;
  UINT32  PciAddress;

  PciAddress = GetEhciAddress (EhciTable[mEhciVender].DbgBase);
  PciRead (EfiPciWidthUint16,
           PciAddress,
           &Offset
           );
  Address = ReadBAR() + (Offset & 0x1fff);
  return  (EFI_USB_DBG_REG *) (UINTN)Address;
}

UINTN
GetUsbDebugPortNum (
  VOID
  )
/*++

Routine Description:

  Get USB debug port number.

Arguments:

  None

Returns:

  Port Number

--*/
{
  UINT32  Address;
  UINTN   PortNum;

  Address = ReadBAR();
  PortNum = (((EFI_USB_CAP_REG*) (UINTN)Address)->HcsParams >> 20) & 0x0f;
  if (PortNum) PortNum --;
  return PortNum;
}

VOID
SetUsbDebugPortNum (
  IN UINTN PortNum
  )
/*++

Routine Description:

  Set USB debug port number.

Arguments:

  PortNum  - Port Number

Returns:

  None

--*/
{
  UINT32  Data;
  UINT32  PciAddress;

  if (EhciTable[mEhciVender].VenderID == 0x10de) {
    //
    // nVidia MCP
    //
    PciAddress = GetEhciAddress (EhciTable[mEhciVender].DbgPort);
    PciRead (
      EfiPciWidthUint32,
      PciAddress,
      &Data
      );
    Data &= ~0x0000f000;
    Data |= (PortNum + 1) << 12;
    PciWrite (EfiPciWidthUint32,
              PciAddress,
              &Data
              );
  }
}

BOOLEAN
DetectEhciExist (
  VOID
  )
/*++

Routine Description:

  DetectEhciExist.

Arguments:

  None

return :
          TRUE  : USB 2.0 exist
          FALSE : USB 2.0 not exist
--*/
{
  if (GetEhciAddress(PLATFORM_USB20_RID) == 0) {
    return FALSE;
  }
  return  TRUE;
}

BOOLEAN
CheckEhciSuspend (
  VOID
  )
{
  UINT32  Data;
  UINT32  PciAddress;
  //
  // Get EHCI power state
  //
  Data = 0x00;
  PciAddress = GetEhciAddress(EhciTable[mEhciVender].PwrSts);
  PciRead (EfiPciWidthUint16,
            PciAddress,
            &Data
            );
  return (BOOLEAN)(Data & 0x03);
}

VOID
EnableEhci (
  VOID
  )
/*++

Routine Description:

  Enable Ehci Reg0x04->0x06.

Arguments:

  None

return :
  None
--*/
{
  UINT32  Data;
  UINT32  PciAddress;
  //
  // Set power state to D0
  //
  Data = 0x00;
  PciAddress = GetEhciAddress(EhciTable[mEhciVender].PwrSts);
  PciWrite (EfiPciWidthUint16,
            PciAddress,
            &Data
            );
  //
  // Enable BME and MSE
  //
  Data = 0x06;
  PciAddress = GetEhciAddress(PLATFORM_USB20_PCICMD);
  PciWrite (EfiPciWidthUint8,
            PciAddress,
            &Data
            );
}

VOID
DisableEhci (
  VOID
  )
/*++

Routine Description:

  Disable Ehci Reg0x04->0x00.

Arguments:

  None

return :
  None
--*/
{
  UINT32  Data;
  UINT32  PciAddress;
  //
  // Disable BME and MSE
  //
  Data = 0x00;
  PciAddress = GetEhciAddress(PLATFORM_USB20_PCICMD);
  PciWrite (EfiPciWidthUint8,
            PciAddress,
            &Data
            );
}

VOID
SetMemBAR()
/*++

Routine Description:

  Sets EHCI Bar

Arguments:

  None

return :
  None
--*/
{
  UINT32  EhciBar;
  UINT32  PciAddress;

  PciAddress = GetEhciAddress(PLATFORM_USB20_MEMBASE);
  PciRead (EfiPciWidthUint32,
           PciAddress,
           &EhciBar
           );

  if (EhciBar != 0) {
    return;
  }
  EhciBar = DebugIoConfig.EhciBar;
  PciWrite (EfiPciWidthUint32,
           PciAddress,
           &EhciBar
           );
}

EFI_STATUS
UsbDebugPortOut(
  IN  UINT8                     *Buffer,
  IN  UINTN                     Length,
  IN  UINT8                     TokenPid,
  IN  UINT8                     Toggle,
  IN  EFI_USB_DBG_REG           *DebugPtr
)
/*++

Routine Description:

  UsbDebugPortOut.
  Check DebugPtr->Sc.Done = 1

Arguments:

  Buffer
  Length
  TokenPid
  Toggle
  DebugPtr

return :
  EFI_SUCCESS
  EFI_TIMEOUT
--*/
{
  UINTN                 Index;
  UINT8                 Toggle0;
  UINT8                 Toggle1;
  EFI_USB_DBG_SC        DebugSC;
  //
  // Set TOKEN_PID_CNT
  //
  *(UINT32*)&DebugPtr->Pid = (Toggle << 8) | TokenPid;
  //
  // Fill the data to debug buffer
  //
  DebugPtr->Data0 = *(UINT32*)&Buffer[0];
  do {
    DebugPtr->Data1 = *(UINT32*)&Buffer[4];
  }
  while (DebugPtr->Data1 != *(UINT32*)&Buffer[4]);
  //
  // Set WRITE_READ#=1 and GO_CNT=1
  //
  DebugSC = DebugPtr->Sc;
  DebugSC.DataLength = (UINT32)Length;
  DebugSC.Write = DEBUG_WRITE;
  DebugSC.Go = 1;
  DebugPtr->Sc = DebugSC;
  for(Index = 0, Toggle0 = 0; Index < DXE_TIMEOUT_TICKS * 2;) {
    if (DebugPtr->Sc.Done) {
      if (DebugPtr->Sc.Error && DebugPtr->Sc.Exception > 0) {
        return EFI_DEVICE_ERROR;
      }
      break;
    }
    Toggle1 = CpuIoRead8(0x61);
    if (((Toggle0 ^ Toggle1) & 0x10) != 0) {
      Toggle0 = Toggle1;
      Index ++;
    }
  }
  if (Index == DXE_TIMEOUT_TICKS * 2) {
    return EFI_TIMEOUT;
  }
  return EFI_SUCCESS;
}

EFI_STATUS
UsbDebugPortIN(
  IN     UINT8                  *Buffer,
  IN OUT UINTN                  *Length,
  IN     UINT8                  TokenPid,
  IN     UINT8                  Toggle,
  IN     EFI_USB_DBG_REG        *DebugPtr

)
/*++

Routine Description:

  UsbDebugPortIN.
  Check DebugPtr->Sc.Done = 1

  *** CAUTION : The size of Buffer must large then 8 bytes ***

Arguments:

  Buffer
  Length
  TokenPid
  Toggle
  DebugPtr

return :
  EFI_SUCCESS
  EFI_TIMEOUT
--*/
{
  UINTN                 Index;
  UINT8                 Toggle0;
  UINT8                 Toggle1;
  EFI_USB_DBG_SC        DebugSC;
  //
  // Set TOKEN_PID_CNT
  //
  *(UINT32*)&DebugPtr->Pid = (Toggle << 8) | TokenPid;
  //
  // Set WRITE_READ#=0 and GO_CNT=1
  //
  DebugSC = DebugPtr->Sc;
  DebugSC.DataLength = 0;
  DebugSC.Write = DEBUG_READ;
  DebugSC.Go = 1;
  DebugPtr->Sc = DebugSC;
  for(Index = 0, Toggle0 = 0; Index < DXE_TIMEOUT_TICKS * 2;) {
    if (DebugPtr->Sc.Done) {
      if (DebugPtr->Sc.Error && DebugPtr->Sc.Exception > 0) {
        return EFI_DEVICE_ERROR;
      }
      break;
    }
    Toggle1 = CpuIoRead8 (0x61);
    if (((Toggle0 ^ Toggle1) & 0x10) != 0) {
      Toggle0 = Toggle1;
      Index ++;
    }
  }
  if (Index == DXE_TIMEOUT_TICKS * 2) {
    return EFI_TIMEOUT;
  }
  if (DebugPtr->Sc.DataLength > 8) {
    return EFI_ABORTED;
  }
  //
  // Fill the Data to Buffer
  //
  *Length = DebugPtr->Sc.DataLength;
  if (Buffer && DebugPtr->Sc.DataLength) {
    *(UINT32*)&Buffer[0] = DebugPtr->Data0;
    *(UINT32*)&Buffer[4] = DebugPtr->Data1;
  }
  return EFI_SUCCESS;
}

EFI_STATUS
ControlTransfer (
  IN  EFI_USB_DEVICE_REQUEST    *Request,
  IN  UINT32                    DeviceAddress,
  IN  UINT8                     *Buffer,
  IN  EFI_USB_DBG_REG           *DebugPtr
)
/*++

Routine Description:

  Control Transfer.

Arguments:

  Request
  DeviceAddress
  Endpoint
  Buffer
  DebugPtr

return :
  EFI_SUCCESS
  EFI_TIMEOUT
--*/
{
  EFI_STATUS    Status;
  UINTN         DataLength = 0;

  DebugPtr->Addr.Address = DeviceAddress;
  DebugPtr->Addr.Endpoint = 0;
  //
  // Setup Stage
  //
  Status = UsbDebugPortOut ((UINT8*)Request, sizeof (EFI_USB_DEVICE_REQUEST), SETUP_TOKEN_ID, DATA0_PID, DebugPtr);
  if (Status != EFI_SUCCESS) {
    return EFI_TIMEOUT;
  }
  //
  // Data stage
  //
  if (Request->Length != 0) {
    Status = UsbDebugPortIN(Buffer, &DataLength, INPUT_TOKEN_ID, DATA1_PID, DebugPtr);
    if (Status != EFI_SUCCESS) {
      return EFI_TIMEOUT;
    }
  }
  //
  // State stage
  //
  if ((Request->RequestType & 0x80) == 0) {
    //
    // This Control Transfer is Set, So its State stage is IN
    //
    Status = UsbDebugPortIN (Buffer, &DataLength, INPUT_TOKEN_ID, DATA1_PID, DebugPtr);
  } else {
    //
    // This Control Transfer is Get, So its State stage is OUT
    //
    Status = UsbDebugPortOut (Buffer, 0, OUTPUT_TOKEN_ID, DATA1_PID, DebugPtr);
    //
    // Return error if returned length is zero in data stage.
    //
    if (DataLength == 0) {
      return EFI_DEVICE_ERROR;
    }
  }
  if (Status != EFI_SUCCESS) {
    return EFI_TIMEOUT;
  }
  return   EFI_SUCCESS;
}

EFI_STATUS
BsUsbInitializeStatusCode (
  VOID
  )
/*++

Routine Description:

  Initialize Usb Port

    The Baud Rate Divisor registers are programmed and the LCR
    is used to configure the communications format. Hard coded
    UART config comes from globals in DebugSerialPlatform lib.

Arguments:

  Unused

Returns:

  None

--*/
{
  EFI_STATUS                    Status;
  UINT32                        Timeout, Index;
  UINTN                         UsbDebugPortNum;
  EFI_USB_DEVICE_DESCRIPTOR     DeviceDescriptor;
  EFI_USB_DEBUG_DESCRIPTOR      DebugDescriptor;
  EFI_USB_CTRL_REG              *CtrlPtr;
  EFI_USB_DBG_REG               *DebugPtr;
  EFI_USB_DBG_SC                DebugSC;
  DEBUG_BULK                    Bulk;

  mEhciAddress = GetEhciDevice (DebugIoConfig.Config.EhciControl);

  if (mEhciAddress == 0) {
    return EFI_DEVICE_ERROR;
  }
  //
  // Detect Ehci
  //
  if (!DetectEhciExist ()) {
    return EFI_DEVICE_ERROR;
  }
  //
  // Enable EHCI
  //
  EnableEhci ();

  //
  // Setup Usb Debug Port Number
  //
  SetUsbDebugPortNum (DebugIoConfig.Config.UsbDebugPort);
  //
  // Set base address
  //
  SetMemBAR();
  //
  // Get Usb Debug Port Number
  //
  UsbDebugPortNum = GetUsbDebugPortNum ();
  CtrlPtr = GetCtrlPointer ();
  DebugPtr = GetDebugPointer ();
  //
  // In order to prevent debug exception error(010b), turn debug enebled bit off if enabled bit was previously set
  //
  if (DebugPtr->Sc.Enabled) {
    DebugSC = DebugPtr->Sc;
    DebugSC.Enabled = 0;
    DebugPtr->Sc = DebugSC;
  }
  //
  // Set EHCI Run/Stop to 1
  //
  CtrlPtr->UsbCmd = CtrlPtr->UsbCmd | EUSBCMD_RS;

  Stall(1000);
  //
  // Set EHCI Configure flags
  //
  CtrlPtr->Cfg = CtrlPtr->Cfg | EUSBCONFIG_CF;

  Stall(1000);
  //
  // OWNER bit set to 1
  //
  DebugSC = DebugPtr->Sc;
  DebugSC.Owner = 1;
  DebugPtr->Sc = DebugSC;

  //
  // Clean connect change status bit
  //
  CtrlPtr->PortSC[UsbDebugPortNum] = CtrlPtr->PortSC[UsbDebugPortNum] | EUSBPORTSC_CSC;
  //
  // Check low speed device
  //
  if ((CtrlPtr->PortSC[UsbDebugPortNum] & EUSBPORTSC_LS) == LINE_STATUS_K) {
    goto ERROR_EXIT;
  }
  //
  // Reset the Port
  //
  CtrlPtr->PortSC[UsbDebugPortNum] = CtrlPtr->PortSC[UsbDebugPortNum] | EUSBPORTSC_PR;

  Stall (1000);
  //
  // Clean Reset bit
  //
  CtrlPtr->PortSC[UsbDebugPortNum] = CtrlPtr->PortSC[UsbDebugPortNum] & ~EUSBPORTSC_PR;
  //
  // Check PORTSC.Enable
  //
  if (DebugIoConfig.Config.BypassTimeout == 0) DebugIoConfig.Config.BypassTimeout = 1;
  Timeout = (UINT32)DebugIoConfig.Config.BypassTimeout * 2;
  while (((CtrlPtr->PortSC[UsbDebugPortNum] & EUSBPORTSC_CCS) != EUSBPORTSC_CCS ||
          (CtrlPtr->PortSC[UsbDebugPortNum] & EUSBPORTSC_PED) != EUSBPORTSC_PED) &&
          Timeout > 0) {
    Stall (20);
    Timeout--;
  }
  if (Timeout == 0) {
    goto ERROR_EXIT;
  }
  //
  // Clear the EHCI status
  //
  CtrlPtr->UsbSts = 0x00ff;
  //
  // Enable the port for debug traffic
  //
  DebugSC = DebugPtr->Sc;
  DebugSC.Enabled = 1;
  DebugPtr->Sc = DebugSC;

  Stall (1000);
  //
  // Get device descriptor through address 0 to check the class/subclass code
  //
  Status = ControlTransfer (&GetDeviceDescriptor, 0, (UINT8*)&DeviceDescriptor, DebugPtr);
  if (Status != EFI_SUCCESS || DeviceDescriptor.DeviceClass != 0xFF || DeviceDescriptor.DeviceSubClass != 0x00 || DeviceDescriptor.DeviceProtocol != 0x00) {
    mGetDebugDevice = FALSE;
    goto ERROR_EXIT;
  }
  //
  // Get debug descriptor through address 0
  //
  Status = ControlTransfer (&GetDebugDescriptor, 0, (UINT8*)&DebugDescriptor, DebugPtr);
  if (Status != EFI_SUCCESS) {
    goto ERROR_EXIT;
  }
  //
  // Set address to DEBUG_DEVICE_ADDR(127)
  //
  Status = ControlTransfer (&SetDeviceAddress, 0, NULL, DebugPtr);
  if (Status != EFI_SUCCESS) {
    goto ERROR_EXIT;
  }

  Stall(1000);
  //
  // Set to debug mode
  //
  Status = ControlTransfer (&SetDebugMode, DEBUG_DEVICE_ADDR, NULL, DebugPtr);
  if (Status != EFI_SUCCESS) {
    goto ERROR_EXIT;
  }
  //
  // Initialize Bulk Endpoints and Toggles
  //
  *(UINT32*)&Bulk = 0;
  Bulk.EndpointIn  = DebugDescriptor.DebugInEndpoint & 0x0f;
  Bulk.EndpointOut = DebugDescriptor.DebugOutEndpoint & 0x0f;
  //
  // Reads garbage 3 times
  //
  for (Index = 0; Index < 3; Index++) {
    UINTN NumBytesToGet;
    DebugPtr->Addr.Address = DEBUG_DEVICE_ADDR;
    DebugPtr->Addr.Endpoint = Bulk.EndpointIn;
    Status = UsbDebugPortIN (NULL, &NumBytesToGet, INPUT_TOKEN_ID, DataPID[Bulk.ToggleIn], DebugPtr);
    if (Status != EFI_SUCCESS) {
      break;
    }
    Bulk.ToggleIn ^= 1;
  }
  //
  // Store Variable to Data Buffer
  //
  DebugPtr->Data0 = *(UINT32*)&Bulk;
  mGetDebugDevice = TRUE;
  return  EFI_SUCCESS;
ERROR_EXIT:

  DebugPtr->Sc.Enabled = 0;
  DebugPtr->Sc.Owner = 0;
  //
  // HCRESET
  //
  CtrlPtr->UsbCmd = CtrlPtr->UsbCmd | EUSBCMD_HCRESET;
  //
  // Delay 30 milli-second
  //
  Stall(1000);
  //
  // Reset EHCI ownership bit
  //
  CtrlPtr->Cfg = 0;
  //
  // Delay 30 milli-second
  //
  DisableEhci();
  return EFI_DEVICE_ERROR;
}

EFI_STATUS
DebugUsbWrite (
  IN OUT UINTN                  *BufferSize,
  IN VOID                       *Buffer
  )
/*++

Routine Description:

 DebugUsbWrite - Outputs a character to the Usb port

  Repeatedly polls the TXRDY bit of the Line Status Register
  until the Transmitter Holding Register is empty.  The character
  is then written to the Serial port.

Arguments:

  Character   - Character to write

Returns:

  None

--*/
{
  EFI_STATUS       Status;
  INTN             StringLength;
  UINTN            NumBytesToSend;
  UINTN            Count0;
  UINT8            *Ptr;
  DEBUG_BULK       Bulk;
  EFI_USB_DBG_REG  *DebugPtr;
  UINT32           PciIndexSave;

  Status = EFI_SUCCESS;
  //
  // Save PCI index
  //
  PciIndexSave = CpuIoRead32 (0xcf8);
  DebugPtr = GetDebugPointer();
  if (CheckEhciSuspend() || DebugPtr->Sc.Enabled == 0 || DebugPtr->Sc.Owner == 0) {
    //
    // Stall 300 MilliSecond to wait for global reset command complete.
    //
    if (mDetectDevice != 0) {
      Stall(300);
      Status = BsUsbInitializeStatusCode();
      mDetectDevice--;
      if (Status != EFI_SUCCESS)
      {
        //
        // Restore PCI index
        //
        CpuIoWrite32(0xcf8, PciIndexSave);
        return EFI_DEVICE_ERROR;
      }
      DebugPtr = GetDebugPointer();
    }
  }
  //
  // The EHCI controller may be disabled, so we should check it
  //
  if ((DebugPtr->Data0 == 0xFFFFFFFF) && (DebugPtr->Data1 == 0xFFFFFFFF)) {
    EnableEhci ();
  }
  //
  // Restore PCI index
  //
  CpuIoWrite32 (0xcf8, PciIndexSave);
  //
  // If Usb Debug Port not been enable, don't send
  //
  if (DebugPtr->Sc.Enabled != 1) {
    return EFI_DEVICE_ERROR;
  }
  //
  // Load Variable to Data Buffer
  //
  *(UINT32*)&Bulk = DebugPtr->Data0;
  //
  // Calculation DataLength
  //
  Ptr = Buffer;
  StringLength = *BufferSize;
  //
  // Set Device and Endpoint Address
  //
  DebugPtr->Addr.Address = DEBUG_DEVICE_ADDR;
  for (Count0 = 0; Count0 < DXE_TIMEOUT_TICKS; Count0 ++) {
    DebugPtr->Addr.Endpoint = Bulk.EndpointOut;
    NumBytesToSend = (StringLength < 8) ? StringLength : 8;
    Status = UsbDebugPortOut (Ptr, NumBytesToSend, OUTPUT_TOKEN_ID, DataPID[Bulk.ToggleOut], DebugPtr);
    if (Status == EFI_SUCCESS) {
      Bulk.ToggleOut ^= 1;
      if (StringLength <= (INTN)NumBytesToSend) {
        goto Finish;
      }
      StringLength -= NumBytesToSend;
      Ptr += NumBytesToSend;
      Count0 = 0;
      DebugPtr->Addr.Endpoint = Bulk.EndpointIn;
    } else if (Status != EFI_TIMEOUT) {
      Stall (1);
    }
  }
  if (Count0 == DXE_TIMEOUT_TICKS) {
    Status = EFI_TIMEOUT;
  }
Finish:
  //
  // Store Variable to Data Buffer
  //
  DebugPtr->Data0 = *(UINT32*)&Bulk;
  Stall (10);
  return Status;
}

VOID
DebugUsbPrint (
  IN UINT8    *OutputString
  )
/*++

Routine Description:

  Prints a string to the Serial port

Arguments:

  OutputString - Ascii string to print to serial port.

Returns:

  None

--*/
{
  EFI_STATUS  Status;
  UINTN       StringLength = 1;
  UINT8       TempBuffer[8];

  Status = EFI_SUCCESS;
  StringLength = 0;
  Memzero (TempBuffer, 8);
  //
  // If Debug cable can't find, skip message out.
  //
  if (!mGetDebugDevice) return;

  for (; *OutputString != 0; OutputString++) {
    TempBuffer[StringLength] = *OutputString;
    StringLength++;
    if (StringLength == 8){
      DebugUsbWrite (&StringLength, TempBuffer);
      Memzero (TempBuffer, 8);
      Stall(50);
      StringLength = 0;
    }
  }

  DebugUsbWrite (&StringLength, TempBuffer);
}

EFI_STATUS
EFIAPI
BsUsbReportStatusCode (
  IN EFI_STATUS_CODE_TYPE     CodeType,
  IN EFI_STATUS_CODE_VALUE    Value,
  IN UINT32                   Instance,
  IN EFI_GUID                 * CallerId,
  IN EFI_STATUS_CODE_DATA     * Data OPTIONAL
  )
/*++

Routine Description:

  Provide a serial port print

Arguments:


Returns:

  Status -  EFI_SUCCESS if the interface could be successfully
            installed

--*/
{
  CHAR8    Buffer[EFI_STATUS_CODE_DATA_MAX_SIZE * 3];
  UINT32   LineNumber;
  CHAR8    *Filename;
  CHAR8    *Description;
  CHAR8    *Format;
  VA_LIST  Marker;
  UINT32   ErrorLevel;
  UINTN    CharCount;

  Buffer[0] = '\0';

  if (ReportStatusCodeExtractAssertInfo (CodeType, Value, Data, &Filename, &Description, &LineNumber)) {
    //
    // Processes ASSERT ()
    //
    ASPrint (
      Buffer,
      EFI_STATUS_CODE_DATA_MAX_SIZE,
      "\nDXE_ASSERT!: %a (%d): %a\n",
      Filename,
      LineNumber,
      Description
      );

  } else if (ReportStatusCodeExtractDebugInfo (Data, &ErrorLevel, &Marker, &Format)) {
    //
    // Process DEBUG () macro to Serial
    //
    AvSPrint (Buffer, EFI_STATUS_CODE_DATA_MAX_SIZE, Format, Marker);

  } else if ((CodeType & EFI_STATUS_CODE_TYPE_MASK) == EFI_ERROR_CODE) {
    //
    // Process Errors
    //
    CharCount = ASPrint (Buffer, EFI_STATUS_CODE_DATA_MAX_SIZE, "ERROR: C%x:V%x I%x", CodeType, Value, Instance);
    //
    // Make sure we don't try to print values that weren't intended to be printed, especially NULL GUID pointers.
    //
    if (CallerId) {
      CharCount += ASPrint (
                    &Buffer[CharCount - 1],
                    (EFI_STATUS_CODE_DATA_MAX_SIZE - (sizeof (Buffer[0]) * CharCount)),
                    " %g",
                    CallerId
                    );
    }

    if (Data) {
      CharCount += ASPrint (
                    &Buffer[CharCount - 1],
                    (EFI_STATUS_CODE_DATA_MAX_SIZE - (sizeof (Buffer[0]) * CharCount)),
                    " %x",
                    Data
                    );
    }

    CharCount += ASPrint (
                  &Buffer[CharCount - 1],
                  (EFI_STATUS_CODE_DATA_MAX_SIZE - (sizeof (Buffer[0]) * CharCount)),
                  "\n"
                  );

  }

  if (Buffer[0] != '\0') {
    //
    // Callout to platform Lib function to do print.
    //
    DebugUsbPrint (Buffer);
  }
  //
  // Debug code to display human readable code information.
  //
#ifdef EFI_DEBUG
  {
    CHAR8  *SeverityToken;
    CHAR8  *SubClassToken;
    CHAR8  *OperationToken;

    if ((CodeType & EFI_STATUS_CODE_TYPE_MASK) == EFI_ERROR_CODE) {
      //
      // Get the severity token
      //
      MatchStrings (
        mSeverityTokens,
        (CodeType & EFI_STATUS_CODE_SEVERITY_MASK),
        &SeverityToken
        );

      //
      // Get the Class/SubClass token
      //
      MatchStrings (
        mClassSubClassTokens,
        (Value & (EFI_STATUS_CODE_CLASS_MASK | EFI_STATUS_CODE_SUBCLASS_MASK)),
        &SubClassToken
        );

      //
      // Get the operation token
      //
      MatchStrings (
        mOperationTokens,
        (Value & (EFI_STATUS_CODE_CLASS_MASK | EFI_STATUS_CODE_SUBCLASS_MASK | EFI_STATUS_CODE_OPERATION_MASK)),
        &OperationToken
        );

      //
      // Concatenate the instance
      //
      ASPrint (
        Buffer,
        EFI_STATUS_CODE_DATA_MAX_SIZE,
        "%a:%a:%a:%d\n",
        SeverityToken,
        SubClassToken,
        OperationToken,
        Instance
        );

      DebugUsbPrint (Buffer);
    }
  }
#endif

  return EFI_SUCCESS;
}
