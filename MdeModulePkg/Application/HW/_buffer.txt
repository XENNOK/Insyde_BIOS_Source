/*// note
  { // 1.結構的賦值
    // 
    //  (1)結構初始化時只能用實數，不能直接給予結構，但賦值的時候可以直接給予結構
    //  ex:
    //    Car car = {4, 20, 50};       -->正確
    //    Car car = {tire.mount,...};   -->錯誤
    //  
  }

  { // 2.變數宣告了未使用，Build 會錯誤
    //
  }

  {}
  
  {}

  {}

  {}
*/

/*// UI prototype
  #include <Uefi.h>
  #include <Library/UefiLib.h>
  #include <Library/UefiApplicationEntryPoint.h>
  #include <Library/UefiBootServicesTableLib.h>

  #define MAIN_PAGE_MODE   0
  #define BRANCH_PAGE_MODE 1

  #define Count         256

  typedef struct {
    INT16 column;         /// cursor column
    INT16 row;            /// cursor row
  } POSITION;

  const POSITION  MainPage_ResetPosition  = {24, 5};
  const POSITION  ResetPosition = {5, 4};

  VOID SetRegisterPageAppearance(VOID);
  VOID SetMainPageAppearance(VOID);
  VOID ResetCursorPosition(POSITION *CursorPosition);
  VOID ShowMainPage(POSITION *CursorPosition);
  VOID JudgeFontColor(UINT8 Buffer);

  EFI_STATUS
  EFIAPI
  UefiMain (
    IN EFI_HANDLE ImageHandle, 
    IN EFI_SYSTEM_TABLE *SystemTable
    )
  {
    EFI_STATUS            Status;
    POSITION              CursorPosition;
    UINT8                 AllBranchPage;
    UINT8                 Mode;
    EFI_INPUT_KEY         InputKey;
    // UINT8                 RecordBuffer[Count];  
    // UINT8                 RecordBufferTime;

    AllBranchPage = 3;
    Mode = MAIN_PAGE_MODE;
    
    gST->ConOut->ClearScreen(gST->ConOut);
    gST->ConOut->SetCursorPosition(gST->ConOut, 0, 0);
    gST->ConOut->EnableCursor(gST->ConOut, TRUE);
    ShowMainPage(&CursorPosition);
    
    while (TRUE) {
      
      //
      // to change mode
      //
      ChangeMode:

      //
      // MAIN_PAGE_MODE
      // with up, down, F1, Esc key response
      //
      while (Mode == MAIN_PAGE_MODE) {
        gST->ConIn->ReadKeyStroke(gST->ConIn, &InputKey);

        if (InputKey.ScanCode == SCAN_ESC) {
          gST->ConOut->ClearScreen(gST->ConOut);
          goto Exit;
        }

        switch (InputKey.ScanCode) {

        case SCAN_UP:
          CursorPosition.row--;
          if (CursorPosition.row < MainPage_ResetPosition.row) {
            CursorPosition.row = MainPage_ResetPosition.row;
          }
          gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);    
          continue;

        case SCAN_DOWN:
          CursorPosition.row++;
          if (CursorPosition.row > (AllBranchPage + MainPage_ResetPosition.row - 1)) {
            CursorPosition.row = (AllBranchPage + MainPage_ResetPosition.row - 1);
          }
          gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);
          continue;

        case SCAN_F1:
          // RecordBufferTime = 0;
          Mode = BRANCH_PAGE_MODE;

          // if (CursorPosition.row == MainPage_ResetPosition.row) {
          //   ReadBda(&CursorPosition, RecordBuffer, &RecordBufferTime);
          // } else if (CursorPosition.row == MainPage_ResetPosition.row + 1) {
          //   ReadEbda(&CursorPosition, RecordBuffer, &RecordBufferTime);
          // } else if (CursorPosition.row == MainPage_ResetPosition.row + 2) {
          //   ReadCmos(&CursorPosition, RecordBuffer, &RecordBufferTime);
          // }

          goto ChangeMode;
        }
      }

      //
      // BRANCH_PAGE_MODE
      // with up, down, right, left, F1, F2, F3, Esc key response
      //
      while (Mode == BRANCH_PAGE_MODE) {
        gST->ConIn->ReadKeyStroke(gST->ConIn, &InputKey);

        if (InputKey.ScanCode == SCAN_ESC) {
          gST->ConOut->ClearScreen(gST->ConOut);
          goto Exit;
        }

        switch (InputKey.ScanCode) {

        case SCAN_F1:
          // RecordBufferTime = 0;
          Mode = MAIN_PAGE_MODE;
          ShowMainPage(&CursorPosition);

          goto ChangeMode;

        case SCAN_F2:

          continue;
        }
      }  
    }

    //
    // to get out
    //
    Exit:

    // free(RecordBuffer);

    Status = EFI_SUCCESS;

    return Status;
  }

  VOID SetRegisterPageAppearance(VOID)
  {
    gST->ConOut->ClearScreen(gST->ConOut);
    gST->ConOut->SetAttribute(gST->ConOut, EFI_WHITE | EFI_BACKGROUND_BLACK);

    Print(L"|                                                    |\n");
    Print(L"|====================================================|\n");
    Print(L"|  | 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F |\n");
    Print(L"|====================================================|\n");
    Print(L"|00|                                                 |\n");
    Print(L"|10|                                                 |\n");
    Print(L"|20|                                                 |\n");
    Print(L"|30|                                                 |\n");
    Print(L"|40|                                                 |\n");
    Print(L"|50|                                                 |\n");
    Print(L"|60|                                                 |\n");
    Print(L"|70|                                                 |\n");
    Print(L"|80|                                                 |\n");
    Print(L"|90|                                                 |\n");
    Print(L"|A0|                                                 |\n");
    Print(L"|B0|                                                 |\n");
    Print(L"|C0|                                                 |\n");
    Print(L"|D0|                                                 |\n");
    Print(L"|E0|                                                 |\n");
    Print(L"|F0|                                                 |\n");
    Print(L"|====================================================|\n");
    Print(L"| [F1]:Back     [F1]:renew     [Esc]:Escape          |\n");
    Print(L"|====================================================|\n");

    return;
  }

  VOID SetMainPageAppearance(VOID)
  {
    gST->ConOut->ClearScreen(gST->ConOut);
    gST->ConOut->SetAttribute(gST->ConOut, EFI_WHITE | EFI_BACKGROUND_BLACK);

    Print(L"|====================================================|\n");
    Print(L"|                                                    |\n");
    Print(L"|                   08-BDA_CMOS                      |\n");
    Print(L"|                                                    |\n");
    Print(L"|====================================================|\n");
    Print(L"|                       BDA                          |\n");
    Print(L"|                       EBDA                         |\n");
    Print(L"|                       CMOS                         |\n");
    Print(L"|====================================================|\n");
    Print(L"| [Arrow key] : Choose                               |\n");
    Print(L"| [F1] : Enter                                       |\n");
    Print(L"| [Esc] : Escape                                     |\n");
    Print(L"|====================================================|\n");

    return;
  }

  VOID ResetCursorPosition(POSITION *CursorPosition)
  {
    *CursorPosition = ResetPosition;
    gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition->column, CursorPosition->row);

    return;
  }

  VOID ShowMainPage(POSITION *CursorPosition)
  {
    SetMainPageAppearance();
    *CursorPosition = MainPage_ResetPosition;
    gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition->column, CursorPosition->row);
    gST->ConOut->EnableCursor(gST->ConOut, TRUE);

    return;
  }

  VOID JudgeFontColor(UINT8 Buffer)
  {
    if (Buffer > 0){
      gST->ConOut->SetAttribute(gST->ConOut, EFI_YELLOW | EFI_BACKGROUND_BLACK);
    } else {
      gST->ConOut->SetAttribute(gST->ConOut, EFI_LIGHTGRAY | EFI_BACKGROUND_BLACK);
    }
    return;
  }
*/

/*// Base prototype
  #include <Uefi.h>
  #include <Library/UefiLib.h>
  #include <Library/UefiApplicationEntryPoint.h>
  #include <Library/UefiBootServicesTableLib.h>

  EFI_STATUS
  EFIAPI
  UefiMain (
    IN EFI_HANDLE ImageHandle, 
    IN EFI_SYSTEM_TABLE *SystemTable
    )
  {
    EFI_STATUS            Status;
    

    Status = EFI_SUCCESS;

    return Status;
  }
*/

/*// PciUtility_06 finish(v1)
  #include <PciUtility_06.h>

  EFI_STATUS
  EFIAPI
  UefiMain (
    IN EFI_HANDLE ImageHandle, 
    IN EFI_SYSTEM_TABLE *SystemTable
    )
  { 
    EFI_STATUS                    Status;  
    EFI_INPUT_KEY                 InputKey;
    POSITION                      CursorPosition;
    UINT8                         Mode;
    UINT8                         AllBranchPage;
    UINT8                         ReadMode;
    ADDRESS                       Address;

    //
    // initialization and into the main page
    //
    gST->ConOut->ClearScreen(gST->ConOut);
    gST->ConOut->SetCursorPosition(gST->ConOut, 0, 0);
    gST->ConOut->EnableCursor(gST->ConOut, TRUE);
    Mode = MAIN_PAGE_MODE;
    ReadMode = BYTE;
    AllBranchPage = ShowMainPage(&CursorPosition);
    
    //
    // choose mode loop
    //
    while (TRUE) {
      
      //
      // to change mode
      //
      ChangeMode:

      //
      // MAIN_PAGE_MODE
      // with up, down, F1, Esc key response
      //
      while (Mode == MAIN_PAGE_MODE) {
        gST->ConIn->ReadKeyStroke(gST->ConIn, &InputKey);

        if (InputKey.ScanCode == SCAN_ESC) {
          gST->ConOut->ClearScreen(gST->ConOut);
          goto Exit;
        }

        switch (InputKey.ScanCode) {

        case SCAN_UP:
          CursorPosition.row--;
          if (CursorPosition.row < MainPage_ResetPosition.row) {
            CursorPosition.row = MainPage_ResetPosition.row;
          }
          gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);    
          continue;

        case SCAN_DOWN:
          CursorPosition.row++;
          if (CursorPosition.row > (AllBranchPage + MainPage_ResetPosition.row - 1)) {
            CursorPosition.row = (AllBranchPage + MainPage_ResetPosition.row - 1);
          }
          gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);
          continue;

        case SCAN_F1:
          Mode = BRANCH_PAGE_MODE;
          ShowRegistPage(&Address, &CursorPosition);
          goto ChangeMode;
        }
      }

      //
      // BRANCH_PAGE_MODE
      // with up, down, right, left, F1, F2, F3, Esc key response
      //
      while (Mode == BRANCH_PAGE_MODE) {
        gST->ConIn->ReadKeyStroke(gST->ConIn, &InputKey);

        if (InputKey.ScanCode == SCAN_ESC) {
          gST->ConOut->ClearScreen(gST->ConOut);
          goto Exit;
        }

        switch (InputKey.ScanCode) {

        case SCAN_UP:
          CursorPosition.row--;
          if (CursorPosition.row < ReadMode1_ResetPosition.row) {
            CursorPosition.row = ReadMode1_ResetPosition.row;
          }
          gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);    
          continue;

        case SCAN_DOWN:
          CursorPosition.row++;
          if (CursorPosition.row > (ReadMode1_ResetPosition.row + 15)) {
            CursorPosition.row = (ReadMode1_ResetPosition.row + 15);
          }
          gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);
          continue;
        
        case SCAN_RIGHT:
          CursorPosition.column = CursorPosition.column + (ReadMode * 3);
          if (CursorPosition.column > (52 - 2 * ReadMode)) {
            CursorPosition.column = (52 - 2 * ReadMode);
          }
          gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);
          continue;

        case SCAN_LEFT:
          CursorPosition.column = CursorPosition.column - (ReadMode * 3);
          if (CursorPosition.column < (ReadMode + 4)) {
            CursorPosition.column = (ReadMode + 4);
          }
          gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);
          continue;

        case SCAN_F1:
          Mode = MAIN_PAGE_MODE;
          ReadMode = BYTE;
          ShowMainPage(&CursorPosition);
          goto ChangeMode;
        
        case SCAN_F2:
          ReadMode *= 2;
          if (ReadMode > 4) ReadMode = BYTE;
          ReadRegist(&Address, &CursorPosition, ReadMode);
          continue;
        case SCAN_F3:
          Mode = WRITE_MODE;
          break;;
        }
      }

      //
      // WRITE_MODE
      // with number(0~9),alphabet(a~f) key response
      //
      if (Mode == WRITE_MODE){
        WRITE_BUFFER ReadMode1_WriteBuffer[2] = {{0, 5, 4}, {0, 5, 4}};
        WRITE_BUFFER ReadMode2_WriteBuffer[4] = {{0, 6, 4}, {0, 6, 4},
                                                {0, 6, 4}, {0, 6, 4}};
        WRITE_BUFFER ReadMode4_WriteBuffer[8] = {{0, 8, 4}, {0, 8, 4},
                                                {0, 8, 4}, {0, 8, 4},
                                                {0, 8, 4}, {0, 8, 4},
                                                {0, 8, 4}, {0, 8, 4}};

        UINT8 count = 0;                // for write_buffer operation
        UINT32 WriteBufferConvert = 0;  // buffer for write_buffer

        while (TRUE) {
          gST->ConIn->ReadKeyStroke(gST->ConIn, &InputKey);

          if (ReadMode == BYTE) {
            if (count == (ReadMode * 2)) {
              count = 0;
              gST->ConOut->ClearScreen(gST->ConOut);
              Address.Offset = ((ReadMode1_WriteBuffer[0].position.column -           \
                                  ReadMode1_ResetPosition.column) / 3) * (ReadMode) + \
                                  16 * (ReadMode1_WriteBuffer[0].position.row -       \
                                  ReadMode1_ResetPosition.row);

              WriteBufferConvert = ((ReadMode1_WriteBuffer[0].value << 4) | (ReadMode1_WriteBuffer[1].value));
              WriteRegist(&Address, WriteBufferConvert, ReadMode);
              ReadRegist(&Address, &CursorPosition, ReadMode);

              Mode = BRANCH_PAGE_MODE;
              goto ChangeMode;
            }

            if (('a' <= InputKey.UnicodeChar && InputKey.UnicodeChar <= 'f')) {
              ReadMode1_WriteBuffer[count].value = (UINT8)InputKey.UnicodeChar - 87;
              ReadMode1_WriteBuffer[count].position.column = CursorPosition.column;
              ReadMode1_WriteBuffer[count].position.row = CursorPosition.row;
              Print(L"%c", InputKey.UnicodeChar);

              CursorPosition.column = CursorPosition.column + 1;
              gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);
              count++;
              continue;

            } else if (('0' <= InputKey.UnicodeChar && InputKey.UnicodeChar <= '9')) {
              ReadMode1_WriteBuffer[count].value = (UINT8)InputKey.UnicodeChar - 48;
              ReadMode1_WriteBuffer[count].position.column = CursorPosition.column;
              ReadMode1_WriteBuffer[count].position.row = CursorPosition.row;
              Print(L"%c", InputKey.UnicodeChar);

              CursorPosition.column = CursorPosition.column + 1;
              gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);
              count++;
              continue;
            }

          } else if (ReadMode == WORD) {
            if (count == (ReadMode * 2)) {
              count = 0;
              gST->ConOut->ClearScreen(gST->ConOut);
              Address.Offset = ((ReadMode2_WriteBuffer[0].position.column -           \
                                  ReadMode2_ResetPosition.column) / 6) * (ReadMode) + \
                                  16 * (ReadMode2_WriteBuffer[0].position.row -       \
                                  ReadMode2_ResetPosition.row);
              
              WriteBufferConvert = ((ReadMode2_WriteBuffer[0].value << 12) | \
                                    (ReadMode2_WriteBuffer[1].value << 8)  | \
                                    (ReadMode2_WriteBuffer[2].value << 4)  | \
                                    (ReadMode2_WriteBuffer[3].value));

              WriteRegist(&Address, WriteBufferConvert, ReadMode);
              ReadRegist(&Address, &CursorPosition, ReadMode);

              Mode = BRANCH_PAGE_MODE;
              goto ChangeMode;
            }

            if (('a' <= InputKey.UnicodeChar && InputKey.UnicodeChar <= 'f')) {
              ReadMode2_WriteBuffer[count].value = (UINT8)InputKey.UnicodeChar - 87;
              ReadMode2_WriteBuffer[count].position.column = CursorPosition.column;
              ReadMode2_WriteBuffer[count].position.row = CursorPosition.row;
              Print(L"%c", InputKey.UnicodeChar);

              CursorPosition.column = CursorPosition.column + 1;
              gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);
              count++;
              continue;

            } else if (('0' <= InputKey.UnicodeChar && InputKey.UnicodeChar <= '9')) {
              ReadMode2_WriteBuffer[count].value = (UINT8)InputKey.UnicodeChar - 48;
              ReadMode2_WriteBuffer[count].position.column = CursorPosition.column;
              ReadMode2_WriteBuffer[count].position.row = CursorPosition.row;
              Print(L"%c", InputKey.UnicodeChar);

              CursorPosition.column = CursorPosition.column + 1;
              gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);
              count++;
              continue;
            }

          } else if (ReadMode == DWORD) {
            if (count == (ReadMode * 2)) {
              count = 0;
              gST->ConOut->ClearScreen(gST->ConOut);
              Address.Offset = ((ReadMode4_WriteBuffer[0].position.column -             \
                                  ReadMode4_ResetPosition.column) / 12) * (ReadMode) +  \
                                  16 * (ReadMode4_WriteBuffer[0].position.row -         \
                                  ReadMode4_ResetPosition.row);
              
              WriteBufferConvert = ((ReadMode4_WriteBuffer[0].value << 28) | \
                                    (ReadMode4_WriteBuffer[1].value << 24) | \
                                    (ReadMode4_WriteBuffer[2].value << 20) | \
                                    (ReadMode4_WriteBuffer[3].value << 16) | \
                                    (ReadMode4_WriteBuffer[4].value << 12) | \
                                    (ReadMode4_WriteBuffer[5].value << 8)  | \
                                    (ReadMode4_WriteBuffer[6].value << 4)  | \
                                    (ReadMode4_WriteBuffer[7].value));

              WriteRegist(&Address, WriteBufferConvert, ReadMode);
              ReadRegist(&Address, &CursorPosition, ReadMode);

              Mode = BRANCH_PAGE_MODE;
              goto ChangeMode;
            }

            if (('a' <= InputKey.UnicodeChar && InputKey.UnicodeChar <= 'f')) {
              ReadMode4_WriteBuffer[count].value = (UINT8)InputKey.UnicodeChar - 87;
              ReadMode4_WriteBuffer[count].position.column = CursorPosition.column;
              ReadMode4_WriteBuffer[count].position.row = CursorPosition.row;
              Print(L"%c", InputKey.UnicodeChar);

              CursorPosition.column = CursorPosition.column + 1;
              gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);
              count++;
              continue;

            } else if (('0' <= InputKey.UnicodeChar && InputKey.UnicodeChar <= '9')) {
              ReadMode4_WriteBuffer[count].value = (UINT8)InputKey.UnicodeChar - 48;
              ReadMode4_WriteBuffer[count].position.column = CursorPosition.column;
              ReadMode4_WriteBuffer[count].position.row = CursorPosition.row;
              Print(L"%c", InputKey.UnicodeChar);

              CursorPosition.column = CursorPosition.column + 1;
              gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);
              count++;
              continue;
            }
          }

          if (InputKey.ScanCode == SCAN_ESC) {
            gST->ConOut->ClearScreen(gST->ConOut);
            goto Exit;
          }

          switch (InputKey.ScanCode) {

          case SCAN_F3:
            Mode = BRANCH_PAGE_MODE;
            break;
          }      
        }
      }
      
      
    }

    //
    // to get out
    //
    Exit:

    Status = EFI_SUCCESS;

    return Status;
  }

  UINT8 ShowMainPage(POSITION *CursorPosition)
  {
    EFI_PCI_ROOT_BRIDGE_IO_PROTOCOL      *PciRootBridgeIo;
    EFI_STATUS                           Status;
    UINT64                               PciAddress;
    UINT16                               Bus;
    UINT16                               Device;
    UINT16                               Func;
    UINT16                               Offset;
    UINT8                                PciData8;            // read buffer  
    UINT8                                Num; 
    UINT8                                Buffer[4];

    Num = 0;
    PciData8 = 0;

    gBS->LocateProtocol (&gEfiPciRootBridgeIoProtocolGuid, NULL, &PciRootBridgeIo);
    gST->ConOut->ClearScreen(gST->ConOut);

    Print(L"|====================================================|\n");
    Print(L"|                    PCI   List                      |\n");
    Print(L"|====================================================|\n");
    Print(L"|              BUS       DEV       FUN               |\n");
    Print(L"|====================================================|\n");
    for (Bus = 0; Bus <= PCI_MAX_BUS; Bus++) {
      for (Device = 0; Device <= PCI_MAX_DEVICE; Device++) {
        for (Func = 0; Func <= PCI_MAX_FUNC; Func++) {
          for (Offset = 0; Offset < 4; Offset++) {                    // just get vendor_ID & device_ID
            PciAddress = EFI_PCI_ADDRESS (Bus, Device, Func, Offset);
            Status = PciRootBridgeIo->Pci.Read (
                                        PciRootBridgeIo,              // This
                                        EfiPciWidthUint8,             // Width
                                        PciAddress,                   // Address
                                        1,                            // Count
                                        &PciData8                     // *Buffer
                                        );
            Buffer[Offset] = PciData8;                                  
          }
          if (Buffer[0] != 0xff && Buffer[1] != 0xff) {
            Num++;
            Print(L"|%17.2x%10.2x%10.2x               |\n", Bus, Device, Func);
          }
        }
      }
    }
    Print(L"|====================================================|\n");
    Print(L"| [Arrow key] : Choose                               |\n");
    Print(L"| [F1] : Enter                                       |\n");
    Print(L"| [Esc] : Escape                                     |\n");
    Print(L"|====================================================|\n");

    *CursorPosition = MainPage_ResetPosition;
    gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition->column, CursorPosition->row);

    return Num;
  }

  void ShowRegistPage(ADDRESS *Address, POSITION *CursorPosition)
  {
    EFI_PCI_ROOT_BRIDGE_IO_PROTOCOL      *PciRootBridgeIo;
    EFI_STATUS                           Status;
    UINT64                               PciAddress;
    UINT16                               Bus;
    UINT16                               Device;
    UINT16                               Func;
    UINT16                               Offset;
    UINT8                                PciData8;                    // read buffer
    UINT8                                Num; 
    UINT8                                Buffer[256] = {0};

    Num = 0;
    PciData8 = 0;

    gBS->LocateProtocol (&gEfiPciRootBridgeIoProtocolGuid, NULL, &PciRootBridgeIo);
    gST->ConOut->ClearScreen(gST->ConOut);

    for (Bus = 0; Bus <= PCI_MAX_BUS; Bus++) {
      for (Device = 0; Device <= PCI_MAX_DEVICE; Device++) {
        for (Func = 0; Func <= PCI_MAX_FUNC; Func++) {
          for (Offset = 0; Offset < 256; Offset++) {                   // get all register
            PciAddress = EFI_PCI_ADDRESS (Bus, Device, Func, Offset);
            Status = PciRootBridgeIo->Pci.Read (
                                        PciRootBridgeIo,               // This
                                        EfiPciWidthUint8,              // Width
                                        PciAddress,                    // Address
                                        1,                             // Count
                                        &PciData8                      // *Buffer
                                        );
            Buffer[Offset] = PciData8;

            if (Buffer[0] == 0xff && Buffer[1] == 0xff) 
              break;
          }
          if (Buffer[0] != 0xff && Buffer[1] != 0xff) {
            Num++;
            if (Num == ((CursorPosition->row)-4)) {
              Address->Bus = Bus;
              Address->Device = Device;
              Address->Func = Func;
              Address->Offset = 0;

              Print(L"|  BUS:%.2x  DEV:%.2x  FUN:%.2x                            |\n", Bus, Device, Func);
              Print(L"====================================================|\n");
              Print(L"|  | 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F |\n");
              Print(L"|====================================================|\n");

              for (Offset = 0; Offset < 256; Offset++) {
                if ((Offset % 16) == 0) 
                  Print(L"|%.2x|", Offset);

                Print(L"%3.2x", Buffer[Offset]);

                if ((Offset % 16) == 15) 
                  Print(L" |\n");
              }
            }
          }
        }
      }
    }
    Print(L"|====================================================|\n");
    Print(L"| [Arrow key]:Choose   [F1]:Back      [F2]:Read Mode |\n");
    Print(L"| [F3]:Modify          [Esc]:Escape                  |\n");
    Print(L"|====================================================|\n");

    *CursorPosition = ReadMode1_ResetPosition;
    gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition->column, CursorPosition->row);

    return;
  }

  void ReadRegist(ADDRESS *Address, POSITION *CursorPosition, UINT8 ReadMode)
  {
    EFI_PCI_ROOT_BRIDGE_IO_PROTOCOL      *PciRootBridgeIo;
    EFI_STATUS                           Status;
    UINT64                               PciAddress;
    UINT8                                PciData8;          // 8bit  read buffer
    UINT16                               PciData16;         // 16bit read buffer
    UINT32                               PciData32;         // 32bit read buffer
    UINT16                               Offset;

    gBS->LocateProtocol (&gEfiPciRootBridgeIoProtocolGuid, NULL, &PciRootBridgeIo);
    gST->ConOut->ClearScreen(gST->ConOut);

    Print(L"|  BUS:%.2x  DEV:%.2x  FUN:%.2x                            |\n", Address->Bus, 
                                                                            Address->Device, 
                                                                            Address->Func);

    Print(L"|====================================================|\n");
    if (ReadMode == BYTE) {
      Print(L"|  | 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F |\n");
      Print(L"|====================================================|\n");

      for (Offset = 0; Offset < 256; Offset++) {
        PciAddress = EFI_PCI_ADDRESS (Address->Bus, Address->Device, Address->Func, Offset);
        Status = PciRootBridgeIo->Pci.Read (
                                    PciRootBridgeIo,      // This
                                    EfiPciWidthUint8,     // Width
                                    PciAddress,           // Address
                                    1,                    // Count
                                    &PciData8             // *Buffer
                                    );
        if ((Offset % 16) == 0) 
          Print(L"|%.2x|", Offset);

        Print(L"%3.2x", PciData8);

        if ((Offset % 16) == 15) 
          Print(L" |\n");   
      }
    } else if (ReadMode == WORD) {
      Print(L"|  |  0100  0302  0504  0706  0908  0B0A  0D0C  0F0E |\n");
      Print(L"|====================================================|\n");

      for (Offset = 0; Offset < 256; Offset += 2) {
        PciAddress = EFI_PCI_ADDRESS (Address->Bus, Address->Device, Address->Func, Offset);
        Status = PciRootBridgeIo->Pci.Read (
                                    PciRootBridgeIo,      // This
                                    EfiPciWidthUint16,    // Width
                                    PciAddress,           // Address
                                    1,                    // Count
                                    &PciData16            // *Buffer
                                    );
        if ((Offset % 16) == 0) 
          Print(L"|%.2x|", Offset);

        Print(L"%6.4x", PciData16);

        if ((Offset % 16) == 14) 
          Print(L" |\n");
      }
    } else if (ReadMode == DWORD) {
      Print(L"|  |    03020100    07060504    0B0A0908    0F0E0D0C |\n");
      Print(L"|====================================================|\n");

      for (Offset = 0; Offset < 256; Offset += 4) {
        PciAddress = EFI_PCI_ADDRESS (Address->Bus, Address->Device, Address->Func, Offset);
        Status = PciRootBridgeIo->Pci.Read (
                                    PciRootBridgeIo,      // This
                                    EfiPciWidthUint32,    // Width
                                    PciAddress,           // Address
                                    1,                    // Count
                                    &PciData32            // *Buffer
                                    );

        if ((Offset % 16) == 0) 
          Print(L"|%.2x|", Offset);

        Print(L"%12.8x", PciData32);

        if ((Offset % 16) == 12) 
          Print(L" |\n");
      }
    }                     
    Print(L"|====================================================|\n");
    Print(L"| [Arrow key]:Choose   [F1]:Back      [F2]:Read Mode |\n");
    Print(L"| [F3]:Modify          [Esc]:Escape                  |\n");
    Print(L"|====================================================|\n");

    if (ReadMode == BYTE) {
      *CursorPosition = ReadMode1_ResetPosition;
      gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition->column, CursorPosition->row);
    } else if (ReadMode == WORD) {
      *CursorPosition = ReadMode2_ResetPosition;
      gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition->column, CursorPosition->row);
    } else if (ReadMode == DWORD) {
      *CursorPosition = ReadMode4_ResetPosition;
      gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition->column, CursorPosition->row);
    }                            

    return;
  }

  void WriteRegist(ADDRESS *Address, UINT32 WriteBufferConvert, UINT8 ReadMode)
  {
    EFI_PCI_ROOT_BRIDGE_IO_PROTOCOL      *PciRootBridgeIo;
    EFI_STATUS                           Status;
    UINT64                               PciAddress; 
    UINT8                                PciData8;            // 8bit  write buffer
    UINT16                               PciData16;           // 16bit write buffer
    UINT32                               PciData32;           // 32bit write buffer

    if (ReadMode == BYTE) {

      PciData8 = (UINT8)WriteBufferConvert;

      gBS->LocateProtocol (&gEfiPciRootBridgeIoProtocolGuid, NULL, &PciRootBridgeIo);
      gST->ConOut->ClearScreen(gST->ConOut);

      PciAddress = EFI_PCI_ADDRESS (Address->Bus, Address->Device, Address->Func, Address->Offset);
      Status = PciRootBridgeIo->Pci.Write (
                                  PciRootBridgeIo,            // This
                                  EfiPciWidthUint8,           // Width
                                  PciAddress,                 // Address
                                  1,                          // Count
                                  &PciData8                   // *Buffer
                                  );                                 
      return;

    } else if (ReadMode == WORD) {

      PciData16 = (UINT16)WriteBufferConvert;

      gBS->LocateProtocol (&gEfiPciRootBridgeIoProtocolGuid, NULL, &PciRootBridgeIo);
      gST->ConOut->ClearScreen(gST->ConOut);

      PciAddress = EFI_PCI_ADDRESS (Address->Bus, Address->Device, Address->Func, Address->Offset);
      Status = PciRootBridgeIo->Pci.Write (
                                  PciRootBridgeIo,            // This
                                  EfiPciWidthUint16,          // Width
                                  PciAddress,                 // Address
                                  1,                          // Count
                                  &PciData16                  // *Buffer
                                  );                                 
      return;

    } else if (ReadMode == DWORD) {

      PciData32 = WriteBufferConvert;

      gBS->LocateProtocol (&gEfiPciRootBridgeIoProtocolGuid, NULL, &PciRootBridgeIo);
      gST->ConOut->ClearScreen(gST->ConOut);

      PciAddress = EFI_PCI_ADDRESS (Address->Bus, Address->Device, Address->Func, Address->Offset);
      Status = PciRootBridgeIo->Pci.Write (
                                  PciRootBridgeIo,            // This
                                  EfiPciWidthUint32,          // Width
                                  PciAddress,                 // Address
                                  1,                          // Count
                                  &PciData32                  // *Buffer
                                  );                                 
      return;
    }
  }
*/

/*// PciUtility_06 finish(v2)
  #include <PciUtility_06.h>

  EFI_STATUS
  EFIAPI
  UefiMain (
    IN EFI_HANDLE ImageHandle, 
    IN EFI_SYSTEM_TABLE *SystemTable
    )
  { 
    EFI_STATUS                    Status;  
    EFI_INPUT_KEY                 InputKey;
    POSITION                      CursorPosition;
    UINT8                         Mode;
    UINT8                         AllBranchPage;
    UINT8                         ReadMode;
    ADDRESS                       Address;

    //
    // initialization and into the main page
    //
    gST->ConOut->ClearScreen(gST->ConOut);
    gST->ConOut->SetCursorPosition(gST->ConOut, 0, 0);
    gST->ConOut->EnableCursor(gST->ConOut, TRUE);
    Mode = MAIN_PAGE_MODE;
    ReadMode = BYTE;
    AllBranchPage = ShowMainPage(&CursorPosition);
    
    //
    // choose mode loop
    //
    while (TRUE) {
      
      //
      // to change mode
      //
      ChangeMode:

      //
      // MAIN_PAGE_MODE
      // with up, down, F1, Esc key response
      //
      while (Mode == MAIN_PAGE_MODE) {
        gST->ConIn->ReadKeyStroke(gST->ConIn, &InputKey);

        if (InputKey.ScanCode == SCAN_ESC) {
          gST->ConOut->ClearScreen(gST->ConOut);
          goto Exit;
        }

        switch (InputKey.ScanCode) {

        case SCAN_UP:
          CursorPosition.row--;
          if (CursorPosition.row < MainPage_ResetPosition.row) {
            CursorPosition.row = MainPage_ResetPosition.row;
          }
          gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);    
          continue;

        case SCAN_DOWN:
          CursorPosition.row++;
          if (CursorPosition.row > (AllBranchPage + MainPage_ResetPosition.row - 1)) {
            CursorPosition.row = (AllBranchPage + MainPage_ResetPosition.row - 1);
          }
          gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);
          continue;

        case SCAN_F1:
          Mode = BRANCH_PAGE_MODE;
          ShowRegistPage(&Address, &CursorPosition);
          goto ChangeMode;
        }
      }

      //
      // BRANCH_PAGE_MODE
      // with up, down, right, left, F1, F2, F3, Esc key response
      //
      while (Mode == BRANCH_PAGE_MODE) {
        gST->ConIn->ReadKeyStroke(gST->ConIn, &InputKey);

        if (InputKey.ScanCode == SCAN_ESC) {
          gST->ConOut->ClearScreen(gST->ConOut);
          goto Exit;
        }

        switch (InputKey.ScanCode) {

        case SCAN_UP:
          CursorPosition.row--;
          if (CursorPosition.row < ReadMode1_ResetPosition.row) {
            CursorPosition.row = ReadMode1_ResetPosition.row;
          }     

          DisplayPosition(ReadMode, &CursorPosition);
          
          gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);    
          continue;

        case SCAN_DOWN:
          CursorPosition.row++;
          if (CursorPosition.row > (ReadMode1_ResetPosition.row + 15)) {
            CursorPosition.row = (ReadMode1_ResetPosition.row + 15);
          }

          DisplayPosition(ReadMode, &CursorPosition);

          gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);
          continue;
        
        case SCAN_RIGHT:
          CursorPosition.column = CursorPosition.column + (ReadMode * 3);
          if (CursorPosition.column > (52 - 2 * ReadMode)) {
            CursorPosition.column = (52 - 2 * ReadMode);
          }

          DisplayPosition(ReadMode, &CursorPosition);

          gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);
          continue;

        case SCAN_LEFT:
          CursorPosition.column = CursorPosition.column - (ReadMode * 3);
          if (CursorPosition.column < (ReadMode + 4)) {
            CursorPosition.column = (ReadMode + 4);
          }

          DisplayPosition(ReadMode, &CursorPosition);

          gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);
          continue;

        case SCAN_F1:
          Mode = MAIN_PAGE_MODE;
          ReadMode = BYTE;
          ShowMainPage(&CursorPosition);
          goto ChangeMode;
        
        case SCAN_F2:
          ReadMode *= 2;
          if (ReadMode > 4) ReadMode = BYTE;
          ReadRegist(&Address, &CursorPosition, ReadMode);
          continue;
        case SCAN_F3:
          Mode = WRITE_MODE;
          break;;
        }
      }

      //
      // WRITE_MODE
      // with number(0~9),alphabet(a~f) key response
      //
      if (Mode == WRITE_MODE){
        WRITE_BUFFER ReadMode1_WriteBuffer[2];
        WRITE_BUFFER ReadMode2_WriteBuffer[4];
        WRITE_BUFFER ReadMode4_WriteBuffer[8];
        UINT8 count;
        UINT8 i;
        UINT32 WriteBufferConvert;

        //
        // initialize write buffer、count
        //
        for (i = 0; i < 2; i++) {
          ReadMode1_WriteBuffer[i].value = 0;
          ReadMode1_WriteBuffer[i].position = ReadMode1_ResetPosition;
        }
        for (i = 0; i < 4; i++) {
          ReadMode2_WriteBuffer[i].value = 0;
          ReadMode2_WriteBuffer[i].position = ReadMode2_ResetPosition;
        }
        for (i = 0; i < 8; i++) {
          ReadMode4_WriteBuffer[i].value = 0;
          ReadMode4_WriteBuffer[i].position = ReadMode4_ResetPosition;
        }
        count = 0;                // for write_buffer operation
        WriteBufferConvert = 0;   // buffer for write_buffer

        while (TRUE) {
          gST->ConIn->ReadKeyStroke(gST->ConIn, &InputKey);

          if (ReadMode == BYTE) {
            if (count == (ReadMode * 2)) {
              count = 0;
              gST->ConOut->ClearScreen(gST->ConOut);
              Address.Offset = ((ReadMode1_WriteBuffer[0].position.column -           \
                                  ReadMode1_ResetPosition.column) / 3) * (ReadMode) + \
                                  16 * (ReadMode1_WriteBuffer[0].position.row -       \
                                  ReadMode1_ResetPosition.row);

              WriteBufferConvert = ((ReadMode1_WriteBuffer[0].value << 4) | (ReadMode1_WriteBuffer[1].value));
              WriteRegist(&Address, WriteBufferConvert, ReadMode);
              ReadRegist(&Address, &CursorPosition, ReadMode);

              Mode = BRANCH_PAGE_MODE;
              goto ChangeMode;
            }

            if (('a' <= InputKey.UnicodeChar && InputKey.UnicodeChar <= 'f')) {
              ReadMode1_WriteBuffer[count].value = (UINT8)InputKey.UnicodeChar - 87;
              ReadMode1_WriteBuffer[count].position.column = CursorPosition.column;
              ReadMode1_WriteBuffer[count].position.row = CursorPosition.row;
              Print(L"%c", InputKey.UnicodeChar);

              CursorPosition.column = CursorPosition.column + 1;
              gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);
              count++;
              continue;

            } else if (('0' <= InputKey.UnicodeChar && InputKey.UnicodeChar <= '9')) {
              ReadMode1_WriteBuffer[count].value = (UINT8)InputKey.UnicodeChar - 48;
              ReadMode1_WriteBuffer[count].position.column = CursorPosition.column;
              ReadMode1_WriteBuffer[count].position.row = CursorPosition.row;
              Print(L"%c", InputKey.UnicodeChar);

              CursorPosition.column = CursorPosition.column + 1;
              gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);
              count++;
              continue;
            }

          } else if (ReadMode == WORD) {
            if (count == (ReadMode * 2)) {
              count = 0;
              gST->ConOut->ClearScreen(gST->ConOut);
              Address.Offset = ((ReadMode2_WriteBuffer[0].position.column -           \
                                  ReadMode2_ResetPosition.column) / 6) * (ReadMode) + \
                                  16 * (ReadMode2_WriteBuffer[0].position.row -       \
                                  ReadMode2_ResetPosition.row);
              
              WriteBufferConvert = ((ReadMode2_WriteBuffer[0].value << 12) | \
                                    (ReadMode2_WriteBuffer[1].value << 8)  | \
                                    (ReadMode2_WriteBuffer[2].value << 4)  | \
                                    (ReadMode2_WriteBuffer[3].value));

              WriteRegist(&Address, WriteBufferConvert, ReadMode);
              ReadRegist(&Address, &CursorPosition, ReadMode);

              Mode = BRANCH_PAGE_MODE;
              goto ChangeMode;
            }

            if (('a' <= InputKey.UnicodeChar && InputKey.UnicodeChar <= 'f')) {
              ReadMode2_WriteBuffer[count].value = (UINT8)InputKey.UnicodeChar - 87;
              ReadMode2_WriteBuffer[count].position.column = CursorPosition.column;
              ReadMode2_WriteBuffer[count].position.row = CursorPosition.row;
              Print(L"%c", InputKey.UnicodeChar);

              CursorPosition.column = CursorPosition.column + 1;
              gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);
              count++;
              continue;

            } else if (('0' <= InputKey.UnicodeChar && InputKey.UnicodeChar <= '9')) {
              ReadMode2_WriteBuffer[count].value = (UINT8)InputKey.UnicodeChar - 48;
              ReadMode2_WriteBuffer[count].position.column = CursorPosition.column;
              ReadMode2_WriteBuffer[count].position.row = CursorPosition.row;
              Print(L"%c", InputKey.UnicodeChar);

              CursorPosition.column = CursorPosition.column + 1;
              gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);
              count++;
              continue;
            }

          } else if (ReadMode == DWORD) {
            if (count == (ReadMode * 2)) {
              count = 0;
              gST->ConOut->ClearScreen(gST->ConOut);
              Address.Offset = ((ReadMode4_WriteBuffer[0].position.column -             \
                                  ReadMode4_ResetPosition.column) / 12) * (ReadMode) +  \
                                  16 * (ReadMode4_WriteBuffer[0].position.row -         \
                                  ReadMode4_ResetPosition.row);
              
              WriteBufferConvert = ((ReadMode4_WriteBuffer[0].value << 28) | \
                                    (ReadMode4_WriteBuffer[1].value << 24) | \
                                    (ReadMode4_WriteBuffer[2].value << 20) | \
                                    (ReadMode4_WriteBuffer[3].value << 16) | \
                                    (ReadMode4_WriteBuffer[4].value << 12) | \
                                    (ReadMode4_WriteBuffer[5].value << 8)  | \
                                    (ReadMode4_WriteBuffer[6].value << 4)  | \
                                    (ReadMode4_WriteBuffer[7].value));

              WriteRegist(&Address, WriteBufferConvert, ReadMode);
              ReadRegist(&Address, &CursorPosition, ReadMode);

              Mode = BRANCH_PAGE_MODE;
              goto ChangeMode;
            }

            if (('a' <= InputKey.UnicodeChar && InputKey.UnicodeChar <= 'f')) {
              ReadMode4_WriteBuffer[count].value = (UINT8)InputKey.UnicodeChar - 87;
              ReadMode4_WriteBuffer[count].position.column = CursorPosition.column;
              ReadMode4_WriteBuffer[count].position.row = CursorPosition.row;
              Print(L"%c", InputKey.UnicodeChar);

              CursorPosition.column = CursorPosition.column + 1;
              gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);
              count++;
              continue;

            } else if (('0' <= InputKey.UnicodeChar && InputKey.UnicodeChar <= '9')) {
              ReadMode4_WriteBuffer[count].value = (UINT8)InputKey.UnicodeChar - 48;
              ReadMode4_WriteBuffer[count].position.column = CursorPosition.column;
              ReadMode4_WriteBuffer[count].position.row = CursorPosition.row;
              Print(L"%c", InputKey.UnicodeChar);

              CursorPosition.column = CursorPosition.column + 1;
              gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);
              count++;
              continue;
            }
          }

          if (InputKey.ScanCode == SCAN_ESC) {
            gST->ConOut->ClearScreen(gST->ConOut);
            goto Exit;
          }

          switch (InputKey.ScanCode) {

          case SCAN_F3:
            Mode = BRANCH_PAGE_MODE;
            break;
          }      
        }
      }
      
      
    }

    //
    // to get out
    //
    Exit:

    Status = EFI_SUCCESS;

    return Status;
  }

  UINT8 ShowMainPage(POSITION *CursorPosition)
  {
    EFI_PCI_ROOT_BRIDGE_IO_PROTOCOL      *PciRootBridgeIo;
    EFI_STATUS                           Status;
    UINT64                               PciAddress;
    UINT16                               Bus;
    UINT16                               Device;
    UINT16                               Func;
    UINT16                               Offset;
    UINT8                                PciData8;            // read buffer  
    UINT8                                Num; 
    UINT8                                Buffer[4];

    Num = 0;
    PciData8 = 0;

    gBS->LocateProtocol (&gEfiPciRootBridgeIoProtocolGuid, NULL, &PciRootBridgeIo);
    gST->ConOut->ClearScreen(gST->ConOut);

    Print(L"|====================================================|\n");
    Print(L"|                    PCI   List                      |\n");
    Print(L"|====================================================|\n");
    Print(L"|              BUS       DEV       FUN               |\n");
    Print(L"|====================================================|\n");
    for (Bus = 0; Bus <= PCI_MAX_BUS; Bus++) {
      for (Device = 0; Device <= PCI_MAX_DEVICE; Device++) {
        for (Func = 0; Func <= PCI_MAX_FUNC; Func++) {
          for (Offset = 0; Offset < 4; Offset++) {                    // just get vendor_ID & device_ID
            PciAddress = EFI_PCI_ADDRESS (Bus, Device, Func, Offset);
            Status = PciRootBridgeIo->Pci.Read (
                                        PciRootBridgeIo,              // This
                                        EfiPciWidthUint8,             // Width
                                        PciAddress,                   // Address
                                        1,                            // Count
                                        &PciData8                     // *Buffer
                                        );
            Buffer[Offset] = PciData8;                                  
          }
          if (Buffer[0] != 0xff && Buffer[1] != 0xff) {
            Num++;
            Print(L"|%17.2x%10.2x%10.2x               |\n", Bus, Device, Func);
          }
        }
      }
    }
    Print(L"|====================================================|\n");
    Print(L"| [Arrow key] : Choose                               |\n");
    Print(L"| [F1] : Enter                                       |\n");
    Print(L"| [Esc] : Escape                                     |\n");
    Print(L"|====================================================|\n");

    *CursorPosition = MainPage_ResetPosition;
    gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition->column, CursorPosition->row);

    return Num;
  }

  void ShowRegistPage(ADDRESS *Address, POSITION *CursorPosition)
  {
    EFI_PCI_ROOT_BRIDGE_IO_PROTOCOL      *PciRootBridgeIo;
    EFI_STATUS                           Status;
    UINT64                               PciAddress;
    UINT16                               Bus;
    UINT16                               Device;
    UINT16                               Func;
    UINT16                               Offset;
    UINT8                                PciData8;                    // read buffer
    UINT8                                Num; 
    UINT8                                Buffer[256] = {0};

    Num = 0;
    PciData8 = 0;

    gBS->LocateProtocol (&gEfiPciRootBridgeIoProtocolGuid, NULL, &PciRootBridgeIo);
    gST->ConOut->ClearScreen(gST->ConOut);

    for (Bus = 0; Bus <= PCI_MAX_BUS; Bus++) {
      for (Device = 0; Device <= PCI_MAX_DEVICE; Device++) {
        for (Func = 0; Func <= PCI_MAX_FUNC; Func++) {
          for (Offset = 0; Offset < 256; Offset++) {                   // get all register
            PciAddress = EFI_PCI_ADDRESS (Bus, Device, Func, Offset);
            Status = PciRootBridgeIo->Pci.Read (
                                        PciRootBridgeIo,               // This
                                        EfiPciWidthUint8,              // Width
                                        PciAddress,                    // Address
                                        1,                             // Count
                                        &PciData8                      // *Buffer
                                        );
            Buffer[Offset] = PciData8;

            if (Buffer[0] == 0xff && Buffer[1] == 0xff) 
              break;
          }
          if (Buffer[0] != 0xff && Buffer[1] != 0xff) {
            Num++;
            if (Num == ((CursorPosition->row)-4)) {
              Address->Bus = Bus;
              Address->Device = Device;
              Address->Func = Func;
              Address->Offset = 0;

              Print(L"|  BUS:%.2x  DEV:%.2x  FUN:%.2x                            |\n", Bus, Device, Func);
              Print(L"====================================================|\n");
              Print(L"|00| 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F |\n");
              Print(L"|====================================================|\n");

              for (Offset = 0; Offset < 256; Offset++) {
                if ((Offset % 16) == 0) 
                  Print(L"|%.2x|", Offset);

                Print(L"%3.2x", Buffer[Offset]);

                if ((Offset % 16) == 15) 
                  Print(L" |\n");
              }
            }
          }
        }
      }
    }
    Print(L"|====================================================|\n");
    Print(L"| [Arrow key]:Choose   [F1]:Back      [F2]:Read Mode |\n");
    Print(L"| [F3]:Modify          [Esc]:Escape                  |\n");
    Print(L"|====================================================|\n");

    *CursorPosition = ReadMode1_ResetPosition;
    gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition->column, CursorPosition->row);

    return;
  }

  void ReadRegist(ADDRESS *Address, POSITION *CursorPosition, UINT8 ReadMode)
  {
    EFI_PCI_ROOT_BRIDGE_IO_PROTOCOL      *PciRootBridgeIo;
    EFI_STATUS                           Status;
    UINT64                               PciAddress;
    UINT8                                PciData8;          // 8bit  read buffer
    UINT16                               PciData16;         // 16bit read buffer
    UINT32                               PciData32;         // 32bit read buffer
    UINT16                               Offset;

    gBS->LocateProtocol (&gEfiPciRootBridgeIoProtocolGuid, NULL, &PciRootBridgeIo);
    gST->ConOut->ClearScreen(gST->ConOut);

    Print(L"|  BUS:%.2x  DEV:%.2x  FUN:%.2x                            |\n", Address->Bus, 
                                                                            Address->Device, 
                                                                            Address->Func);

    Print(L"|====================================================|\n");
    if (ReadMode == BYTE) {
      Print(L"|00| 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F |\n");
      Print(L"|====================================================|\n");

      for (Offset = 0; Offset < 256; Offset++) {
        PciAddress = EFI_PCI_ADDRESS (Address->Bus, Address->Device, Address->Func, Offset);
        Status = PciRootBridgeIo->Pci.Read (
                                    PciRootBridgeIo,      // This
                                    EfiPciWidthUint8,     // Width
                                    PciAddress,           // Address
                                    1,                    // Count
                                    &PciData8             // *Buffer
                                    );
        if ((Offset % 16) == 0) 
          Print(L"|%.2x|", Offset);

        Print(L"%3.2x", PciData8);

        if ((Offset % 16) == 15) 
          Print(L" |\n");   
      }
    } else if (ReadMode == WORD) {
      Print(L"|00|  0100  0302  0504  0706  0908  0B0A  0D0C  0F0E |\n");
      Print(L"|====================================================|\n");

      for (Offset = 0; Offset < 256; Offset += 2) {
        PciAddress = EFI_PCI_ADDRESS (Address->Bus, Address->Device, Address->Func, Offset);
        Status = PciRootBridgeIo->Pci.Read (
                                    PciRootBridgeIo,      // This
                                    EfiPciWidthUint16,    // Width
                                    PciAddress,           // Address
                                    1,                    // Count
                                    &PciData16            // *Buffer
                                    );
        if ((Offset % 16) == 0) 
          Print(L"|%.2x|", Offset);

        Print(L"%6.4x", PciData16);

        if ((Offset % 16) == 14) 
          Print(L" |\n");
      }
    } else if (ReadMode == DWORD) {
      Print(L"|00|    03020100    07060504    0B0A0908    0F0E0D0C |\n");
      Print(L"|====================================================|\n");

      for (Offset = 0; Offset < 256; Offset += 4) {
        PciAddress = EFI_PCI_ADDRESS (Address->Bus, Address->Device, Address->Func, Offset);
        Status = PciRootBridgeIo->Pci.Read (
                                    PciRootBridgeIo,      // This
                                    EfiPciWidthUint32,    // Width
                                    PciAddress,           // Address
                                    1,                    // Count
                                    &PciData32            // *Buffer
                                    );

        if ((Offset % 16) == 0) 
          Print(L"|%.2x|", Offset);

        Print(L"%12.8x", PciData32);

        if ((Offset % 16) == 12) 
          Print(L" |\n");
      }
    }                     
    Print(L"|====================================================|\n");
    Print(L"| [Arrow key]:Choose   [F1]:Back      [F2]:Read Mode |\n");
    Print(L"| [F3]:Modify          [Esc]:Escape                  |\n");
    Print(L"|====================================================|\n");

    if (ReadMode == BYTE) {
      *CursorPosition = ReadMode1_ResetPosition;
      gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition->column, CursorPosition->row);
    } else if (ReadMode == WORD) {
      *CursorPosition = ReadMode2_ResetPosition;
      gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition->column, CursorPosition->row);
    } else if (ReadMode == DWORD) {
      *CursorPosition = ReadMode4_ResetPosition;
      gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition->column, CursorPosition->row);
    }                            

    return;
  }

  void WriteRegist(ADDRESS *Address, UINT32 WriteBufferConvert, UINT8 ReadMode)
  {
    EFI_PCI_ROOT_BRIDGE_IO_PROTOCOL      *PciRootBridgeIo;
    EFI_STATUS                           Status;
    UINT64                               PciAddress; 
    UINT8                                PciData8;            // 8bit  write buffer
    UINT16                               PciData16;           // 16bit write buffer
    UINT32                               PciData32;           // 32bit write buffer

    if (ReadMode == BYTE) {

      PciData8 = (UINT8)WriteBufferConvert;

      gBS->LocateProtocol (&gEfiPciRootBridgeIoProtocolGuid, NULL, &PciRootBridgeIo);
      gST->ConOut->ClearScreen(gST->ConOut);

      PciAddress = EFI_PCI_ADDRESS (Address->Bus, Address->Device, Address->Func, Address->Offset);
      Status = PciRootBridgeIo->Pci.Write (
                                  PciRootBridgeIo,            // This
                                  EfiPciWidthUint8,           // Width
                                  PciAddress,                 // Address
                                  1,                          // Count
                                  &PciData8                   // *Buffer
                                  );                                 
      return;

    } else if (ReadMode == WORD) {

      PciData16 = (UINT16)WriteBufferConvert;

      gBS->LocateProtocol (&gEfiPciRootBridgeIoProtocolGuid, NULL, &PciRootBridgeIo);
      gST->ConOut->ClearScreen(gST->ConOut);

      PciAddress = EFI_PCI_ADDRESS (Address->Bus, Address->Device, Address->Func, Address->Offset);
      Status = PciRootBridgeIo->Pci.Write (
                                  PciRootBridgeIo,            // This
                                  EfiPciWidthUint16,          // Width
                                  PciAddress,                 // Address
                                  1,                          // Count
                                  &PciData16                  // *Buffer
                                  );                                 
      return;

    } else if (ReadMode == DWORD) {

      PciData32 = WriteBufferConvert;

      gBS->LocateProtocol (&gEfiPciRootBridgeIoProtocolGuid, NULL, &PciRootBridgeIo);
      gST->ConOut->ClearScreen(gST->ConOut);

      PciAddress = EFI_PCI_ADDRESS (Address->Bus, Address->Device, Address->Func, Address->Offset);
      Status = PciRootBridgeIo->Pci.Write (
                                  PciRootBridgeIo,            // This
                                  EfiPciWidthUint32,          // Width
                                  PciAddress,                 // Address
                                  1,                          // Count
                                  &PciData32                  // *Buffer
                                  );                                 
      return;
    }
  }

  void DisplayPosition(UINT8 ReadMode, POSITION *CursorPosition)
  {
    if (ReadMode == BYTE) {                                                                          
      gST->ConOut->SetCursorPosition(gST->ConOut, 1, 2);                                             
      Print(L"%.2x", (CursorPosition->column - 5) / 3 * ReadMode + (CursorPosition->row - 4) * 16);  
    } else if (ReadMode == WORD) {                                                                   
      gST->ConOut->SetCursorPosition(gST->ConOut, 1, 2);                                             
      Print(L"%.2x", (CursorPosition->column - 6) / 6 * ReadMode + (CursorPosition->row - 4) * 16);  
    } else if (ReadMode == DWORD) {                                                                  
      gST->ConOut->SetCursorPosition(gST->ConOut, 1, 2);                                             
      Print(L"%.2x", (CursorPosition->column - 8) / 12 * ReadMode + (CursorPosition->row - 4) * 16); 
    }
  }
*/

/*// BdaCmos_08 finish(v1)
  #include <Uefi.h>
  #include <Library/UefiLib.h>
  #include <Library/UefiApplicationEntryPoint.h>
  #include <Library/UefiBootServicesTableLib.h>
  #include <Protocol/CpuIo2.h>

  #define MAIN_PAGE_MODE   0
  #define BRANCH_PAGE_MODE 1

  #define CmosWritePort 0x70
  #define CmosReadPort  0x71
  #define CmosMaxIndex  0x7f

  #define BdaSegment    0x400

  #define Count         256

  typedef struct {
    INT16 column;         /// cursor column
    INT16 row;            /// cursor row
  } POSITION;

  const POSITION  MainPage_ResetPosition  = {24, 5};
  const POSITION  ResetPosition = {5, 4};

  VOID ReadCmos(POSITION *CursorPosition, UINT8 RecordBuffer[], UINT8 *RecordBufferTime);
  VOID ReadBda(POSITION *CursorPosition, UINT8 RecordBuffer[], UINT8 *RecordBufferTime);
  VOID ReadEbda(POSITION *CursorPosition, UINT8 RecordBuffer[], UINT8 *RecordBufferTime);
  VOID SetRegisterPageAppearance(VOID);
  VOID SetMainPageAppearance(VOID);
  VOID ResetCursorPosition(POSITION *CursorPosition);
  VOID ShowMainPage(POSITION *CursorPosition);
  VOID JudgeFontColor(UINT8 Buffer);

  EFI_STATUS
  EFIAPI
  UefiMain (
    IN EFI_HANDLE ImageHandle, 
    IN EFI_SYSTEM_TABLE *SystemTable
    )
  {
    EFI_STATUS            Status;
    POSITION              CursorPosition;
    UINT8                 AllBranchPage;
    UINT8                 Mode;
    EFI_INPUT_KEY         InputKey;
    UINT8                 RecordBuffer[Count];  
    UINT8                 RecordBufferTime;

    // RecordBuffer = malloc(sizeof(UINT8) * Count);
    AllBranchPage = 3;
    Mode = MAIN_PAGE_MODE;
    
    gST->ConOut->ClearScreen(gST->ConOut);
    gST->ConOut->SetCursorPosition(gST->ConOut, 0, 0);
    gST->ConOut->EnableCursor(gST->ConOut, TRUE);

    ShowMainPage(&CursorPosition);
    
    while (TRUE) {
      
      //
      // to change mode
      //
      ChangeMode:

      //
      // MAIN_PAGE_MODE
      // with up, down, F1, Esc key response
      //
      while (Mode == MAIN_PAGE_MODE) {
        gST->ConIn->ReadKeyStroke(gST->ConIn, &InputKey);

        if (InputKey.ScanCode == SCAN_ESC) {
          gST->ConOut->ClearScreen(gST->ConOut);
          goto Exit;
        }

        switch (InputKey.ScanCode) {

        case SCAN_UP:
          CursorPosition.row--;
          if (CursorPosition.row < MainPage_ResetPosition.row) {
            CursorPosition.row = MainPage_ResetPosition.row;
          }
          gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);    
          continue;

        case SCAN_DOWN:
          CursorPosition.row++;
          if (CursorPosition.row > (AllBranchPage + MainPage_ResetPosition.row - 1)) {
            CursorPosition.row = (AllBranchPage + MainPage_ResetPosition.row - 1);
          }
          gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);
          continue;

        case SCAN_F1:
          RecordBufferTime = 0;
          Mode = BRANCH_PAGE_MODE;

          if (CursorPosition.row == MainPage_ResetPosition.row) {
            ReadBda(&CursorPosition, RecordBuffer, &RecordBufferTime);
          } else if (CursorPosition.row == MainPage_ResetPosition.row + 1) {
            ReadEbda(&CursorPosition, RecordBuffer, &RecordBufferTime);
          } else if (CursorPosition.row == MainPage_ResetPosition.row + 2) {
            ReadCmos(&CursorPosition, RecordBuffer, &RecordBufferTime);
          }

          goto ChangeMode;
        }
      }

      //
      // BRANCH_PAGE_MODE
      // with up, down, right, left, F1, F2, F3, Esc key response
      //
      while (Mode == BRANCH_PAGE_MODE) {
        gST->ConIn->ReadKeyStroke(gST->ConIn, &InputKey);

        if (InputKey.ScanCode == SCAN_ESC) {
          gST->ConOut->ClearScreen(gST->ConOut);
          goto Exit;
        }

        switch (InputKey.ScanCode) {

        case SCAN_F1:
          RecordBufferTime = 0;
          Mode = MAIN_PAGE_MODE;
          ShowMainPage(&CursorPosition);

          goto ChangeMode;

        case SCAN_F2:
          RecordBufferTime = 1;
          if (CursorPosition.column == 0) {
            ReadBda(&CursorPosition, RecordBuffer, &RecordBufferTime);
          } else if (CursorPosition.column == 1) {
            ReadEbda(&CursorPosition, RecordBuffer, &RecordBufferTime);
          } else if (CursorPosition.column == 2) {
            ReadCmos(&CursorPosition, RecordBuffer, &RecordBufferTime);
          }
        }
      }  
    }

    //
    // to get out
    //
    Exit:

    // free(RecordBuffer);

    Status = EFI_SUCCESS;

    return Status;
  }

  VOID ReadCmos(POSITION *CursorPosition, UINT8 RecordBuffer[], UINT8 *RecordBufferTime)
  {
    EFI_CPU_IO2_PROTOCOL               *CpuIo2;
    UINT8                              CmosIndex;
    UINT8                              Buffer[CmosMaxIndex];

    gBS->LocateProtocol (&gEfiCpuIo2ProtocolGuid, NULL, &CpuIo2);

    SetRegisterPageAppearance();
    ResetCursorPosition(CursorPosition);

    for (CmosIndex = 0; CmosIndex <= CmosMaxIndex; CmosIndex++) {
      CpuIo2->Io.Write(
                  CpuIo2,
                  EfiCpuIoWidthUint8,
                  CmosWritePort,
                  1,
                  &CmosIndex
                  );

      CpuIo2->Io.Read(
                  CpuIo2,
                  EfiCpuIoWidthUint8,
                  CmosReadPort,
                  1,
                  &Buffer[CmosIndex]
                  );
      
      if (*RecordBufferTime == 0) {
        *(RecordBuffer + CmosIndex) = Buffer[CmosIndex];
        JudgeFontColor(Buffer[CmosIndex]);
      } else {
        if (*(RecordBuffer + CmosIndex) != Buffer[CmosIndex]) {
          *(RecordBuffer + CmosIndex) = Buffer[CmosIndex];
          gST->ConOut->SetAttribute(gST->ConOut, EFI_LIGHTGREEN | EFI_BACKGROUND_BLACK);
        } else {
          JudgeFontColor(Buffer[CmosIndex]);
        }
      }

      if ((CmosIndex % 16) == 0) {
        Print(L"%2.2x", Buffer[CmosIndex]);
      } else if ((CmosIndex % 16) == 15) {
        Print(L"%3.2x", Buffer[CmosIndex]);
        CursorPosition->column = 5;
        CursorPosition->row++;
        gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition->column, CursorPosition->row);
      } else {
        Print(L"%3.2x", Buffer[CmosIndex]);
      }
    }

    CursorPosition->column = 2;
    CursorPosition->row    = 0;
    gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition->column, CursorPosition->row);
    gST->ConOut->SetAttribute(gST->ConOut, EFI_WHITE | EFI_BACKGROUND_BLACK);
    Print(L"CMOS");

    CursorPosition->column = 2;

    gST->ConOut->EnableCursor(gST->ConOut, FALSE);

    return;
  }

  VOID ReadBda(POSITION *CursorPosition, UINT8 RecordBuffer[], UINT8 *RecordBufferTime)
  {
    EFI_CPU_IO2_PROTOCOL               *CpuIo2;
    UINT16                             BdaOffset;
    UINT8                              Buffer[Count];

    gBS->LocateProtocol (&gEfiCpuIo2ProtocolGuid, NULL, &CpuIo2);

    SetRegisterPageAppearance();
    ResetCursorPosition(CursorPosition);

    for (BdaOffset = 0; BdaOffset < Count; BdaOffset++) {
      CpuIo2->Mem.Read(
                    CpuIo2,
                    EfiCpuIoWidthUint8,
                    BdaSegment + BdaOffset,
                    1,
                    &Buffer[BdaOffset]
                    );

      if (*RecordBufferTime == 0) {
        *(RecordBuffer + BdaOffset) = Buffer[BdaOffset];
        JudgeFontColor(Buffer[BdaOffset]);
      } else {
        if (*(RecordBuffer + BdaOffset) != Buffer[BdaOffset]) {
          *(RecordBuffer + BdaOffset) = Buffer[BdaOffset];
          gST->ConOut->SetAttribute(gST->ConOut, EFI_LIGHTGREEN | EFI_BACKGROUND_BLACK);
        } else {
          JudgeFontColor(Buffer[BdaOffset]);
        }
      }

      if ((BdaOffset % 16) == 0) {
        Print(L"%2.2x", Buffer[BdaOffset]);
      } else if ((BdaOffset % 16) == 15) {
        Print(L"%3.2x", Buffer[BdaOffset]);
        CursorPosition->column = 5;
        CursorPosition->row++;
        gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition->column, CursorPosition->row);
      } else {
        Print(L"%3.2x", Buffer[BdaOffset]);
      }
    }

    CursorPosition->column = 2;
    CursorPosition->row    = 0;
    gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition->column, CursorPosition->row);
    gST->ConOut->SetAttribute(gST->ConOut, EFI_WHITE | EFI_BACKGROUND_BLACK);
    Print(L"BDA");

    CursorPosition->column = 0;

    gST->ConOut->EnableCursor(gST->ConOut, FALSE);
    
    return;
  }

  VOID ReadEbda(POSITION *CursorPosition, UINT8 RecordBuffer[], UINT8 *RecordBufferTime)
  {
    EFI_CPU_IO2_PROTOCOL               *CpuIo2;
    UINT32                             EBdaSegment;
    UINT16                             ShiftToEbdaAddSegment;
    UINT16                             EbdaOffset;
    UINT8                              Buffer[Count];

    ShiftToEbdaAddSegment = 0x0e;
    EBdaSegment = 0;

    gBS->LocateProtocol (&gEfiCpuIo2ProtocolGuid, NULL, &CpuIo2);

    SetRegisterPageAppearance();
    ResetCursorPosition(CursorPosition);

    CpuIo2->Mem.Read(
                  CpuIo2,
                  EfiCpuIoWidthUint16,
                  BdaSegment + ShiftToEbdaAddSegment,
                  1,
                  &EBdaSegment
                  );

    EBdaSegment = EBdaSegment << 4;

    for (EbdaOffset = 0; EbdaOffset < Count; EbdaOffset++) {
      CpuIo2->Mem.Read(
                    CpuIo2,
                    EfiCpuIoWidthUint8,
                    EBdaSegment + EbdaOffset,
                    1,
                    &Buffer[EbdaOffset]
                    );

      if (*RecordBufferTime == 0) {
        *(RecordBuffer + EbdaOffset) = Buffer[EbdaOffset];
        JudgeFontColor(Buffer[EbdaOffset]);
      } else {
        if (*(RecordBuffer + EbdaOffset) != Buffer[EbdaOffset]) {
          *(RecordBuffer + EbdaOffset) = Buffer[EbdaOffset];
          gST->ConOut->SetAttribute(gST->ConOut, EFI_LIGHTGREEN | EFI_BACKGROUND_BLACK);
        } else {
          JudgeFontColor(Buffer[EbdaOffset]);
        }
      }

      if ((EbdaOffset % 16) == 0) {
        Print(L"%2.2x", Buffer[EbdaOffset]);
      } else if ((EbdaOffset % 16) == 15) {
        Print(L"%3.2x\n", Buffer[EbdaOffset]);
        CursorPosition->column = 5;
        CursorPosition->row++;
        gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition->column, CursorPosition->row);
      } else {
        Print(L"%3.2x", Buffer[EbdaOffset]);
      }
    }

    CursorPosition->column = 2;
    CursorPosition->row    = 0;
    gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition->column, CursorPosition->row);
    gST->ConOut->SetAttribute(gST->ConOut, EFI_WHITE | EFI_BACKGROUND_BLACK);
    Print(L"EBDA");

    CursorPosition->column = 1;

    gST->ConOut->EnableCursor(gST->ConOut, FALSE);

    return;
  }

  VOID SetRegisterPageAppearance(VOID)
  {
    gST->ConOut->ClearScreen(gST->ConOut);
    gST->ConOut->SetAttribute(gST->ConOut, EFI_WHITE | EFI_BACKGROUND_BLACK);

    Print(L"|                                                    |\n");
    Print(L"|====================================================|\n");
    Print(L"|  | 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F |\n");
    Print(L"|====================================================|\n");
    Print(L"|00|                                                 |\n");
    Print(L"|10|                                                 |\n");
    Print(L"|20|                                                 |\n");
    Print(L"|30|                                                 |\n");
    Print(L"|40|                                                 |\n");
    Print(L"|50|                                                 |\n");
    Print(L"|60|                                                 |\n");
    Print(L"|70|                                                 |\n");
    Print(L"|80|                                                 |\n");
    Print(L"|90|                                                 |\n");
    Print(L"|A0|                                                 |\n");
    Print(L"|B0|                                                 |\n");
    Print(L"|C0|                                                 |\n");
    Print(L"|D0|                                                 |\n");
    Print(L"|E0|                                                 |\n");
    Print(L"|F0|                                                 |\n");
    Print(L"|====================================================|\n");
    Print(L"| [F1]:Back     [F1]:renew     [Esc]:Escape          |\n");
    Print(L"|====================================================|\n");

    return;
  }

  VOID SetMainPageAppearance(VOID)
  {
    gST->ConOut->ClearScreen(gST->ConOut);
    gST->ConOut->SetAttribute(gST->ConOut, EFI_WHITE | EFI_BACKGROUND_BLACK);

    Print(L"|====================================================|\n");
    Print(L"|                                                    |\n");
    Print(L"|                   08-BDA_CMOS                      |\n");
    Print(L"|                                                    |\n");
    Print(L"|====================================================|\n");
    Print(L"|                       BDA                          |\n");
    Print(L"|                       EBDA                         |\n");
    Print(L"|                       CMOS                         |\n");
    Print(L"|====================================================|\n");
    Print(L"| [Arrow key] : Choose                               |\n");
    Print(L"| [F1] : Enter                                       |\n");
    Print(L"| [Esc] : Escape                                     |\n");
    Print(L"|====================================================|\n");

    return;
  }

  VOID ResetCursorPosition(POSITION *CursorPosition)
  {
    *CursorPosition = ResetPosition;
    gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition->column, CursorPosition->row);

    return;
  }

  VOID ShowMainPage(POSITION *CursorPosition)
  {
    SetMainPageAppearance();
    *CursorPosition = MainPage_ResetPosition;
    gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition->column, CursorPosition->row);
    gST->ConOut->EnableCursor(gST->ConOut, TRUE);

    return;
  }

  VOID JudgeFontColor(UINT8 Buffer)
  {
    if (Buffer > 0){
      gST->ConOut->SetAttribute(gST->ConOut, EFI_YELLOW | EFI_BACKGROUND_BLACK);
    } else {
      gST->ConOut->SetAttribute(gST->ConOut, EFI_LIGHTGRAY | EFI_BACKGROUND_BLACK);
    }
    return;
  }
*/

/*// MemoryUtility_09 finish(v1)
  #include <Uefi.h>
  #include <Library/UefiLib.h>
  #include <Library/UefiApplicationEntryPoint.h>
  #include <Library/UefiBootServicesTableLib.h>

  #define MAIN_PAGE_MODE   0
  #define BRANCH_PAGE_MODE 1
  #define GET_SIZE_MODE    2
  #define GET_ADDR_MODE    3
  #define WRITE_MODE       4
  #define SHOW_MODE        5
  #define ERROR_MODE       6

  typedef struct {
    INT16 column;         /// cursor column
    INT16 row;            /// cursor row
  } POSITION;

  typedef struct {
    UINT64    value;      /// write value
    POSITION  position;   /// cursor position
  } WRITE_BUFFER;

  VOID SetMainPageAppearance(VOID);
  VOID SetAllocateTypePageAppearance(VOID);
  VOID SetMemoryTypePageAppearance(VOID);  
  VOID SetGetSizePageAppearance(VOID); 
  VOID SetGetAddressPageAppearance(VOID);  
  VOID SetMemorySettingPageAppearance(VOID); 
  VOID SetRegisterPageAppearance(VOID);


  VOID ResetCursorPosition(POSITION *CursorPosition);
  VOID ShowMainPage(POSITION *CursorPosition);
  VOID JudgeFontColor(UINT8 Buffer);

  UINT64 Power (UINT64 Number, UINT64 Time);

  const POSITION  MainPage_ResetPosition           = {15, 5};
  const POSITION  AllocateTypePage_ResetPosition   = {15, 5};
  const POSITION  MemoryTypePage_ResetPosition     = {15, 5};
  const POSITION  MemorySettingPage_ResetPosition  = {5, 6};
  const POSITION  MemorySettingWrite_ResetPosition = {33, 6};
  const POSITION  RegistPage_ResetPosition         = {5, 4};
  const POSITION  ShowAddress_ResetPosition        = {2, 3};


  EFI_STATUS
  EFIAPI
  UefiMain (
    IN EFI_HANDLE ImageHandle, 
    IN EFI_SYSTEM_TABLE *SystemTable
    )
  {
    EFI_STATUS            Status;
    EFI_INPUT_KEY         InputKey;
    POSITION              CursorPosition;
    UINT8                 AllBranchPage;
    UINT8                 Mode;

    UINTN                 size;
    UINT8                 *Buffer;
    UINT64                Memory;
    UINT8 **TmpBuffer  = &Buffer;
        UINT64 **TmpMemory = (UINT64**)&Memory;
    
    // UINT8 *Buffer                = NULL; 

    UINT8                 EfiMemoryType;
    UINT8                 EfiAllocateType;
    BOOLEAN               Type;

    Mode                  = MAIN_PAGE_MODE;
    AllBranchPage         = 2;
    CursorPosition.column = 0;
    CursorPosition.row    = 0;

    size                  = 0;
    Buffer                = NULL;  
    Memory                = 0;
    EfiMemoryType         = 0;
    EfiAllocateType       = 0;
    Type                  = 0;
    // UINT8 **TmpBuffer = &Buffer;

    //
    // initialization and into the main page
    //
    gST->ConOut->ClearScreen(gST->ConOut);
    gST->ConOut->SetCursorPosition(gST->ConOut, 0, 0);
    gST->ConOut->EnableCursor(gST->ConOut, TRUE);
    ShowMainPage(&CursorPosition);
    
    //
    // choose mode loop
    //
    while (TRUE) {
      
      //
      // to change mode
      //
      ChangeMode:

      //
      // MAIN_PAGE_MODE
      // with up, down, F1, Esc key response
      //
      while (Mode == MAIN_PAGE_MODE) {
        gST->ConIn->ReadKeyStroke(gST->ConIn, &InputKey);

        if (InputKey.ScanCode == SCAN_ESC) {
          gST->ConOut->ClearScreen(gST->ConOut);
          goto Exit;
        }

        switch (InputKey.ScanCode) {

        case SCAN_UP:
          CursorPosition.row--;
          if (CursorPosition.row < MainPage_ResetPosition.row) {
            CursorPosition.row = MainPage_ResetPosition.row;
          }
          gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);    
          continue;

        case SCAN_DOWN:
          CursorPosition.row++;
          if (CursorPosition.row > (AllBranchPage + MainPage_ResetPosition.row - 1)) {
            CursorPosition.row = (AllBranchPage + MainPage_ResetPosition.row - 1);
          }
          gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);
          continue;

        case SCAN_F1:
          Mode = BRANCH_PAGE_MODE;

          if (CursorPosition.row == MainPage_ResetPosition.row) {
            Type = 1;
            SetAllocateTypePageAppearance();
            AllBranchPage = 3;
            CursorPosition = AllocateTypePage_ResetPosition;
            gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);
          } else if (CursorPosition.row == MainPage_ResetPosition.row + 1) {
            Type = 0;
            SetMemoryTypePageAppearance();
            AllBranchPage = 14;
            CursorPosition = MemoryTypePage_ResetPosition;
            gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);
          } 

          goto ChangeMode;
        }
      }

      //
      // BRANCH_PAGE_MODE
      // with F1, F2, Esc key response
      //
      while (Mode == BRANCH_PAGE_MODE) {
        gST->ConIn->ReadKeyStroke(gST->ConIn, &InputKey);

        if (InputKey.ScanCode == SCAN_ESC) {
          gST->ConOut->ClearScreen(gST->ConOut);
          goto Exit;
        }
        
        if (AllBranchPage == 3) {
          switch (InputKey.ScanCode) {

          case SCAN_UP:
            CursorPosition.row--;
            if (CursorPosition.row < AllocateTypePage_ResetPosition.row) {
              CursorPosition.row = AllocateTypePage_ResetPosition.row;
            }
            gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);    
            continue;

          case SCAN_DOWN:
            CursorPosition.row++;
            if (CursorPosition.row > (AllBranchPage + AllocateTypePage_ResetPosition.row - 1)) {
              CursorPosition.row = (AllBranchPage + AllocateTypePage_ResetPosition.row - 1);
            }
            gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);
            continue;

          case SCAN_F1:
            Mode = BRANCH_PAGE_MODE;

            if (CursorPosition.row == AllocateTypePage_ResetPosition.row) {
              SetMemoryTypePageAppearance();
              EfiAllocateType = AllocateAnyPages;
              AllBranchPage = 14;
              CursorPosition = MemoryTypePage_ResetPosition;
              gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);
            } else if (CursorPosition.row == AllocateTypePage_ResetPosition.row + 1) {
              SetMemoryTypePageAppearance();
              EfiAllocateType = AllocateMaxAddress;
              AllBranchPage = 14;
              CursorPosition = MemoryTypePage_ResetPosition;
              gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);
            } else if (CursorPosition.row == AllocateTypePage_ResetPosition.row + 2) {
              SetMemoryTypePageAppearance();
              EfiAllocateType = AllocateAddress;
              AllBranchPage = 14;
              CursorPosition = MemoryTypePage_ResetPosition;
              gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);
            } 

            goto ChangeMode;
          }
        } else if (AllBranchPage == 14) {
          switch (InputKey.ScanCode) {

          case SCAN_UP:
            CursorPosition.row--;
            if (CursorPosition.row < MemoryTypePage_ResetPosition.row) {
              CursorPosition.row = MemoryTypePage_ResetPosition.row;
            }
            gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);    
            continue;

          case SCAN_DOWN:
            CursorPosition.row++;
            if (CursorPosition.row > (AllBranchPage + MemoryTypePage_ResetPosition.row - 1)) {
              CursorPosition.row = (AllBranchPage + MemoryTypePage_ResetPosition.row - 1);
            }
            gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);
            continue;

          case SCAN_F1:
            if ((EfiAllocateType == AllocateAnyPages && Type == 1) || Type == 0) {
              SetGetSizePageAppearance();
              Mode = GET_SIZE_MODE;
              
            } else {
              SetGetAddressPageAppearance();
              Mode = GET_ADDR_MODE;
            }

            if (CursorPosition.row == MemoryTypePage_ResetPosition.row) {
              EfiMemoryType = EfiReservedMemoryType;
            } else if (CursorPosition.row == MemoryTypePage_ResetPosition.row + 1) {
              EfiMemoryType = EfiLoaderCode;
            } else if (CursorPosition.row == MemoryTypePage_ResetPosition.row + 2) {            
              EfiMemoryType = EfiLoaderData;          
            } else if (CursorPosition.row == MemoryTypePage_ResetPosition.row + 3) {            
              EfiMemoryType = EfiBootServicesCode;            
            } else if (CursorPosition.row == MemoryTypePage_ResetPosition.row + 4) {            
              EfiMemoryType = EfiBootServicesData;            
            } else if (CursorPosition.row == MemoryTypePage_ResetPosition.row + 5) {            
              EfiMemoryType = EfiRuntimeServicesCode;            
            } else if (CursorPosition.row == MemoryTypePage_ResetPosition.row + 6) {            
              EfiMemoryType = EfiRuntimeServicesData;            
            } else if (CursorPosition.row == MemoryTypePage_ResetPosition.row + 7) {            
              EfiMemoryType = EfiConventionalMemory;          
            } else if (CursorPosition.row == MemoryTypePage_ResetPosition.row + 8) {            
              EfiMemoryType = EfiUnusableMemory;            
            } else if (CursorPosition.row == MemoryTypePage_ResetPosition.row + 9) {            
              EfiMemoryType = EfiACPIReclaimMemory;            
            } else if (CursorPosition.row == MemoryTypePage_ResetPosition.row + 10) {            
              EfiMemoryType = EfiACPIMemoryNVS;            
            } else if (CursorPosition.row == MemoryTypePage_ResetPosition.row + 11) {            
              EfiMemoryType = EfiMemoryMappedIO;            
            } else if (CursorPosition.row == MemoryTypePage_ResetPosition.row + 12) {            
              EfiMemoryType = EfiMemoryMappedIOPortSpace;            
            } else if (CursorPosition.row == MemoryTypePage_ResetPosition.row + 13) {            
              EfiMemoryType = EfiPalCode;            
            }

            CursorPosition = MemorySettingWrite_ResetPosition;
            gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);

            goto ChangeMode;
          }
        }
        switch (InputKey.ScanCode) {
        
        case SCAN_F2:
          Mode = MAIN_PAGE_MODE; 
          AllBranchPage = 2;
          ShowMainPage(&CursorPosition);
          goto ChangeMode;
        }
      }

      //
      // GET_ADDR_MODE
      //
      if (Mode == GET_ADDR_MODE) {
        UINT8 WriteCount = 0;
        UINT8 WriteNum  = 16;
        UINT8 i;
        WRITE_BUFFER WriteBuffer[16];

        for (i = 0; i < WriteNum; i++) {
          WriteBuffer[i].value = 0;
          WriteBuffer[i].position = MemorySettingWrite_ResetPosition;
        }

        while (TRUE) {
          gST->ConIn->ReadKeyStroke(gST->ConIn, &InputKey);

          if (InputKey.ScanCode == SCAN_ESC) {
            gST->ConOut->ClearScreen(gST->ConOut);
            goto Exit;
          }
          
          if (WriteCount == WriteNum) {
            Mode = GET_SIZE_MODE;
            // Mode = ERROR_MODE;

            for (WriteCount = 0; WriteCount < WriteNum; WriteCount++) {
              Memory |= WriteBuffer[WriteCount].value << ((WriteNum-WriteCount-1) * 4);
            }

            if (Memory == 0) {
              Mode = GET_ADDR_MODE;
              goto ChangeMode;
            }

            SetGetSizePageAppearance();
            CursorPosition = MemorySettingWrite_ResetPosition;
            gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);

            goto ChangeMode;
          }

          if (('a' <= InputKey.UnicodeChar && InputKey.UnicodeChar <= 'f')) {
            WriteBuffer[WriteCount].value = (UINT8)InputKey.UnicodeChar - 87;
            WriteBuffer[WriteCount].position.column = CursorPosition.column;
            WriteBuffer[WriteCount].position.row = CursorPosition.row;
            Print(L"%c", InputKey.UnicodeChar);

            CursorPosition.column = CursorPosition.column + 1;
            gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);

            WriteCount++;
            continue;

          } else if (('0' <= InputKey.UnicodeChar && InputKey.UnicodeChar <= '9')) {
            WriteBuffer[WriteCount].value = InputKey.UnicodeChar - 48;
            WriteBuffer[WriteCount].position.column = CursorPosition.column;
            WriteBuffer[WriteCount].position.row = CursorPosition.row;
            Print(L"%c", InputKey.UnicodeChar);
        
            CursorPosition.column = CursorPosition.column + 1;
            gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);
            
            WriteCount++;
            continue;
          }
        }
      }

      //
      // GET_SIZE_MODE
      //
      if (Mode == GET_SIZE_MODE) {
        UINT8 WriteCount = 0;
        UINT8 WriteNum   = 4;
        UINT8 i;
        WRITE_BUFFER WriteBufferDecimal[4];

        for (i = 0; i < WriteNum; i++) {
          WriteBufferDecimal[i].value = 0;
          WriteBufferDecimal[i].position = MemorySettingWrite_ResetPosition;
        }

        while (TRUE) {
          gST->ConIn->ReadKeyStroke(gST->ConIn, &InputKey);

          if (InputKey.ScanCode == SCAN_ESC) {
            gST->ConOut->ClearScreen(gST->ConOut);
            goto Exit;
          }

          if (WriteCount == WriteNum) {
            Mode = WRITE_MODE;
            // Mode = ERROR_MODE;

            for (WriteCount = 0; WriteCount < WriteNum; WriteCount++) {
              size += WriteBufferDecimal[WriteCount].value * Power((UINT64)10, (UINT64)(WriteNum-WriteCount-1));            
            }

            if (size == 0) {
              Mode = GET_SIZE_MODE;
              goto ChangeMode;
            }

            if (Type == 0) {
              Status = gBS->AllocatePool(
                                      EfiMemoryType,
                                      size,
                                      &Buffer   // (VOID**)??
                                      );
              if (EFI_ERROR(Status)) {
                Mode = ERROR_MODE;
                gST->ConOut->ClearScreen(gST->ConOut);
                Print(L"%r,Please press F1.\n", Status);
                gST->ConOut->EnableCursor(gST->ConOut, FALSE);
                goto ChangeMode;
              }

            } else if (Type == 1) {
              Status = gBS->AllocatePages(
                                      EfiAllocateType,
                                      EfiMemoryType,
                                      size,
                                      &Memory
                                      );
              if (EFI_ERROR(Status)) {
                Mode = ERROR_MODE;
                gST->ConOut->ClearScreen(gST->ConOut);
                Print(L"%r,Please press F1.\n", Status);
                gST->ConOut->EnableCursor(gST->ConOut, FALSE);
                goto ChangeMode;
              }
            }

            SetMemorySettingPageAppearance();
            gST->ConOut->EnableCursor(gST->ConOut, FALSE);

            CursorPosition = ShowAddress_ResetPosition;
            gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);

            if (Type == 0) {
              Print(L"Address:0x%.8x ~ 0x%.8x", Buffer, Buffer + size);
            } else if (Type == 1) {
              Print(L"Address:0x%.8x ~ 0x%.8x", Memory, Memory + (size * 4096));
            }  

            goto ChangeMode;
          }
          
          if (('0' <= InputKey.UnicodeChar && InputKey.UnicodeChar <= '9')) {
            WriteBufferDecimal[WriteCount].value = InputKey.UnicodeChar - 48;
            WriteBufferDecimal[WriteCount].position.column = CursorPosition.column;
            WriteBufferDecimal[WriteCount].position.row = CursorPosition.row;
            Print(L"%c", InputKey.UnicodeChar);
      
            CursorPosition.column = CursorPosition.column + 1;
            gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);
            
            WriteCount++;
            
            continue;
          }

        }
      }

      //
      // WRITE_MODE
      //
      if (Mode == WRITE_MODE) {
        UINT8 LineCount    = 0;
        UINT8 WriteCount   = 0;
        UINT16 WriteNum    = 0;
        UINT64 Address     = 0;
        UINT8  Value       = 0;
        UINT64 **TmpAddress = (UINT64**)&Address;

        UINT16 i;
        BOOLEAN IsWriting = FALSE;
        BOOLEAN AddressOrValue = 0;   // 0->next write addr
        BOOLEAN SetOrReset = 0;       // 0->is set
        WRITE_BUFFER WriteBuffer[16];

        for (i = 0; i < 16; i++) {
          WriteBuffer[i].value = 0;
          WriteBuffer[i].position = MemorySettingWrite_ResetPosition;
        }

        while (TRUE) {
          while (IsWriting == FALSE) {
            if (AddressOrValue == 1) {  // 1 -> value

              IsWriting = !IsWriting;
              WriteNum = 2;
              
              if (LineCount == 13) {
                SetMemorySettingPageAppearance();
                gST->ConOut->EnableCursor(gST->ConOut, FALSE);
                LineCount = 0;
              }
              
              CursorPosition = MemorySettingPage_ResetPosition;
              CursorPosition.row = CursorPosition.row + LineCount;
              gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);
              Print(L"(1Byte) Set   value  with 0xXX");
              CursorPosition = MemorySettingWrite_ResetPosition;
              CursorPosition.row = CursorPosition.row + LineCount;
              gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);
              gST->ConOut->EnableCursor(gST->ConOut, TRUE);

              LineCount++;
              AddressOrValue = !AddressOrValue;

              break;
            }

            gST->ConIn->ReadKeyStroke(gST->ConIn, &InputKey);

            if (InputKey.ScanCode == SCAN_ESC) {
              gBS->FreePages(
                          Memory,
                          size
                          );
              gBS->FreePool(Buffer);
              gST->ConOut->ClearScreen(gST->ConOut);
              goto Exit;
            }

            switch (InputKey.ScanCode) {

            case SCAN_F1:
              SetOrReset = 0;
              IsWriting = !IsWriting;
              
              if (LineCount == 13) {
                SetMemorySettingPageAppearance();
                gST->ConOut->EnableCursor(gST->ConOut, FALSE);
                LineCount = 0;
              }          
              
              CursorPosition = MemorySettingPage_ResetPosition;
              CursorPosition.row = CursorPosition.row + LineCount;
              gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);

              WriteNum = 16;
              Print(L"(64bit) Set  address with 0xXXXXXXXXXXXXXXXX");  

              CursorPosition = MemorySettingWrite_ResetPosition;
              CursorPosition.row = CursorPosition.row + LineCount;
              gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);
              gST->ConOut->EnableCursor(gST->ConOut, TRUE);

              LineCount++;
              AddressOrValue = !AddressOrValue;
        
              break;

            case SCAN_F2:
              SetOrReset = 1;
              IsWriting = !IsWriting;
              WriteNum = 2;
              if (LineCount == 13) {
                SetMemorySettingPageAppearance();
                gST->ConOut->EnableCursor(gST->ConOut, FALSE);
                LineCount = 0;
              }
              CursorPosition = MemorySettingPage_ResetPosition;
              CursorPosition.row = CursorPosition.row + LineCount;
              gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);
              Print(L"(1Byte) Reset memory with 0xXX");
              CursorPosition = MemorySettingWrite_ResetPosition;
              CursorPosition.row = CursorPosition.row + LineCount;
              gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);
              gST->ConOut->EnableCursor(gST->ConOut, TRUE);
              LineCount++;
              break;

            case SCAN_F3:
              SetMemorySettingPageAppearance();
              gST->ConOut->EnableCursor(gST->ConOut, FALSE);
              LineCount = 0;
              
              continue;

            case SCAN_F4:
              Mode = SHOW_MODE;

              SetRegisterPageAppearance();
              CursorPosition = RegistPage_ResetPosition;
              gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);
              gST->ConOut->EnableCursor(gST->ConOut, FALSE);

              if (Type == 0) {
                for (i = 0; i < 256; i++) {
                  if ((i % 16) == 0) {
                    Print(L"%2.2x", *(Buffer + i));
                  } else if ((i % 16) == 15) {
                    Print(L"%3.2x", *(Buffer + i));
                    CursorPosition.column = RegistPage_ResetPosition.column;
                    CursorPosition.row++;
                    gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);
                  } else {
                    Print(L"%3.2x", *(Buffer + i));
                  }
                }
              } else if (Type == 1) {
                for (i = 0; i < 256; i++) {
                  if ((i % 16) == 0) {
                    Print(L"%2.2x", *(UINT8*)(*TmpMemory + i));
                  } else if ((i % 16) == 15) {
                    Print(L"%3.2x", *(UINT8*)(*TmpMemory + i));
                    CursorPosition.column = RegistPage_ResetPosition.column;
                    CursorPosition.row++;
                    gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);
                  } else {
                    Print(L"%3.2x", *(UINT8*)(*TmpMemory + i));
                  }
                }
              }

              goto ChangeMode;
            }
            
          }

          while (IsWriting == TRUE) {
            gST->ConIn->ReadKeyStroke(gST->ConIn, &InputKey);

            if (InputKey.ScanCode == SCAN_ESC) {
              gBS->FreePages(
                          Memory,
                          size
                          );
              gBS->FreePool(Buffer);
              gST->ConOut->ClearScreen(gST->ConOut);
              goto Exit;
            }

            if (WriteCount == WriteNum) {

              if (SetOrReset == 0 && AddressOrValue == 1) { // 1->next write value
                
                // prepare addr
                for (WriteCount = 0; WriteCount < WriteNum; WriteCount++) {
                  Address |= WriteBuffer[WriteCount].value << ((WriteNum-WriteCount-1) * 4);
                }
                
                // judge addr illigle mark:
                if(Address < *((UINT64*)TmpBuffer) || Address > (*((UINT64*)TmpBuffer) + size)) {
                  CursorPosition =  MemorySettingPage_ResetPosition;
                  gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);
                  Print(L"Invalid range! Please set again.");

                  Mode = WRITE_MODE;

                  goto ChangeMode;
                }

              } else if (SetOrReset == 0 && AddressOrValue == 0) {
                // prepare value
                for (WriteCount = 0; WriteCount < WriteNum; WriteCount++) {
                  Value |= WriteBuffer[WriteCount].value << ((WriteNum-WriteCount-1) * 4);
                }            

                gBS->SetMem(
                        *((UINT8**)TmpAddress),
                        1,
                        Value
                        );
              
              } else if (SetOrReset == 1) {  // 1->is reset
                // prepare value
                for (WriteCount = 0; WriteCount < WriteNum; WriteCount++) {
                  Value |= WriteBuffer[WriteCount].value << ((WriteNum-WriteCount-1) * 4);
                }              
                
                if (Type == 0) {
                  gBS->SetMem(
                        Buffer,
                        size,
                        Value
                        );
                } else if (Type == 1) {
                  for (i = 0; i < 4096 * size; i++) {
                    gBS->SetMem(
                            *TmpMemory + i,
                            1,
                            Value
                            );
                  }
                  
                }
              }
              
              Value = 0;
              WriteCount = 0;
              for (i = 0; i < 16; i++) {
                WriteBuffer[i].value = 0;
                WriteBuffer[i].position = MemorySettingWrite_ResetPosition;
              }
              IsWriting = !IsWriting;
              break;
            }

            if (('a' <= InputKey.UnicodeChar && InputKey.UnicodeChar <= 'f')) {
              WriteBuffer[WriteCount].value = (UINT8)InputKey.UnicodeChar - 87;
              WriteBuffer[WriteCount].position.column = CursorPosition.column;
              WriteBuffer[WriteCount].position.row = CursorPosition.row;
              Print(L"%c", InputKey.UnicodeChar);

              CursorPosition.column = CursorPosition.column + 1;
              gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);
              WriteCount++;
              continue;

            } else if (('0' <= InputKey.UnicodeChar && InputKey.UnicodeChar <= '9')) {
              WriteBuffer[WriteCount].value = InputKey.UnicodeChar - 48;
              WriteBuffer[WriteCount].position.column = CursorPosition.column;
              WriteBuffer[WriteCount].position.row = CursorPosition.row;
              Print(L"%c", InputKey.UnicodeChar);
              
              CursorPosition.column = CursorPosition.column + 1;
              gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);
              WriteCount++;
              
              continue;
            }
          }
        }
        
      }
      
      //
      // SHOW_MODE
      // 
      if (Mode == SHOW_MODE) {
        UINT64 Page = 0;
        UINT64 i;
        while (TRUE)  {
          gST->ConIn->ReadKeyStroke(gST->ConIn, &InputKey);

          if (InputKey.ScanCode == SCAN_ESC) {
            gBS->FreePages(
                        Memory,
                        size
                        );
            gBS->FreePool(Buffer);
            gST->ConOut->ClearScreen(gST->ConOut);
            goto Exit;
          }

          switch (InputKey.ScanCode) {

          case SCAN_UP:
            Page--;

            SetRegisterPageAppearance();
              CursorPosition = RegistPage_ResetPosition;
              gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);
              gST->ConOut->EnableCursor(gST->ConOut, FALSE);

              if (Type == 0) {
                for (i = 0 + Page * 256; i < Page * 256 + 256; i++) {
                  if ((i % 16) == 0) {
                    Print(L"%2.2x", *(Buffer + i));
                  } else if ((i % 16) == 15) {
                    Print(L"%3.2x", *(Buffer + i));
                    CursorPosition.column = RegistPage_ResetPosition.column;
                    CursorPosition.row++;
                    gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);
                  } else {
                    Print(L"%3.2x", *(Buffer + i));
                  }
                }
              } else if (Type == 1) {
                for (i = 0 + Page * 256; i < Page * 256 + 256; i++) {
                  if ((i % 16) == 0) {
                    Print(L"%2.2x", *(UINT8*)(*TmpMemory + i));
                  } else if ((i % 16) == 15) {
                    Print(L"%3.2x", *(UINT8*)(*TmpMemory + i));
                    CursorPosition.column = RegistPage_ResetPosition.column;
                    CursorPosition.row++;
                    gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);
                  } else {
                    Print(L"%3.2x", *(UINT8*)(*TmpMemory + i));
                  }
                }
              }
                
            continue;

          case SCAN_DOWN:
            Page++;

            SetRegisterPageAppearance();
              CursorPosition = RegistPage_ResetPosition;
              gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);
              gST->ConOut->EnableCursor(gST->ConOut, FALSE);

              if (Type == 0) {
                for (i = 0 + Page * 256; i < Page * 256 + 256; i++) {
                  if ((i % 16) == 0) {
                    Print(L"%2.2x", *(Buffer + i));
                  } else if ((i % 16) == 15) {
                    Print(L"%3.2x", *(Buffer + i));
                    CursorPosition.column = RegistPage_ResetPosition.column;
                    CursorPosition.row++;
                    gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);
                  } else {
                    Print(L"%3.2x", *(Buffer + i));
                  }
                }
              } else if (Type == 1) {
                for (i = 0 + Page * 256; i < Page * 256 + 256; i++) {
                  if ((i % 16) == 0) {
                    Print(L"%2.2x", *(UINT8*)(*TmpMemory + i)); // (UINT8*)
                  } else if ((i % 16) == 15) {
                    Print(L"%3.2x", *(UINT8*)(*TmpMemory + i));
                    CursorPosition.column = RegistPage_ResetPosition.column;
                    CursorPosition.row++;
                    gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);
                  } else {
                    Print(L"%3.2x", *(UINT8*)(*TmpMemory + i));
                  }
                }
              }
            continue;

          case SCAN_F1:
            Mode = MAIN_PAGE_MODE;
            gBS->FreePages(
                        Memory,
                        size
                        );
            gBS->FreePool(Buffer); 
            AllBranchPage = 2;
            size = 0;
            ShowMainPage(&CursorPosition);
            gST->ConOut->EnableCursor(gST->ConOut, TRUE);
            goto ChangeMode;

          case SCAN_F2:
            Mode = WRITE_MODE;
            SetMemorySettingPageAppearance();
            gST->ConOut->EnableCursor(gST->ConOut, FALSE);

            CursorPosition = ShowAddress_ResetPosition;
            gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);

            if (Type == 0) {
              Print(L"Address:0x%.8x ~ 0x%.8x", Buffer, Buffer + size);
            } else if (Type == 1) {
              Print(L"Address:0x%.8x ~ 0x%.8x", Memory, Memory + (size * 4096));
            }  
            goto ChangeMode;
          }
        }
      }
      

      //
      // ERROR_MODE
      //
      while (Mode == ERROR_MODE) {
        gST->ConIn->ReadKeyStroke(gST->ConIn, &InputKey);

        switch (InputKey.ScanCode) {
        
        case SCAN_F1:
          Mode = MAIN_PAGE_MODE;
          gBS->FreePages(
                      Memory,
                      size
                      );
          gBS->FreePool(Buffer); 
          AllBranchPage = 2;
          size = 0;
          ShowMainPage(&CursorPosition);
          gST->ConOut->EnableCursor(gST->ConOut, TRUE);
          goto ChangeMode;

        // case SCAN_F2:
        //   gST->ConOut->ClearScreen(gST->ConOut);

        //   Print(L"Type            ->%d\n", Type);
        //   Print(L"EfiAllocateType ->%d\n", EfiAllocateType);
        //   Print(L"EfiMemoryType   ->%d\n", EfiMemoryType);
        //   Print(L"size            ->%d\n", size);
        //   Print(L"Buffer(0)       ->%p\n", Buffer);
        //   Print(L"Memory(1)       ->%p", Memory);

        // continue;
        }
      }
    }

    

    // for (EfiMemoryType = 0; EfiMemoryType < EfiMaxMemoryType; EfiMemoryType++) {
    //   Print(L"Type\t->%x\n", EfiMemoryType);

    //   Buf = NULL;
    //   Status = gBS->AllocatePool(
    //                  EfiMemoryType,
    //                  BufferSize,
    //                  &Buf
    //                  );

    //   if (EFI_ERROR(Status)) {
    //     gST->ConOut->ClearScreen(gST->ConOut);
    //     Print(L"%r\n", Status);
    //     gST->ConOut->EnableCursor(gST->ConOut, FALSE);
    //     continue;
    //   }

    //   gBS->SetMem(
    //            Buf,
    //            1,
    //            0xff
    //            );

    //   Print(L"Buf\t->%x\n", Buf);
    //   Print(L"*Buf\t->%x\n", *Buf);
      
    //   gBS->FreePool(Buf); 
    // }

    //
    // to get out
    //
    Exit:

    Status = EFI_SUCCESS;

    return Status;
  }

  VOID 
  SetMainPageAppearance (
    VOID
    )
  {
    gST->ConOut->ClearScreen(gST->ConOut);
    gST->ConOut->SetAttribute(gST->ConOut, EFI_WHITE | EFI_BACKGROUND_BLACK);

    Print(L"|====================================================|\n");
    Print(L"|                                                    |\n");
    Print(L"|                  12-Memory_utility                 |\n");
    Print(L"|                                                    |\n");
    Print(L"|====================================================|\n");
    Print(L"|              Allocate Memory By Page               |\n");
    Print(L"|              Allocate Memory By Pool               |\n");
    Print(L"|====================================================|\n");
    Print(L"| [Arrow key] : Choose                               |\n");
    Print(L"| [F1] : Enter                                       |\n");
    Print(L"| [Esc] : Escape                                     |\n");
    Print(L"|====================================================|\n");

    return;
  }

  VOID 
  SetAllocateTypePageAppearance (
    VOID
    )
  {
    gST->ConOut->ClearScreen(gST->ConOut);
    gST->ConOut->SetAttribute(gST->ConOut, EFI_WHITE | EFI_BACKGROUND_BLACK);

    Print(L"|====================================================|\n");
    Print(L"|                                                    |\n");
    Print(L"|                   Allocate Type                    |\n");
    Print(L"|                                                    |\n");
    Print(L"|====================================================|\n");
    Print(L"|              Allocate Any Pages                    |\n");
    Print(L"|              Allocate Max Address                  |\n");
    Print(L"|              Allocate Address                      |\n");
    Print(L"|====================================================|\n");
    Print(L"| [Arrow key] : Choose     [Esc] : Escape            |\n");
    Print(L"| [F1] : Enter             [F2] : Home               |\n");
    Print(L"|====================================================|\n");

    return;
  }

  VOID 
  SetMemoryTypePageAppearance (
    VOID
    )
  {
    gST->ConOut->ClearScreen(gST->ConOut);
    gST->ConOut->SetAttribute(gST->ConOut, EFI_WHITE | EFI_BACKGROUND_BLACK);

    Print(L"|====================================================|\n");
    Print(L"|                                                    |\n");
    Print(L"|                    Memory Type                     |\n");
    Print(L"|                                                    |\n");
    Print(L"|====================================================|\n");
    Print(L"|              Reserved Memory                       |\n");
    Print(L"|              Loader Code                           |\n");
    Print(L"|              Loader Data                           |\n");
    Print(L"|              Boot Service Code                     |\n");
    Print(L"|              Boot Service Data                     |\n");
    Print(L"|              Runtime Service Code                  |\n");
    Print(L"|              Runtime Service Data                  |\n");
    Print(L"|              Conventional Memory                   |\n");
    Print(L"|              Unusable Memory                       |\n");
    Print(L"|              ACPI Reclaim Memory                   |\n");
    Print(L"|              ACPI NVS Memory                       |\n");
    Print(L"|              Memory Mapped IO                      |\n");
    Print(L"|              Memory Mapped IO Port Space           |\n");
    Print(L"|              PAL Code                              |\n");
    Print(L"|====================================================|\n");
    Print(L"| [Arrow key] : Choose     [Esc] : Escape            |\n");
    Print(L"| [F1] : Enter             [F2] : Home               |\n");
    Print(L"|====================================================|\n");

    return;
  }

  VOID 
  SetGetSizePageAppearance (
    VOID
    )
  {
    gST->ConOut->ClearScreen(gST->ConOut);
    gST->ConOut->SetAttribute(gST->ConOut, EFI_WHITE | EFI_BACKGROUND_BLACK);

    Print(L"|====================================================|\n");
    Print(L"|                                                    |\n");
    Print(L"|                     Get Size                       |\n");
    Print(L"|                                                    |\n");
    Print(L"|====================================================|\n");
    Print(L"|              Please set size.                      |\n");
    Print(L"|              Set  size  with   XXXX                |\n");
    Print(L"|                                                    |\n");
    Print(L"|====================================================|\n");
    Print(L"| [Num]:Number                                       |\n");
    Print(L"| [Esc]:Escape                                       |\n");
    Print(L"|====================================================|\n");

    return;
  }

  VOID 
  SetGetAddressPageAppearance (
    VOID
    )
  {
    gST->ConOut->ClearScreen(gST->ConOut);
    gST->ConOut->SetAttribute(gST->ConOut, EFI_WHITE | EFI_BACKGROUND_BLACK);

    Print(L"|====================================================|\n");
    Print(L"|                                                    |\n");
    Print(L"|                     Get Address                    |\n");
    Print(L"|                                                    |\n");
    Print(L"|====================================================|\n");
    Print(L"|            Please set address.                     |\n");
    Print(L"|            Set  address with 0xXXXXXXXXXXXXXXXX    |\n");
    Print(L"|                                                    |\n");
    Print(L"|====================================================|\n");
    Print(L"| [Num]:Number                                       |\n");
    Print(L"| [Esc]:Escape                                       |\n");
    Print(L"|====================================================|\n");

    return;
  }

  VOID 
  SetMemorySettingPageAppearance (
    VOID
    )
  {
    gST->ConOut->ClearScreen(gST->ConOut);
    gST->ConOut->SetAttribute(gST->ConOut, EFI_WHITE | EFI_BACKGROUND_BLACK);

    Print(L"|====================================================|\n");
    Print(L"|                                                    |\n");
    Print(L"|                  Memory Setting                    |\n");
    Print(L"|                                                    |\n");
    Print(L"|====================================================|\n");
    Print(L"|           Please press button to modify.           |\n");
    Print(L"|                                                    |\n");
    Print(L"|                                                    |\n");
    Print(L"|                                                    |\n");
    Print(L"|                                                    |\n");
    Print(L"|                                                    |\n");
    Print(L"|                                                    |\n");
    Print(L"|                                                    |\n");
    Print(L"|                                                    |\n");
    Print(L"|                                                    |\n");
    Print(L"|                                                    |\n");
    Print(L"|                                                    |\n");
    Print(L"|                                                    |\n");
    Print(L"|                                                    |\n");
    Print(L"|====================================================|\n");
    Print(L"| [F1]:Set       [F2]:Reset     [F3]:Clean Screen    |\n");
    Print(L"| [F4]:Show      [Esc]:Escape                        |\n");
    Print(L"|====================================================|\n");

    return;
  }


  VOID 
  SetRegisterPageAppearance (
    VOID
    )
  {
    gST->ConOut->ClearScreen(gST->ConOut);
    gST->ConOut->SetAttribute(gST->ConOut, EFI_WHITE | EFI_BACKGROUND_BLACK);

    Print(L"|                                                    |\n");
    Print(L"|====================================================|\n");
    Print(L"|  | 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F |\n");
    Print(L"|====================================================|\n");
    Print(L"|00|                                                 |\n");
    Print(L"|10|                                                 |\n");
    Print(L"|20|                                                 |\n");
    Print(L"|30|                                                 |\n");
    Print(L"|40|                                                 |\n");
    Print(L"|50|                                                 |\n");
    Print(L"|60|                                                 |\n");
    Print(L"|70|                                                 |\n");
    Print(L"|80|                                                 |\n");
    Print(L"|90|                                                 |\n");
    Print(L"|A0|                                                 |\n");
    Print(L"|B0|                                                 |\n");
    Print(L"|C0|                                                 |\n");
    Print(L"|D0|                                                 |\n");
    Print(L"|E0|                                                 |\n");
    Print(L"|F0|                                                 |\n");
    Print(L"|====================================================|\n");
    Print(L"| [Arrow key]:Choose   [Esc]:Escape   [F1]:Home      |\n");
    Print(L"|====================================================|\n");

    return;
  }

  VOID 
  ShowMainPage (
    POSITION *CursorPosition
    )
  {
    SetMainPageAppearance();
    *CursorPosition = MainPage_ResetPosition;
    gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition->column, CursorPosition->row);
    gST->ConOut->EnableCursor(gST->ConOut, TRUE);

    return;
  }

  UINT64 Power (UINT64 Number, UINT64 Time)
  {  
    if (Time == 0) {
      return 1;
    } else {
      return (Number * Power(Number, Time-1));
    }
  }
*/

/*// MemoryUtility_09 finish(v2)
  #include <Uefi.h>
  #include <Library/UefiLib.h>
  #include <Library/UefiApplicationEntryPoint.h>
  #include <Library/UefiBootServicesTableLib.h>

  #define MAIN_PAGE_MODE   0
  #define BRANCH_PAGE_MODE 1
  #define GET_SIZE_MODE    2
  #define GET_ADDR_MODE    3
  #define WRITE_MODE       4
  #define SHOW_MODE        5
  #define ERROR_MODE       6

  typedef struct {
    INT16 column;         /// cursor column
    INT16 row;            /// cursor row
  } POSITION;

  typedef struct {
    UINT64    value;      /// write value
    POSITION  position;   /// cursor position
  } WRITE_BUFFER;

  typedef enum {
    POOL,
    PAGE
  } ALLOCATE_TYPE;

  typedef enum {
    MAIN_PAGE_NUM     = 2,
    ALLOCATE_TYPE_NUM = 3,
    MEMORY_TYPE_NUM   = 14
  } BRANCH_PAGE_NUM;

  VOID 
  SetMainPageAppearance (
    VOID
    );

  VOID 
  SetAllocateTypePageAppearance (
    VOID
    );

  VOID 
  SetMemoryTypePageAppearance (
    VOID
    );

  VOID 
  SetGetAddressPageAppearance (
    VOID
    );  

  VOID 
  SetGetSizePageAppearance (
    VOID
    ); 

  VOID 
  SetMemorySettingPageAppearance (
    VOID
    ); 

  VOID 
  SetRegisterPageAppearance (
    VOID
    );

  VOID 
  ShowMainPage (
    POSITION *CursorPosition
    );

  UINT64 
  Power (
    UINT64 Base, 
    UINT64 Index
    );

  const POSITION  MainPage_ResetPosition                  = {15, 5};
  const POSITION  AllocateTypePage_ResetPosition          = {15, 5};
  const POSITION  MemoryTypePage_ResetPosition            = {15, 5};
  const POSITION  MemorySettingPage_ResetPosition         = {5, 6};
  const POSITION  MemorySettingWrite_ResetPosition        = {33, 6};
  const POSITION  RegistPage_ResetPosition                = {5, 4};
  const POSITION  ShowAddressAtSettingPage_ResetPosition  = {2, 3};
  const POSITION  ShowAddressAtRegisterPage_ResetPosition = {2, 0};

  EFI_STATUS
  EFIAPI
  UefiMain (
    IN EFI_HANDLE ImageHandle, 
    IN EFI_SYSTEM_TABLE *SystemTable
    )
  {
    EFI_STATUS            Status;
    EFI_INPUT_KEY         InputKey;
    POSITION              CursorPosition;
    UINT8                 Mode;
    BRANCH_PAGE_NUM       AllBranchPage;

    ALLOCATE_TYPE         Type;
    EFI_ALLOCATE_TYPE     EfiAllocateType;
    EFI_MEMORY_TYPE       EfiMemoryType;
    UINTN                 size;
    UINT8                 *Buffer;
    UINT64                Memory;
    UINT8                 **TmpBuffer;
    UINT64                **TmpMemory;

    Mode                  = MAIN_PAGE_MODE;
    AllBranchPage         = MAIN_PAGE_NUM;
    CursorPosition.column = 0;
    CursorPosition.row    = 0;

    Type                  = 0;
    EfiAllocateType       = 0;
    EfiMemoryType         = 0;
    size                  = 0;
    Buffer                = NULL;  
    Memory                = 0;
    TmpBuffer = &Buffer;
    TmpMemory = (UINT64**)&Memory;

    //
    // initialization and into the main page
    //
    gST->ConOut->ClearScreen(gST->ConOut);
    gST->ConOut->SetCursorPosition(gST->ConOut, 0, 0);
    gST->ConOut->EnableCursor(gST->ConOut, TRUE);
    ShowMainPage(&CursorPosition);
    
    //
    // choose mode loop
    //
    while (TRUE) {
      
      //
      // to change mode
      //
      ChangeMode:

      //
      // MAIN_PAGE_MODE
      // with up, down, F1(enter), Esc key response
      //
      while (Mode == MAIN_PAGE_MODE) {
        gST->ConIn->ReadKeyStroke(gST->ConIn, &InputKey);

        if (InputKey.ScanCode == SCAN_ESC) {
          gST->ConOut->ClearScreen(gST->ConOut);
          goto Exit;
        }

        switch (InputKey.ScanCode) {

        case SCAN_UP:
          CursorPosition.row--;
          if (CursorPosition.row < MainPage_ResetPosition.row) {
            CursorPosition.row = MainPage_ResetPosition.row;
          }
          gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);    
          continue;

        case SCAN_DOWN:
          CursorPosition.row++;
          if (CursorPosition.row > (AllBranchPage + MainPage_ResetPosition.row - 1)) {
            CursorPosition.row = (UINT16)(AllBranchPage + MainPage_ResetPosition.row - 1);
          }
          gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);
          continue;

        case SCAN_F1:
          Mode = BRANCH_PAGE_MODE;

          if (CursorPosition.row == MainPage_ResetPosition.row) {
            Type = PAGE;
            SetAllocateTypePageAppearance();
            AllBranchPage = ALLOCATE_TYPE_NUM;
            CursorPosition = AllocateTypePage_ResetPosition;
            gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);
          } else if (CursorPosition.row == MainPage_ResetPosition.row + 1) {
            Type = POOL;
            SetMemoryTypePageAppearance();
            AllBranchPage = MEMORY_TYPE_NUM;
            CursorPosition = MemoryTypePage_ResetPosition;
            gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);
          } 

          goto ChangeMode;
        }
      }

      //
      // BRANCH_PAGE_MODE
      // with up, down, F1(enter), F2(home), Esc key response
      //
      while (Mode == BRANCH_PAGE_MODE) {
        gST->ConIn->ReadKeyStroke(gST->ConIn, &InputKey);

        if (InputKey.ScanCode == SCAN_ESC) {
          gST->ConOut->ClearScreen(gST->ConOut);
          goto Exit;
        }
        
        if (AllBranchPage == ALLOCATE_TYPE_NUM) {
          switch (InputKey.ScanCode) {

          case SCAN_UP:
            CursorPosition.row--;
            if (CursorPosition.row < AllocateTypePage_ResetPosition.row) {
              CursorPosition.row = AllocateTypePage_ResetPosition.row;
            }
            gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);    
            continue;

          case SCAN_DOWN:
            CursorPosition.row++;
            if (CursorPosition.row > (AllBranchPage + AllocateTypePage_ResetPosition.row - 1)) {
              CursorPosition.row = (UINT16)(AllBranchPage + AllocateTypePage_ResetPosition.row - 1);
            }
            gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);
            continue;

          case SCAN_F1:
            Mode = BRANCH_PAGE_MODE;

            if (CursorPosition.row == AllocateTypePage_ResetPosition.row) {
              SetMemoryTypePageAppearance();
              EfiAllocateType = AllocateAnyPages;
              AllBranchPage = MEMORY_TYPE_NUM;
              CursorPosition = MemoryTypePage_ResetPosition;
              gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);
            } else if (CursorPosition.row == AllocateTypePage_ResetPosition.row + 1) {
              SetMemoryTypePageAppearance();
              EfiAllocateType = AllocateMaxAddress;
              AllBranchPage = MEMORY_TYPE_NUM;
              CursorPosition = MemoryTypePage_ResetPosition;
              gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);
            } else if (CursorPosition.row == AllocateTypePage_ResetPosition.row + 2) {
              SetMemoryTypePageAppearance();
              EfiAllocateType = AllocateAddress;
              AllBranchPage = MEMORY_TYPE_NUM;
              CursorPosition = MemoryTypePage_ResetPosition;
              gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);
            } 

            goto ChangeMode;
          }
        } else if (AllBranchPage == MEMORY_TYPE_NUM) {
          switch (InputKey.ScanCode) {

          case SCAN_UP:
            CursorPosition.row--;
            if (CursorPosition.row < MemoryTypePage_ResetPosition.row) {
              CursorPosition.row = MemoryTypePage_ResetPosition.row;
            }
            gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);    
            continue;

          case SCAN_DOWN:
            CursorPosition.row++;
            if (CursorPosition.row > (AllBranchPage + MemoryTypePage_ResetPosition.row - 1)) {
              CursorPosition.row = (UINT16)(AllBranchPage + MemoryTypePage_ResetPosition.row - 1);
            }
            gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);
            continue;

          case SCAN_F1:
            if ((EfiAllocateType == AllocateAnyPages && Type == PAGE) || Type == POOL) {
              SetGetSizePageAppearance();
              Mode = GET_SIZE_MODE;
              
            } else {
              SetGetAddressPageAppearance();
              Mode = GET_ADDR_MODE;
            }

            if (CursorPosition.row == MemoryTypePage_ResetPosition.row) {
              EfiMemoryType = EfiReservedMemoryType;
            } else if (CursorPosition.row == MemoryTypePage_ResetPosition.row + 1) {
              EfiMemoryType = EfiLoaderCode;
            } else if (CursorPosition.row == MemoryTypePage_ResetPosition.row + 2) {            
              EfiMemoryType = EfiLoaderData;          
            } else if (CursorPosition.row == MemoryTypePage_ResetPosition.row + 3) {            
              EfiMemoryType = EfiBootServicesCode;            
            } else if (CursorPosition.row == MemoryTypePage_ResetPosition.row + 4) {            
              EfiMemoryType = EfiBootServicesData;            
            } else if (CursorPosition.row == MemoryTypePage_ResetPosition.row + 5) {            
              EfiMemoryType = EfiRuntimeServicesCode;            
            } else if (CursorPosition.row == MemoryTypePage_ResetPosition.row + 6) {            
              EfiMemoryType = EfiRuntimeServicesData;            
            } else if (CursorPosition.row == MemoryTypePage_ResetPosition.row + 7) {            
              EfiMemoryType = EfiConventionalMemory;          
            } else if (CursorPosition.row == MemoryTypePage_ResetPosition.row + 8) {            
              EfiMemoryType = EfiUnusableMemory;            
            } else if (CursorPosition.row == MemoryTypePage_ResetPosition.row + 9) {            
              EfiMemoryType = EfiACPIReclaimMemory;            
            } else if (CursorPosition.row == MemoryTypePage_ResetPosition.row + 10) {            
              EfiMemoryType = EfiACPIMemoryNVS;            
            } else if (CursorPosition.row == MemoryTypePage_ResetPosition.row + 11) {            
              EfiMemoryType = EfiMemoryMappedIO;            
            } else if (CursorPosition.row == MemoryTypePage_ResetPosition.row + 12) {            
              EfiMemoryType = EfiMemoryMappedIOPortSpace;            
            } else if (CursorPosition.row == MemoryTypePage_ResetPosition.row + 13) {            
              EfiMemoryType = EfiPalCode;            
            }

            CursorPosition = MemorySettingWrite_ResetPosition;
            gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);

            goto ChangeMode;
          }
        }
        switch (InputKey.ScanCode) {
        
        case SCAN_F2:
          Mode = MAIN_PAGE_MODE; 
          AllBranchPage = MAIN_PAGE_NUM;
          ShowMainPage(&CursorPosition);
          goto ChangeMode;
        }
      }

      //
      // GET_ADDR_MODE
      // with Number(0 ~ 9), Esc key response
      //
      if (Mode == GET_ADDR_MODE) {
        UINT8        WriteCount;
        UINT8        WriteNum;
        UINT16       i;                        // just for loop count
        WRITE_BUFFER WriteBuffer[16];

        WriteCount = 0;
        WriteNum   = 16;

        for (i = 0; i < WriteNum; i++) {
          WriteBuffer[i].value = 0;
          WriteBuffer[i].position = MemorySettingWrite_ResetPosition;
        }

        while (TRUE) {
          gST->ConIn->ReadKeyStroke(gST->ConIn, &InputKey);

          if (InputKey.ScanCode == SCAN_ESC) {
            gST->ConOut->ClearScreen(gST->ConOut);
            goto Exit;
          }
          
          if (WriteCount == WriteNum) {
            Mode = GET_SIZE_MODE;

            //
            // get memory value
            //
            for (WriteCount = 0; WriteCount < WriteNum; WriteCount++) {
              Memory |= WriteBuffer[WriteCount].value << ((WriteNum-WriteCount-1) * 4);
            }

            SetGetSizePageAppearance();
            CursorPosition = MemorySettingWrite_ResetPosition;
            gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);

            goto ChangeMode;
          }

          if (('a' <= InputKey.UnicodeChar && InputKey.UnicodeChar <= 'f')) {
            WriteBuffer[WriteCount].value = (UINT8)InputKey.UnicodeChar - 87;
            WriteBuffer[WriteCount].position.column = CursorPosition.column;
            WriteBuffer[WriteCount].position.row = CursorPosition.row;
            Print(L"%c", InputKey.UnicodeChar);

            CursorPosition.column = CursorPosition.column + 1;
            gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);

            WriteCount++;
            continue;

          } else if (('0' <= InputKey.UnicodeChar && InputKey.UnicodeChar <= '9')) {
            WriteBuffer[WriteCount].value = InputKey.UnicodeChar - 48;
            WriteBuffer[WriteCount].position.column = CursorPosition.column;
            WriteBuffer[WriteCount].position.row = CursorPosition.row;
            Print(L"%c", InputKey.UnicodeChar);
        
            CursorPosition.column = CursorPosition.column + 1;
            gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);
            
            WriteCount++;
            continue;
          }
        }
      }

      //
      // GET_SIZE_MODE
      // with Number(0 ~ F), Esc key response
      //
      if (Mode == GET_SIZE_MODE) {
        UINT8        WriteCount;
        UINT8        WriteNum;
        UINT8        i;                       // just for loop count
        WRITE_BUFFER WriteBufferDecimal[4];

        WriteCount = 0;
        WriteNum   = 4;

        for (i = 0; i < WriteNum; i++) {
          WriteBufferDecimal[i].value = 0;
          WriteBufferDecimal[i].position = MemorySettingWrite_ResetPosition;
        }

        while (TRUE) {
          gST->ConIn->ReadKeyStroke(gST->ConIn, &InputKey);

          if (InputKey.ScanCode == SCAN_ESC) {
            gST->ConOut->ClearScreen(gST->ConOut);
            goto Exit;
          }

          if (WriteCount == WriteNum) {
            Mode = WRITE_MODE;

            //
            // get size value
            //
            for (WriteCount = 0; WriteCount < WriteNum; WriteCount++) {
              size += WriteBufferDecimal[WriteCount].value * Power((UINT64)10, (UINT64)(WriteNum-WriteCount-1));            
            }

            //
            // if size is zero operation
            //
            if (size == 0) {
              Mode = GET_SIZE_MODE;
              SetGetSizePageAppearance();
              CursorPosition = MemorySettingWrite_ResetPosition;
              gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);
              goto ChangeMode;
            }

            //
            // allocate memory
            //
            if (Type == POOL) {
              Status = gBS->AllocatePool(
                                      EfiMemoryType,
                                      size,
                                      &Buffer   // (VOID**)??
                                      );
              if (EFI_ERROR(Status)) {
                Mode = ERROR_MODE;
                gST->ConOut->ClearScreen(gST->ConOut);
                Print(L"%r,Please press F1.\n", Status);
                gST->ConOut->EnableCursor(gST->ConOut, FALSE);
                goto ChangeMode;
              }
            } else if (Type == PAGE) {
              Status = gBS->AllocatePages(
                                      EfiAllocateType,
                                      EfiMemoryType,
                                      size,
                                      &Memory
                                      );
              if (EFI_ERROR(Status)) {
                Mode = ERROR_MODE;
                gST->ConOut->ClearScreen(gST->ConOut);
                Print(L"%r,Please press F1.\n", Status);
                gST->ConOut->EnableCursor(gST->ConOut, FALSE);
                goto ChangeMode;
              }
            }

            SetMemorySettingPageAppearance();
            gST->ConOut->EnableCursor(gST->ConOut, FALSE);
            CursorPosition = ShowAddressAtSettingPage_ResetPosition;
            gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);
            if (Type == POOL) {
              Print(L"Address:0x%.8p - 0x%.8p", Buffer, Buffer + size - 1);
            } else if (Type == PAGE) {
              Print(L"Address:0x%.8x - 0x%.8x", Memory, Memory + (size * 4096) - 1);
            }  

            goto ChangeMode;
          }
          
          if (('0' <= InputKey.UnicodeChar && InputKey.UnicodeChar <= '9')) {
            WriteBufferDecimal[WriteCount].value = InputKey.UnicodeChar - 48;
            WriteBufferDecimal[WriteCount].position.column = CursorPosition.column;
            WriteBufferDecimal[WriteCount].position.row = CursorPosition.row;
            Print(L"%c", InputKey.UnicodeChar);
      
            CursorPosition.column = CursorPosition.column + 1;
            gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);
            
            WriteCount++;
            
            continue;
          }
        }
      }

      //
      // WRITE_MODE
      // with F1(set memory), F2(reset memory), F3(clear screen), F4(show register), Esc key response
      //
      if (Mode == WRITE_MODE) {
        BOOLEAN      IsWriting;          // TRUE -> is writing
        BOOLEAN      AddressOrValue;     // TRUE -> next write value ; FALSE -> next write address
        BOOLEAN      SetOrReset;         // TRUE -> is set ; FALSE -> is reset
        UINT8        LineCount;
        UINT8        WriteCount;
        UINT8        Value;              // for setting memory
        UINT16       WriteNum;
        UINT16       i;
        UINT64       Address;
        UINT64       **TmpAddress;
        WRITE_BUFFER WriteBuffer[16];

        LineCount      = 0;
        WriteCount     = 0;
        WriteNum       = 0;
        Address        = 0;
        Value          = 0;
        TmpAddress     = (UINT64**)&Address;
        IsWriting      = FALSE;
        AddressOrValue = 0;         
        SetOrReset     = 0;       
        
        for (i = 0; i < 16; i++) {
          WriteBuffer[i].value = 0;
          WriteBuffer[i].position = MemorySettingWrite_ResetPosition;
        }

        while (TRUE) {
          while (IsWriting == FALSE) {

            //
            // when address setting finish, do this judgement
            //
            if (AddressOrValue == TRUE) {  
              IsWriting = !IsWriting;
              WriteNum = 2;
              
              //
              // if larger than 13 row, clear the screen
              //
              if (LineCount == 13) {
                SetMemorySettingPageAppearance();
                gST->ConOut->EnableCursor(gST->ConOut, FALSE);
                CursorPosition = ShowAddressAtSettingPage_ResetPosition;
                gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);
                if (Type == POOL) {
                  Print(L"Address:0x%.8p - 0x%.8p", Buffer, Buffer + size - 1);
                } else if (Type == PAGE) {
                  Print(L"Address:0x%.8x - 0x%.8x", Memory, Memory + (size * 4096) - 1);
                }  
                Mode = WRITE_MODE;
                goto ChangeMode;
              }
              
              CursorPosition = MemorySettingPage_ResetPosition;
              CursorPosition.row = CursorPosition.row + LineCount;
              gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);
              Print(L"(1Byte) Set   value  with 0xXX");
              CursorPosition = MemorySettingWrite_ResetPosition;
              CursorPosition.row = CursorPosition.row + LineCount;
              gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);
              gST->ConOut->EnableCursor(gST->ConOut, TRUE);

              LineCount++;
              AddressOrValue = !AddressOrValue;

              break;
            }

            gST->ConIn->ReadKeyStroke(gST->ConIn, &InputKey);

            if (InputKey.ScanCode == SCAN_ESC) {
              gBS->FreePages(
                          Memory,
                          size
                          );
              gBS->FreePool(Buffer);
              gST->ConOut->ClearScreen(gST->ConOut);
              goto Exit;
            }

            switch (InputKey.ScanCode) {
            
            //
            // set address and write value
            //
            case SCAN_F1:
              SetOrReset = 0;
              IsWriting = !IsWriting;
              
              if (LineCount == 13) {
                SetMemorySettingPageAppearance();
                gST->ConOut->EnableCursor(gST->ConOut, FALSE);
                CursorPosition = ShowAddressAtSettingPage_ResetPosition;
                gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);
                if (Type == POOL) {
                  Print(L"Address:0x%.8p - 0x%.8p", Buffer, Buffer + size - 1);
                } else if (Type == PAGE) {
                  Print(L"Address:0x%.8x - 0x%.8x", Memory, Memory + (size * 4096) - 1);
                }  
                LineCount = 0;
              }          
              
              CursorPosition = MemorySettingPage_ResetPosition;
              CursorPosition.row = CursorPosition.row + LineCount;
              gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);

              WriteNum = 16;
              Print(L"(64bit) Set  address with 0xXXXXXXXXXXXXXXXX");  

              CursorPosition = MemorySettingWrite_ResetPosition;
              CursorPosition.row = CursorPosition.row + LineCount;
              gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);
              gST->ConOut->EnableCursor(gST->ConOut, TRUE);

              LineCount++;
              AddressOrValue = !AddressOrValue;
        
              break;

            //
            // to reset
            //
            case SCAN_F2:
              SetOrReset = 1;
              IsWriting = !IsWriting;
              WriteNum = 2;
              if (LineCount == 13) {
                SetMemorySettingPageAppearance();
                gST->ConOut->EnableCursor(gST->ConOut, FALSE);
                CursorPosition = ShowAddressAtSettingPage_ResetPosition;
                gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);
                if (Type == POOL) {
                  Print(L"Address:0x%.8p - 0x%.8p", Buffer, Buffer + size - 1);
                } else if (Type == PAGE) {
                  Print(L"Address:0x%.8x - 0x%.8x", Memory, Memory + (size * 4096) - 1);
                }  
                LineCount = 0;
              }
              CursorPosition = MemorySettingPage_ResetPosition;
              CursorPosition.row = CursorPosition.row + LineCount;
              gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);
              Print(L"(1Byte) Reset memory with 0xXX");
              CursorPosition = MemorySettingWrite_ResetPosition;
              CursorPosition.row = CursorPosition.row + LineCount;
              gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);
              gST->ConOut->EnableCursor(gST->ConOut, TRUE);
              LineCount++;
              break;
            //
            // clear screen
            //
            case SCAN_F3:
              SetMemorySettingPageAppearance();
              gST->ConOut->EnableCursor(gST->ConOut, FALSE);
              CursorPosition = ShowAddressAtSettingPage_ResetPosition;
              gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);
              if (Type == POOL) {
                Print(L"Address:0x%.8p - 0x%.8p", Buffer, Buffer + size - 1);
              } else if (Type == PAGE) {
                Print(L"Address:0x%.8x - 0x%.8x", Memory, Memory + (size * 4096) - 1);
              }  
              LineCount = 0;
              
              continue;

            //
            // show register
            //
            case SCAN_F4:
              Mode = SHOW_MODE;

              SetRegisterPageAppearance();
              gST->ConOut->EnableCursor(gST->ConOut, FALSE);
              CursorPosition = ShowAddressAtRegisterPage_ResetPosition;
              gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);
              if (Type == POOL) {
                Print(L"Address:0x%.8p", Buffer);
              } else if (Type == PAGE) {
                Print(L"Address:0x%.8x", Memory);
              }

              CursorPosition = RegistPage_ResetPosition;
              gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);
              gST->ConOut->EnableCursor(gST->ConOut, FALSE);

              if (Type == POOL) {
                for (i = 0; i < 256; i++) {
                  if ((i % 16) == 0) {
                    Print(L"%2.2x", *(Buffer + i));
                  } else if ((i % 16) == 15) {
                    Print(L"%3.2x", *(Buffer + i));
                    CursorPosition.column = RegistPage_ResetPosition.column;
                    CursorPosition.row++;
                    gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);
                  } else {
                    Print(L"%3.2x", *(Buffer + i));
                  }
                }
              } else if (Type == PAGE) {
                for (i = 0; i < 256; i++) {
                  if ((i % 16) == 0) {
                    Print(L"%2.2x", *(UINT8*)(*TmpMemory + i));
                  } else if ((i % 16) == 15) {
                    Print(L"%3.2x", *(UINT8*)(*TmpMemory + i));
                    CursorPosition.column = RegistPage_ResetPosition.column;
                    CursorPosition.row++;
                    gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);
                  } else {
                    Print(L"%3.2x", *(UINT8*)(*TmpMemory + i));
                  }
                }
              }

              goto ChangeMode;
            }
            
          }
          
          //
          // for writing
          //
          while (IsWriting == TRUE) {
            gST->ConIn->ReadKeyStroke(gST->ConIn, &InputKey);

            if (InputKey.ScanCode == SCAN_ESC) {
              gBS->FreePages(
                          Memory,
                          size
                          );
              gBS->FreePool(Buffer);
              gST->ConOut->ClearScreen(gST->ConOut);
              goto Exit;
            }

            if (WriteCount == WriteNum) {

              if (SetOrReset == FALSE && AddressOrValue == FALSE) {

                // prepare addr
                for (WriteCount = 0; WriteCount < WriteNum; WriteCount++) {
                  Address |= WriteBuffer[WriteCount].value << ((WriteNum-WriteCount-1) * 4);
                }
                
                // judge addr illigle mark:
                if(Address < *((UINT64*)TmpBuffer) || Address > (*((UINT64*)TmpBuffer) + size)) {
                  SetMemorySettingPageAppearance();
                  gST->ConOut->EnableCursor(gST->ConOut, FALSE);
                  CursorPosition = ShowAddressAtSettingPage_ResetPosition;
                  gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);
                  if (Type == POOL) {
                    Print(L"Address:0x%.8p - 0x%.8p", Buffer, Buffer + size - 1);
                  } else if (Type == PAGE) {
                    Print(L"Address:0x%.8x - 0x%.8x", Memory, Memory + (size * 4096) - 1);
                  }
                  CursorPosition =  MemorySettingPage_ResetPosition;
                  gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);
                  Print(L"------Invalid range! Please set again.------");
                  
                  Mode = WRITE_MODE;

                  goto ChangeMode;
                }

              } else if (SetOrReset == FALSE && AddressOrValue == FALSE) {

                // prepare value
                for (WriteCount = 0; WriteCount < WriteNum; WriteCount++) {
                  Value |= WriteBuffer[WriteCount].value << ((WriteNum-WriteCount-1) * 4);
                }            

                gBS->SetMem(
                        *((UINT8**)TmpAddress),
                        1,
                        Value
                        );
              
              } else if (SetOrReset == TRUE) { 

                // prepare value
                for (WriteCount = 0; WriteCount < WriteNum; WriteCount++) {
                  Value |= WriteBuffer[WriteCount].value << ((WriteNum-WriteCount-1) * 4);
                }              
                
                //
                // set memory
                //
                if (Type == POOL) {
                  gBS->SetMem(
                        Buffer,
                        size,
                        Value
                        );
                } else if (Type == PAGE) {
                  for (i = 0; i < 4096 * size; i++) {
                    gBS->SetMem(
                            *TmpMemory + i,
                            1,
                            Value
                            );
                  }
                  
                }
              }
              
              Value = 0;
              WriteCount = 0;
              for (i = 0; i < 16; i++) {
                WriteBuffer[i].value = 0;
                WriteBuffer[i].position = MemorySettingWrite_ResetPosition;
              }
              IsWriting = !IsWriting;
              break;
            }

            if (('a' <= InputKey.UnicodeChar && InputKey.UnicodeChar <= 'f')) {
              WriteBuffer[WriteCount].value = (UINT8)InputKey.UnicodeChar - 87;
              WriteBuffer[WriteCount].position.column = CursorPosition.column;
              WriteBuffer[WriteCount].position.row = CursorPosition.row;
              Print(L"%c", InputKey.UnicodeChar);

              CursorPosition.column = CursorPosition.column + 1;
              gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);
              WriteCount++;
              continue;

            } else if (('0' <= InputKey.UnicodeChar && InputKey.UnicodeChar <= '9')) {
              WriteBuffer[WriteCount].value = InputKey.UnicodeChar - 48;
              WriteBuffer[WriteCount].position.column = CursorPosition.column;
              WriteBuffer[WriteCount].position.row = CursorPosition.row;
              Print(L"%c", InputKey.UnicodeChar);
              
              CursorPosition.column = CursorPosition.column + 1;
              gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);
              WriteCount++;
              
              continue;
            }
          }
        }
      }
      
      //
      // SHOW_MODE
      // with up, down(turn page), F1(set memory), F2(home), Esc key response
      // 
      if (Mode == SHOW_MODE) {
        UINT64 Page;            // for turn page
        UINT64 i;

        Page = 0;
        while (TRUE)  {
          gST->ConIn->ReadKeyStroke(gST->ConIn, &InputKey);

          if (InputKey.ScanCode == SCAN_ESC) {
            gBS->FreePages(
                        Memory,
                        size
                        );
            gBS->FreePool(Buffer);
            gST->ConOut->ClearScreen(gST->ConOut);
            goto Exit;
          }

          switch (InputKey.ScanCode) {

          case SCAN_UP:
            Page--;

            SetRegisterPageAppearance();
            gST->ConOut->EnableCursor(gST->ConOut, FALSE);
            CursorPosition = ShowAddressAtRegisterPage_ResetPosition;
            gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);
            if (Type == POOL) {
              Print(L"Address:0x%.8p", Buffer + Page * 256);
            } else if (Type == PAGE) {
              Print(L"Address:0x%.8x", Memory, Memory + Page * 256);
            }
              CursorPosition = RegistPage_ResetPosition;
              gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);
              gST->ConOut->EnableCursor(gST->ConOut, FALSE);

              if (Type == POOL) {
                for (i = 0 + Page * 256; i < Page * 256 + 256; i++) {
                  if ((i % 16) == 0) {
                    Print(L"%2.2x", *(Buffer + i));
                  } else if ((i % 16) == 15) {
                    Print(L"%3.2x", *(Buffer + i));
                    CursorPosition.column = RegistPage_ResetPosition.column;
                    CursorPosition.row++;
                    gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);
                  } else {
                    Print(L"%3.2x", *(Buffer + i));
                  }
                }
              } else if (Type == PAGE) {
                for (i = 0 + Page * 256; i < Page * 256 + 256; i++) {
                  if ((i % 16) == 0) {
                    Print(L"%2.2x", *(UINT8*)(*TmpMemory + i));
                  } else if ((i % 16) == 15) {
                    Print(L"%3.2x", *(UINT8*)(*TmpMemory + i));
                    CursorPosition.column = RegistPage_ResetPosition.column;
                    CursorPosition.row++;
                    gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);
                  } else {
                    Print(L"%3.2x", *(UINT8*)(*TmpMemory + i));
                  }
                }
              }
                
            continue;

          case SCAN_DOWN:
            Page++;

            SetRegisterPageAppearance();
            gST->ConOut->EnableCursor(gST->ConOut, FALSE);
            CursorPosition = ShowAddressAtRegisterPage_ResetPosition;
            gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);
            if (Type == POOL) {
              Print(L"Address:0x%.8p", Buffer + Page * 256);
            } else if (Type == PAGE) {
              Print(L"Address:0x%.8x", Memory, Memory + Page * 256);
            }
              CursorPosition = RegistPage_ResetPosition;
              gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);
              gST->ConOut->EnableCursor(gST->ConOut, FALSE);

              if (Type == POOL) {
                for (i = 0 + Page * 256; i < Page * 256 + 256; i++) {
                  if ((i % 16) == 0) {
                    Print(L"%2.2x", *(Buffer + i));
                  } else if ((i % 16) == 15) {
                    Print(L"%3.2x", *(Buffer + i));
                    CursorPosition.column = RegistPage_ResetPosition.column;
                    CursorPosition.row++;
                    gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);
                  } else {
                    Print(L"%3.2x", *(Buffer + i));
                  }
                }
              } else if (Type == PAGE) {
                for (i = 0 + Page * 256; i < Page * 256 + 256; i++) {
                  if ((i % 16) == 0) {
                    Print(L"%2.2x", *(UINT8*)(*TmpMemory + i)); // (UINT8*)
                  } else if ((i % 16) == 15) {
                    Print(L"%3.2x", *(UINT8*)(*TmpMemory + i));
                    CursorPosition.column = RegistPage_ResetPosition.column;
                    CursorPosition.row++;
                    gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);
                  } else {
                    Print(L"%3.2x", *(UINT8*)(*TmpMemory + i));
                  }
                }
              }
            continue;

          //
          // get back write mode
          //
          case SCAN_F1:
            Mode = WRITE_MODE;
            SetMemorySettingPageAppearance();
            gST->ConOut->EnableCursor(gST->ConOut, FALSE);
            CursorPosition = ShowAddressAtSettingPage_ResetPosition;
            gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);
            if (Type == POOL) {
              Print(L"Address:0x%.8p - 0x%.8p", Buffer, Buffer + size - 1);
            } else if (Type == PAGE) {
              Print(L"Address:0x%.8x - 0x%.8x", Memory, Memory + (size * 4096) - 1);
            }  
            goto ChangeMode;

          //
          // get back main page
          //
          case SCAN_F2:
            Mode = MAIN_PAGE_MODE;
            gBS->FreePages(
                        Memory,
                        size
                        );
            gBS->FreePool(Buffer); 
            AllBranchPage = MAIN_PAGE_NUM;
            size = 0;
            ShowMainPage(&CursorPosition);
            gST->ConOut->EnableCursor(gST->ConOut, TRUE);
            goto ChangeMode;
          }
        }
      }
      

      //
      // ERROR_MODE
      // with F1(home) key response
      //
      while (Mode == ERROR_MODE) {
        gST->ConIn->ReadKeyStroke(gST->ConIn, &InputKey);

        switch (InputKey.ScanCode) {
        
        case SCAN_F1:
          Mode = MAIN_PAGE_MODE;
          gBS->FreePages(
                      Memory,
                      size
                      );
          gBS->FreePool(Buffer); 
          AllBranchPage = MAIN_PAGE_NUM;
          size = 0;
          ShowMainPage(&CursorPosition);
          gST->ConOut->EnableCursor(gST->ConOut, TRUE);
          goto ChangeMode;
        }
      }
    }

    //
    // to get out
    //
    Exit:

    Status = EFI_SUCCESS;

    return Status;
  }

  VOID 
  SetMainPageAppearance (
    VOID
    )
  {
    gST->ConOut->ClearScreen(gST->ConOut);
    gST->ConOut->SetAttribute(gST->ConOut, EFI_WHITE | EFI_BACKGROUND_BLACK);

    Print(L"|====================================================|\n");
    Print(L"|                                                    |\n");
    Print(L"|                  12-Memory_utility                 |\n");
    Print(L"|                                                    |\n");
    Print(L"|====================================================|\n");
    Print(L"|              Allocate Memory By Page               |\n");
    Print(L"|              Allocate Memory By Pool               |\n");
    Print(L"|====================================================|\n");
    Print(L"| [Arrow key] : Choose                               |\n");
    Print(L"| [F1] : Enter                                       |\n");
    Print(L"| [Esc] : Escape                                     |\n");
    Print(L"|====================================================|\n");

    return;
  }

  VOID 
  SetAllocateTypePageAppearance (
    VOID
    )
  {
    gST->ConOut->ClearScreen(gST->ConOut);
    gST->ConOut->SetAttribute(gST->ConOut, EFI_WHITE | EFI_BACKGROUND_BLACK);

    Print(L"|====================================================|\n");
    Print(L"|                                                    |\n");
    Print(L"|                   Allocate Type                    |\n");
    Print(L"|                                                    |\n");
    Print(L"|====================================================|\n");
    Print(L"|              Allocate Any Pages                    |\n");
    Print(L"|              Allocate Max Address                  |\n");
    Print(L"|              Allocate Address                      |\n");
    Print(L"|====================================================|\n");
    Print(L"| [Arrow key] : Choose     [Esc] : Escape            |\n");
    Print(L"| [F1] : Enter             [F2] : Home               |\n");
    Print(L"|====================================================|\n");

    return;
  }


  VOID 
  SetMemoryTypePageAppearance (
    VOID
    )
  {
    gST->ConOut->ClearScreen(gST->ConOut);
    gST->ConOut->SetAttribute(gST->ConOut, EFI_WHITE | EFI_BACKGROUND_BLACK);

    Print(L"|====================================================|\n");
    Print(L"|                                                    |\n");
    Print(L"|                    Memory Type                     |\n");
    Print(L"|                                                    |\n");
    Print(L"|====================================================|\n");
    Print(L"|              Reserved Memory                       |\n");
    Print(L"|              Loader Code                           |\n");
    Print(L"|              Loader Data                           |\n");
    Print(L"|              Boot Service Code                     |\n");
    Print(L"|              Boot Service Data                     |\n");
    Print(L"|              Runtime Service Code                  |\n");
    Print(L"|              Runtime Service Data                  |\n");
    Print(L"|              Conventional Memory                   |\n");
    Print(L"|              Unusable Memory                       |\n");
    Print(L"|              ACPI Reclaim Memory                   |\n");
    Print(L"|              ACPI NVS Memory                       |\n");
    Print(L"|              Memory Mapped IO                      |\n");
    Print(L"|              Memory Mapped IO Port Space           |\n");
    Print(L"|              PAL Code                              |\n");
    Print(L"|====================================================|\n");
    Print(L"| [Arrow key] : Choose     [Esc] : Escape            |\n");
    Print(L"| [F1] : Enter             [F2] : Home               |\n");
    Print(L"|====================================================|\n");

    return;
  }

  VOID 
  SetGetSizePageAppearance (
    VOID
    )
  {
    gST->ConOut->ClearScreen(gST->ConOut);
    gST->ConOut->SetAttribute(gST->ConOut, EFI_WHITE | EFI_BACKGROUND_BLACK);

    Print(L"|====================================================|\n");
    Print(L"|                                                    |\n");
    Print(L"|                     Get Size                       |\n");
    Print(L"|                                                    |\n");
    Print(L"|====================================================|\n");
    Print(L"|              Please set size.                      |\n");
    Print(L"|              Set  size  with   XXXX                |\n");
    Print(L"|                                                    |\n");
    Print(L"|====================================================|\n");
    Print(L"| [Num]:Number                                       |\n");
    Print(L"| [Esc]:Escape                                       |\n");
    Print(L"|====================================================|\n");

    return;
  }

  VOID 
  SetGetAddressPageAppearance (
    VOID
    )
  {
    gST->ConOut->ClearScreen(gST->ConOut);
    gST->ConOut->SetAttribute(gST->ConOut, EFI_WHITE | EFI_BACKGROUND_BLACK);

    Print(L"|====================================================|\n");
    Print(L"|                                                    |\n");
    Print(L"|                     Get Address                    |\n");
    Print(L"|                                                    |\n");
    Print(L"|====================================================|\n");
    Print(L"|            Please set address.                     |\n");
    Print(L"|            Set  address with 0xXXXXXXXXXXXXXXXX    |\n");
    Print(L"|                                                    |\n");
    Print(L"|====================================================|\n");
    Print(L"| [Num]:Number                                       |\n");
    Print(L"| [Esc]:Escape                                       |\n");
    Print(L"|====================================================|\n");

    return;
  }

  VOID 
  SetMemorySettingPageAppearance (
    VOID
    )
  {
    gST->ConOut->ClearScreen(gST->ConOut);
    gST->ConOut->SetAttribute(gST->ConOut, EFI_WHITE | EFI_BACKGROUND_BLACK);

    Print(L"|====================================================|\n");
    Print(L"|                                                    |\n");
    Print(L"|                  Memory Setting                    |\n");
    Print(L"|                                                    |\n");
    Print(L"|====================================================|\n");
    Print(L"|           Please press button to modify.           |\n");
    Print(L"|                                                    |\n");
    Print(L"|                                                    |\n");
    Print(L"|                                                    |\n");
    Print(L"|                                                    |\n");
    Print(L"|                                                    |\n");
    Print(L"|                                                    |\n");
    Print(L"|                                                    |\n");
    Print(L"|                                                    |\n");
    Print(L"|                                                    |\n");
    Print(L"|                                                    |\n");
    Print(L"|                                                    |\n");
    Print(L"|                                                    |\n");
    Print(L"|                                                    |\n");
    Print(L"|====================================================|\n");
    Print(L"| [F1]:Set       [F2]:Reset     [F3]:Clean Screen    |\n");
    Print(L"| [F4]:Show      [Esc]:Escape   [Num]:Number         |\n");
    Print(L"|====================================================|\n");

    return;
  }

  VOID 
  SetRegisterPageAppearance (
    VOID
    )
  {
    gST->ConOut->ClearScreen(gST->ConOut);
    gST->ConOut->SetAttribute(gST->ConOut, EFI_WHITE | EFI_BACKGROUND_BLACK);

    Print(L"|                                                    |\n");
    Print(L"|====================================================|\n");
    Print(L"|  | 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F |\n");
    Print(L"|====================================================|\n");
    Print(L"|00|                                                 |\n");
    Print(L"|10|                                                 |\n");
    Print(L"|20|                                                 |\n");
    Print(L"|30|                                                 |\n");
    Print(L"|40|                                                 |\n");
    Print(L"|50|                                                 |\n");
    Print(L"|60|                                                 |\n");
    Print(L"|70|                                                 |\n");
    Print(L"|80|                                                 |\n");
    Print(L"|90|                                                 |\n");
    Print(L"|A0|                                                 |\n");
    Print(L"|B0|                                                 |\n");
    Print(L"|C0|                                                 |\n");
    Print(L"|D0|                                                 |\n");
    Print(L"|E0|                                                 |\n");
    Print(L"|F0|                                                 |\n");
    Print(L"|====================================================|\n");
    Print(L"| [F1]:Modify            [F2]:Home                   |\n");
    Print(L"| [Arrow key]:Choose     [Esc]:Escape                |\n");
    Print(L"|====================================================|\n");

    return;
  }


  VOID 
  ShowMainPage (
    POSITION *CursorPosition
    )
  {
    SetMainPageAppearance();
    *CursorPosition = MainPage_ResetPosition;
    gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition->column, CursorPosition->row);
    gST->ConOut->EnableCursor(gST->ConOut, TRUE);

    return;
  }

  UINT64 Power (
    UINT64 Base,
    UINT64 Index
    )
  {  
    if (Index == 0) {
      return 1;
    } else {
      return (Base * Power(Base, Index-1));
    }
  }
*/

/*// ImageHandleProtocol_13 finish(v1)
  #include <Uefi.h>
  #include <Library/UefiLib.h>
  #include <Library/UefiApplicationEntryPoint.h>
  #include <Library/UefiBootServicesTableLib.h>

  #include <Library/ShellLib.h>
  #include <Library/HandleParsingLib.h>

  typedef struct {
    INT16 column;         /// cursor column
    INT16 row;            /// cursor row
  } POSITION;

  typedef struct {
    UINT64    value;      /// write value
    POSITION  position;   /// cursor position
  } WRITE_BUFFER;

  EFI_STATUS 
  SearchAllProtocol (
    VOID
    );

  EFI_STATUS 
  SearchProtocolByGuid (
    EFI_GUID *ProtocolGuid
    );

  EFI_STATUS 
  SearchProtocolGuidByName (
    CHAR16 *Str
    );

  UINT32 
  InputValue (
    WRITE_BUFFER *WriteBuffer,
    POSITION *CursorPosition
    );

  UINT32 
  InputWord (
    WRITE_BUFFER *WriteBuffer, 
    POSITION *CursorPosition
    );

  EFI_GUID 
  ParseGuid (
    WRITE_BUFFER *WriteBuffer
    );

  VOID 
  SetMainPageAppearance (
    VOID
    );

  VOID 
  InitializeArray(
    WRITE_BUFFER *WriteBuffer
    );


  EFI_STATUS
  EFIAPI
  UefiMain (
    IN EFI_HANDLE ImageHandle, 
    IN EFI_SYSTEM_TABLE *SystemTable
    )
  {
    EFI_STATUS            Status;
    EFI_INPUT_KEY         InputKey;
    POSITION              CursorPosition;
    EFI_GUID              ProtocolGuid;
    WRITE_BUFFER          WriteBuffer[50];
    CHAR16                Str[50];
    UINT32                i;

    CursorPosition.column = 0;
    CursorPosition.row    = 0;

    InitializeArray(WriteBuffer);

    gST->ConOut->ClearScreen(gST->ConOut);
    gST->ConOut->EnableCursor(gST->ConOut, FALSE);
    SetMainPageAppearance();

    while (TRUE) {
      gST->ConIn->ReadKeyStroke(gST->ConIn, &InputKey);

      if (InputKey.ScanCode == SCAN_ESC) {
        gST->ConOut->ClearScreen(gST->ConOut);
        break;
      }

      switch (InputKey.ScanCode) {

      case SCAN_F1:
        gST->ConOut->ClearScreen(gST->ConOut);
        SearchAllProtocol();
        continue;

      case SCAN_F2:
        gST->ConOut->ClearScreen(gST->ConOut);
        Print(L"Please input GUID.\n");
        InputValue(WriteBuffer, &CursorPosition);
        Print(L"\n");
        ProtocolGuid = ParseGuid(WriteBuffer);
        SearchProtocolByGuid(&ProtocolGuid);
        InitializeArray(WriteBuffer);
        continue;

      case SCAN_F3:
        gST->ConOut->ClearScreen(gST->ConOut);
        Print(L"Please input Protocol name.\n");
        InputWord(WriteBuffer, &CursorPosition);

        for (i = 0; i < 50; i++) {
          Str[i] = (CHAR16)(WriteBuffer[i].value);
        }
        Print(L"Name:%s\nGUID:", Str);
        SearchProtocolGuidByName(Str);
        InitializeArray(WriteBuffer);
        continue;

      case SCAN_DOWN:
        gST->ConOut->ClearScreen(gST->ConOut);
        SetMainPageAppearance();
        continue;
      }
    }

    Status = EFI_SUCCESS;

    return Status; 
  }

  EFI_STATUS 
  SearchProtocolGuidByName (
    CHAR16 *Str
    )
  {
    EFI_STATUS            Status;
    EFI_GUID              *ProtocolBuffer;
    EFI_INPUT_KEY         InputKey;

    Status = GetGuidFromStringName(
              Str, 
              NULL, 
              &ProtocolBuffer
              );

    if (EFI_ERROR (Status)){
      Print(L"%r\n", Status);
      gST->ConOut->SetAttribute(gST->ConOut, EFI_YELLOW | EFI_BACKGROUND_BLACK);
      Print(L"Press down to exit.");
      gST->ConOut->SetAttribute(gST->ConOut, EFI_WHITE | EFI_BACKGROUND_BLACK);
      return Status;
    }

    Print(L"%g\n", ProtocolBuffer);
    gST->ConOut->SetAttribute(gST->ConOut, EFI_YELLOW | EFI_BACKGROUND_BLACK);
    Print(L"Press down to exit.");
    gST->ConOut->SetAttribute(gST->ConOut, EFI_WHITE | EFI_BACKGROUND_BLACK);

    while (TRUE) {
      gST->ConIn->ReadKeyStroke(gST->ConIn, &InputKey);

      switch(InputKey.ScanCode){
      
      case SCAN_DOWN:
        gST->ConOut->ClearScreen(gST->ConOut);
        SetMainPageAppearance();
        return Status;
      }
    }
  }

  UINT32 
  InputWord (
    WRITE_BUFFER *WriteBuffer, 
    POSITION *CursorPosition
    )
  {
    EFI_INPUT_KEY         InputKey;
    INT32                WriteCount;

    WriteCount = 0;

    while (TRUE) {
      gST->ConIn->ReadKeyStroke(gST->ConIn, &InputKey);

      if (WriteCount >= 50) {
        return WriteCount;
      }

      switch(InputKey.UnicodeChar){
      case CHAR_NULL:
        continue;
      
      case CHAR_CARRIAGE_RETURN:
        gST->ConOut->ClearScreen(gST->ConOut);
        return WriteCount;
      
      case CHAR_BACKSPACE:
        WriteCount--;
        if (WriteCount < 0) {
          WriteCount = 0;
        }
        WriteBuffer[WriteCount].value = CHAR_NULL;
        Print(L"%c", InputKey.UnicodeChar); 
        
        continue;

      default:
        WriteBuffer[WriteCount].value = InputKey.UnicodeChar;
        Print(L"%c", InputKey.UnicodeChar);
        WriteCount++;
        continue;
      }
    }
  }

  EFI_STATUS
  SearchProtocolByGuid (
    EFI_GUID *ProtocolGuid
    )
  {
    EFI_STATUS            Status;
    EFI_HANDLE            *HandleBuffer;
    UINT64                HandleNumber;
    UINT32                HandleCount;
    EFI_GUID              **ProtocolBuffer;
    UINT64                ProtocolNumber;
    EFI_INPUT_KEY         InputKey;
    
    Status = gBS->LocateHandleBuffer(
                    ByProtocol,
                    ProtocolGuid,
                    NULL,
                    &HandleNumber,
                    &HandleBuffer
                    );
    if (EFI_ERROR (Status)){
      Print(L"%r\n", Status);
      gST->ConOut->SetAttribute(gST->ConOut, EFI_YELLOW | EFI_BACKGROUND_BLACK);
      Print(L"Press down to exit.");
      gST->ConOut->SetAttribute(gST->ConOut, EFI_WHITE | EFI_BACKGROUND_BLACK);
      return Status;
    } else {

      for (HandleCount = 0; HandleCount < HandleNumber; HandleCount++) {
        Print(L"Handle:%d --> 0x%.8x\n", HandleCount, HandleBuffer[HandleCount]);
        Status = gBS->ProtocolsPerHandle(
                                      HandleBuffer[HandleCount],
                                      &ProtocolBuffer,
                                      &ProtocolNumber
                                      );
        Print(L"   Protocol:%s --> GUID:%g\n", GetStringNameFromGuid(
                                                                  *ProtocolBuffer,
                                                                  NULL
                                                                  ), 
                                              ProtocolGuid
                                              );

        if (HandleCount % 10 == 9) {
          gST->ConOut->SetAttribute(gST->ConOut, EFI_YELLOW | EFI_BACKGROUND_BLACK);
          Print(L"Press down to next page.");
          gST->ConOut->SetAttribute(gST->ConOut, EFI_WHITE | EFI_BACKGROUND_BLACK);
          while (TRUE) {
            gST->ConIn->ReadKeyStroke(gST->ConIn, &InputKey);

            if (InputKey.ScanCode == SCAN_DOWN) {
              gST->ConOut->ClearScreen(gST->ConOut);
              break;
            }
          }
        }
        if (HandleCount + 1 == HandleNumber) {
          gST->ConOut->SetAttribute(gST->ConOut, EFI_YELLOW | EFI_BACKGROUND_BLACK);
          Print(L"Press down to exit.");
          gST->ConOut->SetAttribute(gST->ConOut, EFI_WHITE | EFI_BACKGROUND_BLACK);
          while (TRUE) {
            gST->ConIn->ReadKeyStroke(gST->ConIn, &InputKey);

            if (InputKey.ScanCode == SCAN_DOWN) {
              gST->ConOut->ClearScreen(gST->ConOut);
              SetMainPageAppearance();
              break; 
            }
          }
        }
      }
    }

    return Status; 
  }

  EFI_GUID 
  ParseGuid (
    WRITE_BUFFER *WriteBuffer
    )
  {
    EFI_GUID TestGuid;
    UINT32   i;
    UINT32   j;
    
    TestGuid.Data1 = 0;
    TestGuid.Data2 = 0;
    TestGuid.Data3 = 0;
    

    for (i = 0; i < 8; i++) {
      TestGuid.Data4[i] = 0;
    }

    for (i = 0; i < 8; i++) {
      TestGuid.Data1 |= WriteBuffer[i].value << ((8-i-1) * 4);
    }

    for (i = 8; i < 12; i++) {
      TestGuid.Data2 |= WriteBuffer[i].value << ((12-i-1) * 4);
    }

    for (i = 12; i < 16; i++) {
      TestGuid.Data3 |= WriteBuffer[i].value << ((16-i-1) * 4);
    }

    for (j = 0; j < 8; j++) {
      for (i = 16 + 2*j; i < 18 + 2*j; i++) {
        TestGuid.Data4[j] |= WriteBuffer[i].value << (((18+2*j)-i-1) * 4);
      }
    }

    return TestGuid;
  }

  UINT32
  InputValue (
    WRITE_BUFFER  *WriteBuffer,
    POSITION      *CursorPosition
    )
  {
    EFI_INPUT_KEY         InputKey;
    INT32                WriteCount;
    BOOLEAN               Flag;

    WriteCount = 0;
    Flag = 0;

    while (TRUE) {
      gST->ConIn->ReadKeyStroke(gST->ConIn, &InputKey);

      if (WriteCount == 32) {
        return WriteCount;
      }

      if (('a' <= InputKey.UnicodeChar && InputKey.UnicodeChar <= 'f')) {
        
        WriteBuffer[WriteCount].value = InputKey.UnicodeChar - 87;
        Print(L"%c", InputKey.UnicodeChar);
        WriteCount++;
        
        continue;

      } else if (('0' <= InputKey.UnicodeChar && InputKey.UnicodeChar <= '9')) {
        WriteBuffer[WriteCount].value = InputKey.UnicodeChar - 48;
        Print(L"%c", InputKey.UnicodeChar);
        WriteCount++;

        continue;
      } else if (InputKey.UnicodeChar == CHAR_BACKSPACE) {

        WriteCount--;
      
        if(WriteCount < 0) {
          WriteCount = 0;
        } 
      
        WriteBuffer[WriteCount].value = CHAR_NULL;
        Print(L"%c", InputKey.UnicodeChar);

        continue;
      }
    }
  }

  EFI_STATUS 
  SearchAllProtocol (
    VOID
    )
  {
    EFI_STATUS            Status;
    EFI_HANDLE            *HandleBuffer;
    UINT64                HandleNumber;
    UINT32                HandleCount;
    EFI_GUID              **ProtocolBuffer;
    UINT64                ProtocolNumber;
    UINT32                ProtocolCount;
    EFI_INPUT_KEY         InputKey;

    gST->ConOut->ClearScreen(gST->ConOut);
    
    Status = gBS->LocateHandleBuffer(
                    AllHandles,
                    NULL,
                    NULL,
                    &HandleNumber,
                    &HandleBuffer
                    );
    if (EFI_ERROR (Status)){
      gST->ConOut->SetAttribute(gST->ConOut, EFI_YELLOW | EFI_BACKGROUND_BLACK);
      Print(L"%r\nPress down to exit.", Status);
      gST->ConOut->SetAttribute(gST->ConOut, EFI_WHITE | EFI_BACKGROUND_BLACK);
      
      return Status;
    } else {

      for (HandleCount = 0; HandleCount < HandleNumber; HandleCount++) {

        Print(L"Handle:%d --> 0x%.8x\n", HandleCount, HandleBuffer[HandleCount]);

        Status = gBS->ProtocolsPerHandle(
                                      HandleBuffer[HandleCount],
                                      &ProtocolBuffer,
                                      &ProtocolNumber
                                      );
        if (EFI_ERROR (Status)){
          gST->ConOut->SetAttribute(gST->ConOut, EFI_YELLOW | EFI_BACKGROUND_BLACK);
          Print(L"%r\nPress down to exit.", Status);
          gST->ConOut->SetAttribute(gST->ConOut, EFI_WHITE | EFI_BACKGROUND_BLACK);
          return Status;
        } else {

          for (ProtocolCount = 0; ProtocolCount < ProtocolNumber; ProtocolCount++) {

            Print(L"   Protocol:%s --> GUID:%g\n", GetStringNameFromGuid(
                                                                      *ProtocolBuffer,
                                                                      NULL
                                                                      ), 
                                                  ProtocolBuffer[ProtocolCount]
                                                  );          
          }
          if (HandleCount % 3 == 2) {
            gST->ConOut->SetAttribute(gST->ConOut, EFI_YELLOW | EFI_BACKGROUND_BLACK);
            Print(L"Press down to next page.");
            gST->ConOut->SetAttribute(gST->ConOut, EFI_WHITE | EFI_BACKGROUND_BLACK);
            while (TRUE) {
              gST->ConIn->ReadKeyStroke(gST->ConIn, &InputKey);

              if (InputKey.ScanCode == SCAN_DOWN) {
                gST->ConOut->ClearScreen(gST->ConOut);
                break;
              }
            }
          }
          if (HandleCount + 1 == HandleNumber) {
            gST->ConOut->SetAttribute(gST->ConOut, EFI_YELLOW | EFI_BACKGROUND_BLACK);
            Print(L"Press down to exit.");
            gST->ConOut->SetAttribute(gST->ConOut, EFI_WHITE | EFI_BACKGROUND_BLACK);
            while (TRUE) {
              gST->ConIn->ReadKeyStroke(gST->ConIn, &InputKey);

              if (InputKey.ScanCode == SCAN_DOWN) {
                gST->ConOut->ClearScreen(gST->ConOut);
                SetMainPageAppearance();
                break;
              }
            }
          }
        }
      }
    }
    return Status;
  }


  VOID 
  SetMainPageAppearance (
    VOID
    )
  {
    gST->ConOut->ClearScreen(gST->ConOut);
    gST->ConOut->SetAttribute(gST->ConOut, EFI_WHITE | EFI_BACKGROUND_BLACK);

    Print(L"|====================================================|\n");
    Print(L"|                                                    |\n");
    Print(L"|              13-Image/Handle/Protocol              |\n");
    Print(L"|                                                    |\n");
    Print(L"|====================================================|\n");
    Print(L"|                                                    |\n");
    Print(L"| [F1] : Search all Handle and Protocol              |\n");
    Print(L"| [F2] : Search Protocol name by GUID                |\n");
    Print(L"| [F3] : Search GUID by Protocol name                |\n");
    Print(L"| [Esc] : Escape                                     |\n");
    Print(L"|====================================================|\n");

    return;
  }

  VOID 
  InitializeArray(
    WRITE_BUFFER *WriteBuffer
    )
  {
    UINT32 i;

    for (i = 0; i < 50; i++) {
      WriteBuffer[i].value = 0;
      WriteBuffer[i].position.column = 0;
      WriteBuffer[i].position.row = 0;
    }
  }
*/

/*// Sio_09 finish(v1)
  #include <Uefi.h>
  #include <Library/UefiLib.h>
  #include <Library/UefiApplicationEntryPoint.h>
  #include <Library/UefiBootServicesTableLib.h>
  #include <Protocol/CpuIo2.h>

  #define MAIN_PAGE_MODE   0
  #define BRANCH_PAGE_MODE 1

  #define DownEdgeInterval  15
  #define RightEdgeInterval 50
  #define LeftEdgeInterval  5

  #define MaxIndex 256

  #define AddressPort    0x2e
  #define DataPort       0x2f
  #define Unlock         0x87
  #define Lock           0xaa
  #define LdnReg         0x7

  typedef struct {
    INT16 column;         /// cursor column
    INT16 row;            /// cursor row
  } POSITION;

  typedef struct {
    UINT64    value;      /// write value
    POSITION  position;   /// cursor position
  } WRITE_BUFFER;

  VOID 
  SetMainPageAppearance (
    VOID
    );

  VOID 
  SetRegisterPageAppearance (
    VOID
    );

  VOID 
  ShowMainPage (
    POSITION *CursorPosition
    );

  VOID 
  ShowRegisterPage (
    POSITION *CursorPosition
    );

  VOID 
  ShowOffset (
    POSITION *CursorPosition
    );

  VOID 
  ShowTitle (
    POSITION *CursorPosition,
    UINT8 *Ldn
    );

  VOID 
  ShowSio (
    POSITION *CursorPosition,
    UINT8 *Ldn
    );

  UINT64 
  InputValue (
    WRITE_BUFFER *WriteBuffer,
    UINT32 *InputAmount
    );

  VOID 
  InitializeArray(
    WRITE_BUFFER *WriteBuffer
    );

  EFI_STATUS
  ReadSio (
    POSITION *CursorPosition,
    UINT8 *Ldn
    );

  EFI_STATUS
  WriteSio (
    POSITION *CursorPosition,
    UINT8 *Ldn,
    UINT64 ModifyValue
    );

  const POSITION  MainPage_ResetPosition  = {46, 6};
  const POSITION  ResetPosition           = {5, 4};
  const POSITION  OffsetPosition          = {1, 2};
  const POSITION  TitlePosition           = {2, 0};

  EFI_STATUS
  EFIAPI
  UefiMain (
    IN EFI_HANDLE ImageHandle, 
    IN EFI_SYSTEM_TABLE *SystemTable
    )
  {
    EFI_STATUS            Status;
    EFI_INPUT_KEY         InputKey;
    UINT8                 Mode;
    POSITION              CursorPosition;
    WRITE_BUFFER          WriteBuffer[2];
    UINT8                 Ldn;
    UINT64                ModifyValue;
    UINT32                InputAmount;
    
    Mode                  = MAIN_PAGE_MODE;
    Ldn = 0;
    ModifyValue = 0;
    CursorPosition.column = 0;
    CursorPosition.row = 0;
    InitializeArray(WriteBuffer);
  

    //
    // initialization and into the main page
    //
    gST->ConOut->ClearScreen(gST->ConOut);
    gST->ConOut->SetCursorPosition(gST->ConOut, 0, 0);
    gST->ConOut->EnableCursor(gST->ConOut, TRUE);
    

    //
    // choose mode loop
    //
    while (TRUE) {
      
      //
      // to change mode
      //
      ChangeMode:

      //
      // MAIN_PAGE_MODE
      // with up, down, F1(enter), Esc key response
      //
      if (Mode == MAIN_PAGE_MODE) {
        ShowMainPage(&CursorPosition);
        InputAmount = 1;
        Ldn = (UINT8)InputValue(WriteBuffer, &InputAmount);
        if (InputAmount == 0) {
          gST->ConOut->ClearScreen(gST->ConOut);
          goto Exit;

        } else {
          ShowSio(&CursorPosition, &Ldn);
          Mode = BRANCH_PAGE_MODE;
          goto ChangeMode;
        }
      }

      //
      // BRANCH_PAGE_MODE
      // with up, down, F1(enter), F2(home), Esc key response
      //
      if (Mode == BRANCH_PAGE_MODE) {
        while (TRUE) {
          gST->ConIn->ReadKeyStroke(gST->ConIn, &InputKey);

          if (InputKey.ScanCode == SCAN_ESC) {
            gST->ConOut->ClearScreen(gST->ConOut);
            goto Exit;
          }
          
          switch (InputKey.ScanCode) {

          case SCAN_F1:
            Mode = MAIN_PAGE_MODE;
            ShowMainPage(&CursorPosition);
            InitializeArray(WriteBuffer);
            goto ChangeMode;

          case SCAN_F2:
            InputAmount = 2;
            ModifyValue = InputValue(WriteBuffer, &InputAmount);
            if (InputAmount == 0) {
              ShowSio(&CursorPosition, &Ldn);
              InitializeArray(WriteBuffer);
              continue;
            }
            WriteSio(&CursorPosition, &Ldn, ModifyValue);
            ShowSio(&CursorPosition, &Ldn);
            continue;

          case SCAN_UP:
            CursorPosition.row--;
            if (CursorPosition.row < ResetPosition.row) {
              CursorPosition.row = ResetPosition.row;
            }
            gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);   
            ShowOffset(&CursorPosition); 
            continue;

          case SCAN_DOWN:
            CursorPosition.row++;
            if (CursorPosition.row > (ResetPosition.row + DownEdgeInterval)) {
              CursorPosition.row = (ResetPosition.row + DownEdgeInterval);
            }

            gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);
            ShowOffset(&CursorPosition);
            continue;
          
          case SCAN_RIGHT:
            CursorPosition.column += 3;
            if (CursorPosition.column > RightEdgeInterval) {
              CursorPosition.column = RightEdgeInterval;
            }
            gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);
            ShowOffset(&CursorPosition);
            continue;

          case SCAN_LEFT:
            CursorPosition.column -= 3;
            if (CursorPosition.column < LeftEdgeInterval) {
              CursorPosition.column = LeftEdgeInterval;
            }
            gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);
            ShowOffset(&CursorPosition);
            continue;
          }
        }
      }
    }

    //
    // to get out
    //
    Exit:

    Status = EFI_SUCCESS;

    return Status;
  }

  EFI_STATUS
  WriteSio (
    POSITION *CursorPosition,
    UINT8 *Ldn,
    UINT64 ModifyValue
    )
  {
    EFI_STATUS  Status;
    UINT8 AddressBuffer;
    UINT8 DataBuffer;
    EFI_CPU_IO2_PROTOCOL       *CpuIo2;

    Status = gBS->LocateProtocol (&gEfiCpuIo2ProtocolGuid, NULL, &CpuIo2);

    //
    // Unlock
    //
    AddressBuffer = Unlock;
    CpuIo2->Io.Write (
                  CpuIo2,
                  EfiCpuIoWidthUint8,
                  AddressPort,
                  1,
                  &AddressBuffer   
                  ); 
    CpuIo2->Io.Write (
                  CpuIo2,
                  EfiCpuIoWidthUint8,
                  AddressPort,
                  1,
                  &AddressBuffer   
                  ); 

    //
    // Select device
    //
    AddressBuffer = LdnReg;
    CpuIo2->Io.Write (
                  CpuIo2,
                  EfiCpuIoWidthUint8,
                  AddressPort,
                  1,
                  &AddressBuffer   
                  ); 

    AddressBuffer = *Ldn;               
    CpuIo2->Io.Write (
                  CpuIo2,
                  EfiCpuIoWidthUint8,
                  DataPort,
                  1,
                  &AddressBuffer   
                  );

    //
    // Write register
    //
    AddressBuffer = (UINT8)((CursorPosition->column - ResetPosition.column) / 3 + \
                            (CursorPosition->row - ResetPosition.row) * 16);
    CpuIo2->Io.Write (
                  CpuIo2,
                  EfiCpuIoWidthUint8,
                  AddressPort,
                  1,
                  &AddressBuffer   
                  );

    DataBuffer = (UINT8)ModifyValue;
    CpuIo2->Io.Write (
                  CpuIo2,
                  EfiCpuIoWidthUint8,
                  DataPort,
                  1,
                  &DataBuffer   
                  );
    
    if (AddressBuffer == LdnReg) {
      *Ldn = (UINT8)ModifyValue;
    }
    
    //
    // Lock
    //
    AddressBuffer = Lock;
    CpuIo2->Io.Write (
                  CpuIo2,
                  EfiCpuIoWidthUint8,
                  0x2E,
                  1,
                  &AddressBuffer   
                  ); 

    Status = EFI_SUCCESS;

    return Status;
  }

  EFI_STATUS
  ReadSio (
    POSITION *CursorPosition,
    UINT8 *Ldn
    )
  {
    EFI_STATUS  Status;
    UINT32 i;
    UINT8 AddressBuffer;
    UINT8 DataBuffer;
    EFI_CPU_IO2_PROTOCOL       *CpuIo2;

    Status = gBS->LocateProtocol (&gEfiCpuIo2ProtocolGuid, NULL, &CpuIo2);  

    //
    // Unlock
    //
    AddressBuffer = Unlock;
    CpuIo2->Io.Write (
                  CpuIo2,
                  EfiCpuIoWidthUint8,
                  AddressPort,
                  1,
                  &AddressBuffer   
                  ); 
    CpuIo2->Io.Write (
                  CpuIo2,
                  EfiCpuIoWidthUint8,
                  AddressPort,
                  1,
                  &AddressBuffer   
                  ); 

    //
    // Select device
    //
    AddressBuffer = LdnReg;
    Status = CpuIo2->Io.Write (
                          CpuIo2,
                          EfiCpuIoWidthUint8,
                          AddressPort,
                          1,
                          &AddressBuffer   
                          );
    if (EFI_ERROR(Status)) {
      gST->ConOut->ClearScreen(gST->ConOut);
      Print(L"%r\nPlease press F1 to home.", Status);
      gST->ConOut->EnableCursor(gST->ConOut, FALSE);
      return Status;
    } 

    AddressBuffer = *Ldn;               
    CpuIo2->Io.Write (
                  CpuIo2,
                  EfiCpuIoWidthUint8,
                  DataPort,
                  1,
                  &AddressBuffer   
                  );

    //
    // Show register
    //
    for (i = 0; i < MaxIndex; i++){
      AddressBuffer = (UINT8)i;
      CpuIo2->Io.Write (
                    CpuIo2,
                    EfiCpuIoWidthUint8,
                    AddressPort,
                    1,
                    &AddressBuffer   
                    );

      CpuIo2->Io.Read (
                    CpuIo2,
                    EfiCpuIoWidthUint8,
                    DataPort,
                    1,
                    &DataBuffer   
                    );

      if ((i % 16) == 0) {
        Print(L"%2.2x", DataBuffer);
      } else if ((i % 16) == 15) {
        Print(L"%3.2x\n", DataBuffer);
        CursorPosition->column = ResetPosition.column;
        CursorPosition->row++;
        gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition->column, CursorPosition->row);
      } else {
        Print(L"%3.2x", DataBuffer);
      }
    }

    //
    // Lock
    //
    AddressBuffer = Lock;
    CpuIo2->Io.Write (
                  CpuIo2,
                  EfiCpuIoWidthUint8,
                  AddressPort,
                  1,
                  &AddressBuffer   
                  ); 

    *CursorPosition = ResetPosition;
    gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition->column, CursorPosition->row);

    Status = EFI_SUCCESS;

    return Status;
  }

  VOID 
  SetMainPageAppearance (
    VOID
    )
  {
    gST->ConOut->ClearScreen(gST->ConOut);
    gST->ConOut->SetAttribute(gST->ConOut, EFI_WHITE | EFI_BACKGROUND_BLACK);

    Print(L"|====================================================|\n");
    Print(L"|                                                    |\n");
    Print(L"|                      09-SIO                        |\n");
    Print(L"|                                                    |\n");
    Print(L"|====================================================|\n");
    Print(L"|                                                    |\n");
    Print(L"|     Please input logical device number(0~f):       |\n");
    Print(L"|                                                    |\n");
    Print(L"|====================================================|\n");
    Print(L"| [Num]:Number            [Esc]:Escape               |\n");
    Print(L"|====================================================|\n");

    return;
  }

  VOID 
  SetRegisterPageAppearance (
    VOID
    )
  {
    gST->ConOut->ClearScreen(gST->ConOut);
    gST->ConOut->SetAttribute(gST->ConOut, EFI_WHITE | EFI_BACKGROUND_BLACK);

    Print(L"|                                                    |\n");
    Print(L"|====================================================|\n");
    Print(L"|  | 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F |\n");
    Print(L"|====================================================|\n");
    Print(L"|00|                                                 |\n");
    Print(L"|10|                                                 |\n");
    Print(L"|20|                                                 |\n");
    Print(L"|30|                                                 |\n");
    Print(L"|40|                                                 |\n");
    Print(L"|50|                                                 |\n");
    Print(L"|60|                                                 |\n");
    Print(L"|70|                                                 |\n");
    Print(L"|80|                                                 |\n");
    Print(L"|90|                                                 |\n");
    Print(L"|A0|                                                 |\n");
    Print(L"|B0|                                                 |\n");
    Print(L"|C0|                                                 |\n");
    Print(L"|D0|                                                 |\n");
    Print(L"|E0|                                                 |\n");
    Print(L"|F0|                                                 |\n");
    Print(L"|====================================================|\n");
    Print(L"| [F1]:Home               [F2]:Modify                |\n");
    Print(L"| [Arrow key]:Choose      [Esc]:Escape               |\n");
    Print(L"|====================================================|\n");

    return;
  }

  VOID 
  ShowMainPage (
    POSITION *CursorPosition
    )
  {
    SetMainPageAppearance();
    *CursorPosition = MainPage_ResetPosition;
    gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition->column, CursorPosition->row);
    gST->ConOut->EnableCursor(gST->ConOut, TRUE);

    return;
  }

  VOID 
  ShowRegisterPage (
    POSITION *CursorPosition
    )
  {
    SetRegisterPageAppearance();
    *CursorPosition = ResetPosition;
    gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition->column, CursorPosition->row);
    gST->ConOut->EnableCursor(gST->ConOut, TRUE);

    return;
  }

  VOID 
  ShowOffset (
    POSITION *CursorPosition
    )
  {
    POSITION PreviousPosition;
    UINT8 Offset;

    PreviousPosition = *CursorPosition;
    Offset = (UINT8)((CursorPosition->column - ResetPosition.column) / 3 + \
                            (CursorPosition->row - ResetPosition.row) * 16);

    *CursorPosition = OffsetPosition;
    gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition->column, CursorPosition->row);
    Print(L"%.2x", Offset);

    *CursorPosition = PreviousPosition;
    gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition->column, CursorPosition->row);

    return;
  }

  VOID 
  ShowTitle (
    POSITION *CursorPosition,
    UINT8 *Ldn
    )
  {
    POSITION PreviousPosition;
    PreviousPosition = *CursorPosition;

    *CursorPosition = TitlePosition;
    gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition->column, CursorPosition->row);

    switch(*Ldn) {

    case 0x0:
    case 0x4:
    case 0xf:
      Print(L"LDN:%2x (Reserved)", *Ldn);
      break;
    case 0x1:
      Print(L"LDN:%2x (Parallel Port)", *Ldn);
      break;
    case 0x2:
      Print(L"LDN:%2x (UARTA)", *Ldn);
      break;
    case 0x3:
      Print(L"LDN:%2x (UARTB)", *Ldn);
      break;
    case 0x5:
      Print(L"LDN:%2x (Keyboard Controller)", *Ldn);
      break;
    case 0x6:
      Print(L"LDN:%2x (CIR)", *Ldn);
      break;
    case 0x7:
      Print(L"LDN:%2x (GPIO0~GPIO7)", *Ldn);
      break;
    case 0x8:
      Print(L"LDN:%2x (PORT80 UART)", *Ldn);
      break;
    case 0x9:
      Print(L"LDN:%2x (GPIO8~9, GPIO0 Enhance, GPIO1 Enhance)", *Ldn);
      break;
    case 0xa:
      Print(L"LDN:%2x (ACPI)", *Ldn);
      break;
    case 0xb:
      Print(L"LDN:%2x (EC Space)", *Ldn);
      break;
    case 0xc:
      Print(L"LDN:%2x (RTC Timer)", *Ldn);
      break;
    case 0xd:
      Print(L"LDN:%2x (Deep Sleep, Power Fault)", *Ldn);
      break;
    case 0xe:
      Print(L"LDN:%2x (Fan Assign)", *Ldn);
      break;
    default:
      Print(L"LDN:%2x (Unknow)", *Ldn);
      break;
    }

    *CursorPosition = PreviousPosition;
    gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition->column, CursorPosition->row);
    return;
  }

  VOID 
  ShowSio (
    POSITION *CursorPosition,
    UINT8 *Ldn
    )
  {
    ShowRegisterPage(CursorPosition);
    ReadSio(CursorPosition, Ldn);
    ShowTitle(CursorPosition, Ldn);
    ShowOffset(CursorPosition);
    return;
  }

  UINT64
  InputValue (
    WRITE_BUFFER  *WriteBuffer,
    UINT32 *InputAmount
    )
  {
    EFI_INPUT_KEY         InputKey;
    INT32                WriteCount;
    UINT32 i;
    UINT64 Value;

    WriteCount = 0;
    Value = 0;

    while (TRUE) {
      gST->ConIn->ReadKeyStroke(gST->ConIn, &InputKey);

      if ((UINT32)WriteCount == *InputAmount) {

        for (i = 0; i < *InputAmount; i++) {
          Value |= WriteBuffer[i].value << ((*InputAmount-i-1) * 4);
        }

        return Value;
      }

      if (InputKey.ScanCode == SCAN_ESC) {
        *InputAmount = 0;
        return 0;
      }

      if (('a' <= InputKey.UnicodeChar && InputKey.UnicodeChar <= 'f')) {
        
        WriteBuffer[WriteCount].value = InputKey.UnicodeChar - 87;
        Print(L"%c", InputKey.UnicodeChar);
        WriteCount++;
        
        continue;

      } else if (('0' <= InputKey.UnicodeChar && InputKey.UnicodeChar <= '9')) {
        WriteBuffer[WriteCount].value = InputKey.UnicodeChar - 48;
        Print(L"%c", InputKey.UnicodeChar);
        WriteCount++;

        continue;
      } else if (InputKey.UnicodeChar == CHAR_BACKSPACE) {

        WriteCount--;
      
        if(WriteCount < 0) {
          WriteCount = 0;
        } 
      
        WriteBuffer[WriteCount].value = CHAR_NULL;
        Print(L"%c", InputKey.UnicodeChar);

        continue;
      }
    }
  }

  VOID 
  InitializeArray(
    WRITE_BUFFER *WriteBuffer
    )
  {
    UINT32 i;

    for (i = 0; i < 2; i++) {
      WriteBuffer[i].value = 0;
      WriteBuffer[i].position.column = 0;
      WriteBuffer[i].position.row = 0;
    }
  }
*/

/*// CPU_11 finish(v1)
  #include "_test.h"

  VOID
  Function_0 (
    VOID
    ); 

  VOID
  Function_1 (
    VOID
    );

  VOID
  Function_2 (
    VOID
    );

  DESCRIPTOR
  GetDescription(
    UINT8 IndexValue
    );

  VOID
  Function_3 (
    VOID
    );

  VOID
  Function_4 (
    VOID
    );

  VOID
  Function_5 (
    VOID
    );

  VOID
  Function_6 (
    VOID
    );

  VOID
  Function_7 (
    VOID
    );

  VOID
  Function_8 (
    VOID
    );

  VOID
  Function_9 (
    VOID
    );

  VOID
  Function_A (
    VOID
    );

  VOID
  Function_B (
    VOID
    );

  VOID
  Function_C (
    VOID
    );

  VOID
  Function_D (
    VOID
    );

  VOID
  Function_E0 (
    VOID
    );

  VOID
  Function_E1 (
    VOID
    );

  VOID
  Function_E2 (
    VOID
    );

  VOID
  Function_E3 (
    VOID
    );

  VOID
  Function_E4 (
    VOID
    );

  VOID
  ShowFullBrandString (
    VOID
    );

  VOID
  Function_E5 (
    VOID
    );

  VOID
  Function_E6 (
    VOID
    );

  VOID
  Function_E7 (
    VOID
    );

  VOID
  Function_E8 (
    VOID
    );

  VOID
  MsrRead(
    VOID
    );

  VOID
  MsrWrite(
    VOID
    );

  VOID 
  InitializeArray(
    WRITE_BUFFER *WriteBuffer
    );

  UINT64 
  Power (
    UINT64 Base, 
    UINT64 Index
    );

  UINT32 
  InputValue (
    WRITE_BUFFER *WriteBuffer, 
    POSITION *CursorPosition
    );

  VOID
  SetMainPageAppearance (
    VOID
    );

  VOID
  ShowMainPage (
    VOID
    );

  VOID
  SetBranchPageSupplementAppearance (
    VOID
    );

  EFI_STATUS
  EFIAPI
  UefiMain (
    IN EFI_HANDLE ImageHandle, 
    IN EFI_SYSTEM_TABLE *SystemTable
    )
  {
    EFI_STATUS            Status;
    EFI_INPUT_KEY         InputKey;

    ShowMainPage();

    //
    // choose loop
    //
    while (TRUE) {
      gST->ConIn->ReadKeyStroke(gST->ConIn, &InputKey);

      if (InputKey.ScanCode == SCAN_ESC) {
        gST->ConOut->ClearScreen(gST->ConOut);
        break;
      }

      if (InputKey.ScanCode == SCAN_F1) {
        gST->ConOut->ClearScreen(gST->ConOut);
        ShowMainPage();
        continue;
      }

      switch (InputKey.UnicodeChar) {
      
      case '0':
        Function_0();
        SetBranchPageSupplementAppearance();
        break;
      case '1':
        Function_1();
        SetBranchPageSupplementAppearance();
        break;
      case '2':
        Function_2();
        SetBranchPageSupplementAppearance();
        break;
      case '3':
        Function_3();
        SetBranchPageSupplementAppearance();
        break;
      case '4':
        Function_4();
        SetBranchPageSupplementAppearance();
        break;
      case '5':
        Function_5();
        SetBranchPageSupplementAppearance();
        break;
      case '6':
        Function_6();
        SetBranchPageSupplementAppearance();
        break;
      case '7':
        Function_7();
        SetBranchPageSupplementAppearance();
        break;
      case '8':
        Function_8();
        SetBranchPageSupplementAppearance();
        break;
      case '9':
        Function_9();
        SetBranchPageSupplementAppearance();
        break;
      case 'a':
        Function_A();
        SetBranchPageSupplementAppearance();
        break;
      case 'b':
        Function_B();
        SetBranchPageSupplementAppearance();
        break;
      case 'c':
        Function_C();
        SetBranchPageSupplementAppearance();
        break;
      case 'd':
        Function_D();
        SetBranchPageSupplementAppearance();
        break;
      case 'e':
        Function_E0();
        SetBranchPageSupplementAppearance();
        break;
      case 'f':
        Function_E1();
        SetBranchPageSupplementAppearance();
        break;
      case 'g':
        Function_E2();
        SetBranchPageSupplementAppearance();
        break;
      case 'h':
        Function_E3();
        SetBranchPageSupplementAppearance();
        break;
      case 'i':
        Function_E4();
        SetBranchPageSupplementAppearance();
        break;
      case 'j':
        Function_E5();
        SetBranchPageSupplementAppearance();
        break;
      case 'k':
        Function_E6();
        SetBranchPageSupplementAppearance();
        break;
      case 'l':
        Function_E7();
        SetBranchPageSupplementAppearance();
        break;
      case 'm':
        Function_E8();
        SetBranchPageSupplementAppearance();
        break; 
      case 'n':
        MsrRead();
        SetBranchPageSupplementAppearance();
        break; 
      case 'o':
        MsrWrite();
        SetBranchPageSupplementAppearance();
        break; 
      case 'p':
        ShowFullBrandString();
        SetBranchPageSupplementAppearance();
        break;
      }
    }

    Status = EFI_SUCCESS;

    return Status;
  }

  VOID
  Function_0 (
    VOID
    ) 
  {
    UINT32    Index;
    UINT32    Eax;
    UINT32    Ebx;
    UINT32    Ecx;
    UINT32    Edx;
    UINT32    ShiftBit;
    UINT32    i;
    
    gST->ConOut->ClearScreen(gST->ConOut);
    Print(L"CPUID Standard Function 0 - Vender-ID and Largest Standard Function\n\n");

    Index = 0;
    AsmCpuid (Index, &Eax, &Ebx, &Ecx, &Edx);
    gST->ConOut->SetAttribute(gST->ConOut, EFI_YELLOW | EFI_BACKGROUND_BLACK);
    Print(L"EAX: %.8x, EBX: %.8x, ECX: %.8x, EDX: %.8x\n\n", Eax, Ebx, Ecx, Edx);
    gST->ConOut->SetAttribute(gST->ConOut, EFI_WHITE | EFI_BACKGROUND_BLACK);

    //
    // eax store largest standard function
    //
    Print(L"Largest Standard Function: %x\n\n", Eax);

    //
    // vendor ID store order : ebx->edx->ecx
    //
    ShiftBit = 8;
    Print(L"Vender ID: ");
    for (i = 0; i < 4; i++) {
      Print(L"%c", (UINT8)(Ebx >> i * ShiftBit));    
    }
    for (i = 0; i < 4; i++) {
      Print(L"%c", (UINT8)(Edx >> i * ShiftBit));    
    }
    for (i = 0; i < 4; i++) {
      Print(L"%c", (UINT8)(Ecx >> i * ShiftBit));    
    }
    
    Print(L"\n");

    return;
  }

  VOID
  Function_1 (
    VOID
    )
  {
    UINT32    Index = 0;
    UINT32    Eax = 0;
    UINT32    Ebx = 0;
    UINT32    Ecx = 0;
    UINT32    Edx = 0;
    UINT32    ShiftBit;
    UINT32    GetBit;

    UINT8     Stepping;
    UINT8     Model;
    UINT8     Family;
    UINT8     ProcessorType;
    UINT8     ExtendedModel;
    UINT8     ExtendedFamily;
    UINT8     FamilyValue;
    UINT8     ModelValue;
    
    gST->ConOut->ClearScreen(gST->ConOut);
    Print(L"CPUID Standard Function 1 - Feature Information\n\n");

    Index = 1;
    AsmCpuid (Index, &Eax, &Ebx, &Ecx, &Edx);
    gST->ConOut->SetAttribute(gST->ConOut, EFI_YELLOW | EFI_BACKGROUND_BLACK);
    Print(L"EAX: %.8x, EBX: %.8x, ECX: %.8x, EDX: %.8x\n\n", Eax, Ebx, Ecx, Edx);
    gST->ConOut->SetAttribute(gST->ConOut, EFI_WHITE | EFI_BACKGROUND_BLACK);

    //
    // feature information
    //
    GetBit = 0xf; // [3:0]
    ShiftBit = 0;
    Stepping = (UINT8)((Eax >> ShiftBit) & GetBit);
    Print(L"Stepping       : 0x%.2x\n", Stepping);

    GetBit = 0xf; // [7:4]
    ShiftBit = 4;
    Model = (UINT8)((Eax >> ShiftBit) & GetBit);
    Print(L"Model          : 0x%.2x\n", Model);

    GetBit = 0xf; // [11:8]
    ShiftBit = 8;
    Family = (UINT8)((Eax >> ShiftBit) & GetBit);
    Print(L"Family         : 0x%.2x\n", Family);

    GetBit = 0x3; // [13:12]
    ShiftBit = 12;
    ProcessorType = (UINT8)((Eax >> ShiftBit) & GetBit);
    Print(L"Processor Type : 0x%.2x\n", ProcessorType);

    GetBit = 0xf; // [19:16]
    ShiftBit = 16;
    ExtendedModel = (UINT8)((Eax >> ShiftBit) & GetBit);
    Print(L"Extended Model : 0x%.2x\n", ExtendedModel);

    GetBit = 0xff; // [27:20]
    ShiftBit = 20;
    ExtendedFamily = (UINT8)((Eax >> ShiftBit) & GetBit);
    Print(L"Extended Family: 0x%.2x\n", ExtendedFamily);

    ModelValue = (ExtendedModel << 4 ) + Model;
    FamilyValue = ExtendedFamily + Family;
    Print(L"Model Value    : 0x%.2x\n", ModelValue);
    Print(L"Family Value   : 0x%.2x\n", FamilyValue);

    Print(L"Processor Type : ");
    switch (ProcessorType) {
    
    case 0:
      Print(L"Original OEM Processor\n");
      break;
    case 1:
      Print(L"OverDrive® Processor\n");
      break;
    case 2:
      Print(L"Dual Processor\n");
      break;
    case 3:
      Print(L"Intel reserved\n");
      break;
    }

    return;
  }

  VOID
  Function_2 (
    VOID
    ) 
  {
    UINT32     Index = 0;
    UINT32     Eax = 0;
    UINT32     Ebx = 0;
    UINT32     Ecx = 0;
    UINT32     Edx = 0;
    UINT8      CPUIDTimes;
    UINT32     i;
    UINT8      IndexValue;
    DESCRIPTOR Descriptor;
    
    gST->ConOut->ClearScreen(gST->ConOut);
    Print(L"CPUID Standard Function 2 - Cache Descriptors\n\n");

    Index = 2;
    AsmCpuid (Index, &Eax, &Ebx, &Ecx, &Edx);
    gST->ConOut->SetAttribute(gST->ConOut, EFI_YELLOW | EFI_BACKGROUND_BLACK);
    Print(L"EAX: %.8x, EBX: %.8x, ECX: %.8x, EDX: %.8x\n\n", Eax, Ebx, Ecx, Edx);
    gST->ConOut->SetAttribute(gST->ConOut, EFI_WHITE | EFI_BACKGROUND_BLACK);

    CPUIDTimes = (UINT8)Eax;

    for (i = 0; i < CPUIDTimes; i++) {
      if (((Eax >> 31) & 0x1) == 0) {
        IndexValue = (UINT8)(Eax);
        Descriptor = GetDescription(IndexValue);
        Print (L"Description: %a\n", Descriptor.Description);

        IndexValue = (UINT8)(Eax >> 8);
        Descriptor = GetDescription(IndexValue);
        Print (L"Description: %a\n", Descriptor.Description);

        IndexValue = (UINT8)(Eax >> 16);
        Descriptor = GetDescription(IndexValue);
        Print (L"Description: %a\n", Descriptor.Description);

        IndexValue = (UINT8)(Eax >> 24);
        Descriptor = GetDescription(IndexValue);
        Print (L"Description: %a\n", Descriptor.Description);
      }

      if (((Ebx >> 31) & 0x1) == 0) {
        IndexValue = (UINT8)(Ebx);
        Descriptor = GetDescription(IndexValue);
        Print (L"Description: %a\n", Descriptor.Description);

        IndexValue = (UINT8)(Ebx >> 8);
        Descriptor = GetDescription(IndexValue);
        Print (L"Description: %a\n", Descriptor.Description);

        IndexValue = (UINT8)(Ebx >> 16);
        Descriptor = GetDescription(IndexValue);
        Print (L"Description: %a\n", Descriptor.Description);

        IndexValue = (UINT8)(Ebx >> 24);
        Descriptor = GetDescription(IndexValue);
        Print (L"Description: %a\n", Descriptor.Description);
      }

      if (((Ecx >> 31) & 0x1) == 0) {
        IndexValue = (UINT8)(Ecx);
        Descriptor = GetDescription(IndexValue);
        Print (L"Description: %a\n", Descriptor.Description);

        IndexValue = (UINT8)(Ecx >> 8);
        Descriptor = GetDescription(IndexValue);
        Print (L"Description: %a\n", Descriptor.Description);

        IndexValue = (UINT8)(Ecx >> 16);
        Descriptor = GetDescription(IndexValue);
        Print (L"Description: %a\n", Descriptor.Description);

        IndexValue = (UINT8)(Ecx >> 24);
        Descriptor = GetDescription(IndexValue);
        Print (L"Description: %a\n", Descriptor.Description);
      }

      if (((Edx >> 31) & 0x1) == 0) {
        IndexValue = (UINT8)(Edx);
        Descriptor = GetDescription(IndexValue);
        Print (L"Description: %a\n", Descriptor.Description);

        IndexValue = (UINT8)(Edx >> 8);
        Descriptor = GetDescription(IndexValue);
        Print (L"Description: %a\n", Descriptor.Description);

        IndexValue = (UINT8)(Edx >> 16);
        Descriptor = GetDescription(IndexValue);
        Print (L"Description: %a\n", Descriptor.Description);

        IndexValue = (UINT8)(Edx >> 24);
        Descriptor = GetDescription(IndexValue);
        Print (L"Description: %a\n", Descriptor.Description);
      }

      Index = 2;
      AsmCpuid (Index, &Eax, &Ebx, &Ecx, &Edx);
    }

    return;
  }

  DESCRIPTOR
  GetDescription(
    UINT8 IndexValue
    )
  {
    UINT32 i;
    i = 0;

    while (Descriptors[i].Value != 0xff) {
      if (Descriptors[i].Value == IndexValue) {
        return Descriptors[i];
      } else {
        i++;
      }
    }

    return Descriptors[i];
  }

  VOID
  Function_3 (
    VOID
    )
  {
    UINT32    Index = 0;
    UINT32    Eax = 0;
    UINT32    Ebx = 0;
    UINT32    Ecx = 0;
    UINT32    Edx = 0;
    UINT32    ShiftBit;
    UINT32    GetBit;
    
    gST->ConOut->ClearScreen(gST->ConOut);
    Print(L"CPUID Standard Function 3 - Processor Serial Number\n\n");

    Index = 1;
    AsmCpuid (Index, &Eax, &Ebx, &Ecx, &Edx);

    //
    // check Function_1 edx bit 18
    // if it support(1) or not(0)
    //
    ShiftBit = 18;
    GetBit = 1;
    if (((Edx >> ShiftBit) & GetBit) == 1) {
      Index = 3;
      AsmCpuid (Index, &Eax, &Ebx, &Ecx, &Edx);
      gST->ConOut->SetAttribute(gST->ConOut, EFI_YELLOW | EFI_BACKGROUND_BLACK);
      Print(L"EAX: %.8x, EBX: %.8x, ECX: %.8x, EDX: %.8x\n\n", Eax, Ebx, Ecx, Edx);
      gST->ConOut->SetAttribute(gST->ConOut, EFI_WHITE | EFI_BACKGROUND_BLACK);
    } else {
      Print(L"PSN Unsupport!!\n");
    }

    return;
  }

  VOID
  Function_4 (
    VOID
    ) 
  {
    UINT32    Index;
    UINT32    SubIndex;
    UINT32    Eax;
    UINT32    Ebx;
    UINT32    Ecx;
    UINT32    Edx;
    UINT32    Count;

    UINT32    NumberOfProcessorCores;
    UINT32    CacheType;
    UINT32    CacheLevel;
    UINT32    WaysOfAssociativity;
    UINT32    PhysicalLinePartitions;
    UINT32    SystemCoherencyLineSize;
    UINT32    NumberOfSets;
    UINT32    CacheSize;
    
    gST->ConOut->ClearScreen(gST->ConOut);
    Print(L"CPUID Standard Function 4 - Processor Serial Number\n\n");

    Index = 4;
    SubIndex = 0;
    AsmCpuidEx (Index, SubIndex, &Eax, &Ebx, &Ecx, &Edx);

    //
    // number of processor cores ("plus 1") -> EAX[31:26] + 1
    //
    NumberOfProcessorCores = (Eax >> 26) & 0x3f;
    Print(L"The number of cores: %d\n\n", NumberOfProcessorCores + 1); 

    Index = 4;
    SubIndex = 0;
    Count = 0;
    while (TRUE) {
      AsmCpuidEx (Index, SubIndex, &Eax, &Ebx, &Ecx, &Edx);
      gST->ConOut->SetAttribute(gST->ConOut, EFI_YELLOW | EFI_BACKGROUND_BLACK);
      Print(L"EAX: %.8x, EBX: %.8x, ECX: %.8x, EDX: %.8x\n", Eax, Ebx, Ecx, Edx);
      gST->ConOut->SetAttribute(gST->ConOut, EFI_WHITE | EFI_BACKGROUND_BLACK);
      Print(L"The cache %d information: \n", Count);
      
      //
      // Cache Type -> EAX[4:0]
      //
      CacheType = Eax & 0x1f;
      Print(L"Cache Type : ");
      switch (CacheType) {

      case 0:
        Print(L"Null, no more caches\n");
        return;
      case 1:
        Print(L"Data Cache\n");
        break;
      case 2:
        Print(L"Instruction Cache\n");
        break;
      case 3:
        Print(L"Unified Cache\n");
        break;
      default:
        Print(L"Reserved\n");
        break;
      }

      //
      // Cache Level -> EAX[7:5]
      //
      CacheLevel = (Eax >> 5) & 0x7;
      Print(L"Cache Level: %d", CacheLevel);

      //
      // Ways of Associativity ("plus 1") -> EBX[31:22]
      //
      WaysOfAssociativity = (Ebx >> 22) & 0x3ff;
      Print(L"Ways of Associativity: %d\n", WaysOfAssociativity + 1);

      //
      // Physical Line partitions ("plus 1") -> EBX[21:12]
      //
      PhysicalLinePartitions = (Ebx >> 12) & 0x3ff;
      Print(L"Physical Line partitions  : %d\n", PhysicalLinePartitions + 1);

      //
      // System Coherency Line Size ("plus 1") -> EBX[11:0]
      //
      SystemCoherencyLineSize = Ebx & 0xfff;
      Print(L"System Coherency Line Size: %d\n", SystemCoherencyLineSize + 1);
      
      //
      // Number of Sets ("plus 1") -> ECX[31:0]
      //
      NumberOfSets = Ecx;
      Print(L"Number of Sets: %d\n", NumberOfSets + 1);

      //
      // Cache Size -> (Way + 1) * (Partitions + 1) * (Line_Size + 1)  * (Sets + 1)
      //
      CacheSize = (WaysOfAssociativity + 1) * (PhysicalLinePartitions + 1) * \
                  (SystemCoherencyLineSize + 1) * (NumberOfSets + 1);
      Print(L"Cache Size: %d\n\n", CacheSize); 

      //
      // continue to show other caches
      //
      SubIndex++;
      Count++;
    }

    return;
  }

  VOID
  Function_5 (
    VOID
    ) 
  {
    UINT32    Index;
    UINT32    Eax;
    UINT32    Ebx;
    UINT32    Ecx;
    UINT32    Edx;

    UINT32 SmallestMonitorLineSize;
    UINT32 LargestMonitorLineSize;
    UINT32 SupportForTreatingInterrupts;
    UINT32 ExtensionsSupported;
    UINT32 C0;
    UINT32 C1;
    UINT32 C2;
    UINT32 C3;
    UINT32 C4;

    gST->ConOut->ClearScreen(gST->ConOut);
    Print(L"CPUID Standard Function 5 - MONITOR / MWAIT Parameters\n\n");

    Index = 5;
    AsmCpuid (Index, &Eax, &Ebx, &Ecx, &Edx);
    gST->ConOut->SetAttribute(gST->ConOut, EFI_YELLOW | EFI_BACKGROUND_BLACK);
    Print(L"EAX: %.8x, EBX: %.8x, ECX: %.8x, EDX: %.8x\n\n", Eax, Ebx, Ecx, Edx);
    gST->ConOut->SetAttribute(gST->ConOut, EFI_WHITE | EFI_BACKGROUND_BLACK);
    
    //
    // Smallest monitor line size in bytes -> EAX[15:0]
    //
    SmallestMonitorLineSize = Eax & 0xffff;
    Print(L"Smallest monitor line size: %d (Byte)\n", SmallestMonitorLineSize);

    //
    // Largest monitor line size in bytes -> EBX[15:0]
    //
    LargestMonitorLineSize = Ebx & 0xffff;
    Print(L"Largest monitor line size : %d (Byte)\n", LargestMonitorLineSize);

    //
    // Support for treating interrupts as break-events for MWAIT -> ECX[1]
    //
    SupportForTreatingInterrupts = (Ecx >> 1) & 0x1;
    Print(L"Support for treating interrupts as break-events for MWAIT: %a\n", \
      SupportForTreatingInterrupts ? "Yes" : "No");

    //
    // MONITOR / MWAIT Extensions supported -> ECX[0]
    //
    ExtensionsSupported = Ecx & 0x1;
    Print(L"MONITOR / MWAIT Extensions supported: %a\n", ExtensionsSupported ? "Yes" : "No");

    //
    // Number of C0* sub-states supported using MONITOR / MWAIT -> EDX[3:0]
    //
    C0 = Edx & 0xf;
    Print(L"Number of C0* sub-states supported using MONITOR / MWAIT: %d\n", C0);

    //
    // Number of C1* sub-states supported using MONITOR / MWAIT -> EDX[7:4]
    //
    C1 = (Edx >> 4) & 0xf;
    Print(L"Number of C1* sub-states supported using MONITOR / MWAIT: %d\n", C1);

    //
    // Number of C2* sub-states supported using MONITOR / MWAIT -> EDX[11:8]
    //
    C2 = (Edx >> 8) & 0xf;
    Print(L"Number of C2* sub-states supported using MONITOR / MWAIT: %d\n", C2);

    //
    // Number of C3* sub-states supported using MONITOR / MWAIT -> EDX[15:12]
    //
    C3 = (Edx >> 12) & 0xf;
    Print(L"Number of C3* sub-states supported using MONITOR / MWAIT: %d\n", C3);

    //
    // Number of C4* sub-states supported using MONITOR / MWAIT -> EDX[19:16]
    //
    C4 = (Edx >> 16) & 0xf;
    Print(L"Number of C4* sub-states supported using MONITOR / MWAIT: %d\n", C4);

    return;
  }

  VOID
  Function_6 (
    VOID
    ) 
  {
    UINT32    Index;
    UINT32    Eax;
    UINT32    Ebx;
    UINT32    Ecx;
    UINT32    Edx;

    UINT32 DTS;
    UINT32 IntelTurboBoost;
    UINT32 ARAT;
    UINT32 PLN;
    UINT32 ECMD;
    UINT32 PTM;

    UINT32 NumberOfInterruptThresholds;
    
    UINT32 PerformanceEnergyBiasCapability;
    UINT32 ACNT2Capability;
    UINT32 HardwareCoordinationFeedbackCapability;

    gST->ConOut->ClearScreen(gST->ConOut);
    Print(L"CPUID Standard Function 6 - Digital Thermal Sensor and Power Management Parameters\n\n");

    Index = 6;
    AsmCpuid (Index, &Eax, &Ebx, &Ecx, &Edx);
    gST->ConOut->SetAttribute(gST->ConOut, EFI_YELLOW | EFI_BACKGROUND_BLACK);
    Print(L"EAX: %.8x, EBX: %.8x, ECX: %.8x, EDX: %.8x\n\n", Eax, Ebx, Ecx, Edx);
    gST->ConOut->SetAttribute(gST->ConOut, EFI_WHITE | EFI_BACKGROUND_BLACK);

    //
    // Digital Thermal Sensor (DTS) capability -> EAX[0]
    //
    DTS = Eax & 0x1;
    Print(L"Digital Thermal Sensor (DTS) capability: %a\n", DTS ? "Yes" : "No");

    //
    // Intel® Turbo Boost Technology capability -> EAX[1]
    //
    IntelTurboBoost = (Eax >> 1) & 0x1;
    Print(L"Intel Turbo Boost Technology capability: %a\n", IntelTurboBoost ? "Yes" : "No");

    //
    // Always Running APIC Timer (ARAT) capability -> EAX[2]
    //
    ARAT = (Eax >> 2) & 0x1;
    Print(L"Always Running APIC Timer (ARAT) capability: %a\n", ARAT ? "Yes" : "No");

    //
    // Power Limit Notification (PLN) capability -> EAX[4]
    //
    PLN = (Eax >> 4) & 0x1;
    Print(L"Power Limit Notification (PLN) capability  : %a\n", PLN ? "Yes" : "No");

    //
    // Extended Clock Modulation Duty (ECMD) capability -> EAX[5]
    //
    ECMD = (Eax >> 5) & 0x1;
    Print(L"Extended Clock Modulation Duty (ECMD) capability: %a\n", ECMD ? "Yes" : "No");

    //
    // Package Thermal Management (PTM) capability -> EAX[6]
    //
    PTM = (Eax >> 6) & 0x1;
    Print(L"Package Thermal Management (PTM) capability: %a\n", PTM ? "Yes" : "No");

    //
    // Number of Interrupt Thresholds -> EBX[3:0]
    //
    NumberOfInterruptThresholds = Ebx & 0xf;
    Print(L"Number of Interrupt Thresholds: %d\n", NumberOfInterruptThresholds);

    //
    // Performance-Energy Bias capability -> ECX[3]
    //
    PerformanceEnergyBiasCapability = (Ecx >> 3) & 0x1;
    Print(L"Performance-Energy Bias capability: %a\n", PerformanceEnergyBiasCapability ? "Yes" : "No");

    //
    // ACNT2 Capability -> ECX[1]
    //
    ACNT2Capability = (Eax >> 1) & 0x1;
    Print(L"ACNT2 Capability: %a\n", ACNT2Capability ? "Yes" : "No");

    //
    // Hardware Coordination Feedback capability -> ECX[0]
    //
    HardwareCoordinationFeedbackCapability = Ecx & 0x1;
    Print(L"Hardware Coordination Feedback capability: %a\n",       \
            HardwareCoordinationFeedbackCapability ? "Yes" : "No");

    return;
  }

  VOID
  Function_7 (
    VOID
    ) 
  {
    UINT32    Index;
    UINT32    SubIndex;
    UINT32    Eax;
    UINT32    Ebx;
    UINT32    Ecx;
    UINT32    Edx;

    UINT32 MaximumSupportedLeaf;

    UINT32 INVPCID;
    UINT32 EnhancedRepMovsbStosb;
    UINT32 SMEP;
    UINT32 FSGSBASE;

    gST->ConOut->ClearScreen(gST->ConOut);
    Print(L"CPUID Standard Function 7 - Structured Extended Feature Flags Enumeration\n\n");

    Index = 7;
    SubIndex = 0;
    AsmCpuidEx (Index, SubIndex, &Eax, &Ebx, &Ecx, &Edx);
    gST->ConOut->SetAttribute(gST->ConOut, EFI_YELLOW | EFI_BACKGROUND_BLACK);
    Print(L"EAX: %.8x, EBX: %.8x, ECX: %.8x, EDX: %.8x\n\n", Eax, Ebx, Ecx, Edx);
    gST->ConOut->SetAttribute(gST->ConOut, EFI_WHITE | EFI_BACKGROUND_BLACK);

    if ((Eax == 0) && (Ebx == 0) && (Ecx == 0) && (Edx == 0)) {
      Print(L"No sub-leaves are supported.\n");
    } else {
      //
      // Reports the maximum supported leaf 7 sub-leaf -> EAX[31:0]
      //
      MaximumSupportedLeaf = Eax;
      Print(L"Reports the maximum supported leaf 7 sub-leaf: %d\n", MaximumSupportedLeaf);

      //
      // INVPCID. If 1,
      // supports INVPCID instruction for system software that manages processcontext identifiers -> EBX[10]
      //
      INVPCID = (Ebx >> 10) & 0x1;
      Print(L"Supports INVPCID instruction: %a\n", INVPCID ? "Yes" : "No");

      //
      // Supports Enhanced REP MOVSB/STOSB if 1 -> EBX[9]
      //
      EnhancedRepMovsbStosb = (Ebx >> 9) & 0x1;
      Print(L"Supports Enhanced REP MOVSB/STOSB: %a\n", EnhancedRepMovsbStosb ? "Yes" : "No");

      //
      // SMEP. Supports Supervisor Mode Execution Protection if 1 -> EBX[7]
      //
      SMEP = (Ebx >> 7) & 0x1;
      Print(L"Supports Supervisor Mode Execution Protection: %a\n", SMEP ? "Yes" : "No");

      //
      // FSGSBASE. Supports RDFSBASE/RDGSBASE/WRFSBASE/WRGSBASE if 1 -> EBX[0]
      //
      FSGSBASE = Ebx & 0x1;
      Print(L"Supports RDFSBASE/RDGSBASE/WRFSBASE/WRGSBASE: %a\n", FSGSBASE ? "Yes" : "No");
    }

    return;
  }

  VOID
  Function_8 (
    VOID
    ) 
  {
    gST->ConOut->ClearScreen(gST->ConOut);
    Print(L"CPUID Standard Function 8 - Reserved\n\n");

    Print(L"This function is reserved\n");

    return;
  }

  VOID
  Function_9 (
    VOID
    ) 
  {
    UINT32    Index;
    UINT32    Eax;
    UINT32    Ebx;
    UINT32    Ecx;
    UINT32    Edx;

    UINT32 ValueOfPlatformDacCapMsrBits;

    gST->ConOut->ClearScreen(gST->ConOut);
    Print(L"CPUID Standard Function 9 - Direct Cache Access (DCA) Parameters\n\n");

    Index = 9;
    AsmCpuid (Index, &Eax, &Ebx, &Ecx, &Edx);
    gST->ConOut->SetAttribute(gST->ConOut, EFI_YELLOW | EFI_BACKGROUND_BLACK);
    Print(L"EAX: %.8x, EBX: %.8x, ECX: %.8x, EDX: %.8x\n\n", Eax, Ebx, Ecx, Edx);
    gST->ConOut->SetAttribute(gST->ConOut, EFI_WHITE | EFI_BACKGROUND_BLACK);

    //
    // Value of PLATFORM_DCA_CAP MSR Bits -> EAX[31:0]
    //
    ValueOfPlatformDacCapMsrBits = Eax;
    Print(L"Value of PLATFORM_DCA_CAP MSR Bits: %d\n", ValueOfPlatformDacCapMsrBits);

    return;
  }

  VOID
  Function_A (
    VOID
    ) 
  {
    UINT32    Index;
    UINT32    Eax;
    UINT32    Ebx;
    UINT32    Ecx;
    UINT32    Edx;

    UINT32 Length;
    UINT32 BitWidth;
    UINT32 Number;
    UINT32 VersionId;

    UINT32 BranchMispredictsRetired;
    UINT32 BranchInstructionsRetired;
    UINT32 LastLevelCacheMisses;
    UINT32 LastLevelCacheReferences;
    UINT32 ReferenceCycles;
    UINT32 InstructionsRetired;
    UINT32 CoreCycles;

    UINT32 NumberOfBitsInTheFixedCounters;
    UINT32 NumberOfFixedCounters;

    gST->ConOut->ClearScreen(gST->ConOut);
    Print(L"CPUID Standard Function A - Architectural Performance Monitor Features\n\n");

    Index = 0xa;
    AsmCpuid (Index, &Eax, &Ebx, &Ecx, &Edx);
    gST->ConOut->SetAttribute(gST->ConOut, EFI_YELLOW | EFI_BACKGROUND_BLACK);
    Print(L"EAX: %.8x, EBX: %.8x, ECX: %.8x, EDX: %.8x\n\n", Eax, Ebx, Ecx, Edx);
    gST->ConOut->SetAttribute(gST->ConOut, EFI_WHITE | EFI_BACKGROUND_BLACK);

    //
    // Length of EBX bit vector to enumerate architectural performance monitoring events -> EAX[31:24]
    //
    Length = (Eax >> 24) & 0xff;
    Print(L"Length of EBX bit vector to enumerate architectural performance monitoring events: %d\n", Length);

    //
    // Bit width of general-purpose performance monitoring counters -> EAX[23:16]
    //
    BitWidth = (Eax >> 16) & 0xff;
    Print(L"Bit width of general-purpose performance monitoring counters: %d\n", BitWidth);

    //
    // Number of general-purpose performance monitoring counters per logical processor -> EAX[15:8]
    //
    Number = (Eax >> 8) & 0xff;
    Print(L"Number of general-purpose performance monitoring counters per logical processor: %d\n", Number);

    //
    // Version ID of architectural performance monitoring -> EAX[7:0]
    //
    VersionId = Eax & 0xff;
    Print(L"Version ID of architectural performance monitoring: %d\n", VersionId);

    //
    // Branch Mispredicts Retired; 0 = supported -> EBX[6]
    //
    BranchMispredictsRetired = (Ebx >> 6) & 0x1;
    Print(L"Branch Mispredicts Retired : %a\n", BranchMispredictsRetired ? "Unsupported" : "Supported");

    //
    // Branch Instructions Retired; 0 = supported -> EBX[5]
    //
    BranchInstructionsRetired = (Ebx >> 5) & 0x1;
    Print(L"Branch Instructions Retired: %a\n", BranchInstructionsRetired ? "Unsupported" : "Supported");

    //
    // Last Level Cache Misses; 0 = supported -> EBX[4]
    //
    LastLevelCacheMisses = (Ebx >> 4) & 0x1;
    Print(L"Last Level Cache Misses: %a\n", LastLevelCacheMisses ? "Unsupported" : "Supported");

    //
    // Last Level Cache References; 0 = supported -> EBX[3]
    //
    LastLevelCacheReferences = (Ebx >> 3) & 0x1;
    Print(L"Last Level Cache References: %a\n", LastLevelCacheReferences ? "Unsupported" : "Supported");

    //
    // Reference Cycles; 0 = supported -> EBX[2]
    //
    ReferenceCycles = (Ebx >> 2) & 0x1;
    Print(L"Reference Cycles: %a\n", ReferenceCycles ? "Unsupported" : "Supported");

    //
    // Instructions Retired; 0 = supported -> EBX[1]
    //
    InstructionsRetired = (Ebx >> 1) & 0x1;
    Print(L"Instructions Retired: %a\n", InstructionsRetired ? "Unsupported" : "Supported");

    //
    // Core Cycles; 0 = supported -> EBX[0]
    //
    CoreCycles = Ebx & 0x1;
    Print(L"Core Cycles: %a\n", CoreCycles ? "Unsupported" : "Supported");

    //
    // Number of Bits in the Fixed Counters -> EDX[12:5]
    //
    NumberOfBitsInTheFixedCounters = (Edx >> 5) & 0xff;
    Print(L"Number of Bits in the Fixed Counters: %d\n", NumberOfBitsInTheFixedCounters);
    
    //
    // Number of Fixed Counters -> EDX[4:0]
    //
    NumberOfFixedCounters = Edx & 0x1f;
    Print(L"Number of Fixed Counters: %d\n", NumberOfFixedCounters);

    return;
  }

  VOID
  Function_B (
    VOID
    ) 
  {
    UINT32    Index;
    UINT32    SubIndex;
    UINT32    Eax;
    UINT32    Ebx;
    UINT32    Ecx;
    UINT32    Edx;

    UINT32    LevelType;
    UINT32    LevelNumber;

    gST->ConOut->ClearScreen(gST->ConOut);
    Print(L"CPUID Standard Function B - x2APIC Features / Processor Topology\n");  

    SubIndex = 0;
    while (TRUE) {
      Index = 0xb;
      AsmCpuidEx (Index, SubIndex, &Eax, &Ebx, &Ecx, &Edx);

      if ((Eax == 0) && (Ebx == 0)) {
        break;
      } else {

        gST->ConOut->SetAttribute(gST->ConOut, EFI_YELLOW | EFI_BACKGROUND_BLACK);
        Print(L"\nEAX: %.8x, EBX: %.8x, ECX: %.8x, EDX: %.8x", Eax, Ebx, Ecx, Edx);
        gST->ConOut->SetAttribute(gST->ConOut, EFI_WHITE | EFI_BACKGROUND_BLACK);

        if (SubIndex == 0) {
          Print(L"\nThread Level Processor Topology\n");
        } else if (SubIndex == 1) {
          Print(L"\nCore Level Processor Topology\n");
        } else if (SubIndex >= 2) {
          Print(L"\nCore Level Processor Topology\n");
        }

        //
        // Level Type (0=Invalid, 1=Thread, 2=Core) -> ECX[15:8]
        //
        LevelType = (Ecx >> 8) & 0xff;
        Print(L"Level Type  : ", LevelType);
        switch(LevelType) {

        case 0:
          Print(L"Invalid\n");
          break;

        case 1:
          Print(L"Thread\n");
          break;

        case 2:
          Print(L"Core\n");
          break;
        }

        //
        // Level Number -> ECX[7:0]
        //
        LevelNumber = Ecx & 0xff;
        Print(L"Level Number: %d\n", LevelNumber);

        SubIndex++;
      }
    }

    return;
  }

  VOID
  Function_C (
    VOID
    ) 
  {
    gST->ConOut->ClearScreen(gST->ConOut);
    Print(L"CPUID Standard Function C - Reserved\n\n");

    Print(L"This function is reserved\n");

    return;
  }

  VOID
  Function_D (
    VOID
    ) 
  {
    UINT32    Index;
    UINT32    SubIndex;
    UINT32    Eax;
    UINT32    Ebx;
    UINT32    Ecx;
    UINT32    Edx;

    UINT32    LowerValidBit;
    UINT32    MaximumSizeRequiredByEnabledFeatures;
    UINT32    MaximumSizeOfTheXsaveXrstorSaveArea;
    UINT32    UpperValidBit;

    UINT32    XSAVEOPT;

    UINT32    SizeOfTheSaveAreaForAnExtendedState;
    UINT32    TheOffsetInBytesOfTheSaveArea;

    gST->ConOut->ClearScreen(gST->ConOut);
    Print(L"CPUID Standard Function D - XSAVE Features");

    //
    // EAX = 0xd, ECX = 0
    //
    Index = 0xd;
    SubIndex = 0;
    AsmCpuidEx (Index, SubIndex, &Eax, &Ebx, &Ecx, &Edx);
    gST->ConOut->SetAttribute(gST->ConOut, EFI_YELLOW | EFI_BACKGROUND_BLACK);
    Print(L"\n\nEAX: %.8x, EBX: %.8x, ECX: %.8x, EDX: %.8x\n", Eax, Ebx, Ecx, Edx);
    gST->ConOut->SetAttribute(gST->ConOut, EFI_WHITE | EFI_BACKGROUND_BLACK);

    //
    // Reports the valid bit fields of the lower 32 bits of the XFEATURE_ENABLED_MASK register (XCR0) -> EAX[31:0]
    // If a bit is 0, the corresponding bit field in XCR0 is reserved.
    //
    LowerValidBit = Eax;
    Print(L"The valid bit fields of the lower 32 bits of the XCR0: 0x%.8x\n", LowerValidBit);

    //
    // Maximum size (bytes) required by enabled features in XFEATURE_ENABLED_MASK (XCR0) -> EBX[31:0]
    // May be different than ECX when features at the end of the save area are not enabled.
    //
    MaximumSizeRequiredByEnabledFeatures = Ebx;
    Print(L"Maximum size (bytes) required by enabled features in XFEATURE_ENABLED_MASK: 0x%.8x\n", \
            MaximumSizeRequiredByEnabledFeatures);

    //
    // Maximum size (bytes) of the XSAVE/XRSTOR save area required by all supported features in the processor,
    // i.e all the valid bit fields in XFEATURE_ENABLED_MASK -> ECX[31:0]
    // This includes the size needed for the XSAVE.HEADER.
    //
    MaximumSizeOfTheXsaveXrstorSaveArea = Ecx;
    Print(L"Maximum size (bytes) of the XSAVE/XRSTOR save area required by all supported features in the processor: 0x%.8x\n", \
            MaximumSizeOfTheXsaveXrstorSaveArea);

    //
    // Reports the valid bit fields of the upper 32 bits of the XFEATURE_ENABLED_MASK register (XCR0) -> EDX[31:0]
    // If a bit is 0, the corresponding bit field in XCR0 is reserved.
    //
    UpperValidBit = Edx;
    Print(L"The valid bit fields of the upper 32 bits of the XCR0: 0x%.8x\n", UpperValidBit);

    //
    // EAX = 0xd, ECX = 1
    //
    Index = 0xd;
    SubIndex = 1;
    AsmCpuidEx (Index, SubIndex, &Eax, &Ebx, &Ecx, &Edx);
    gST->ConOut->SetAttribute(gST->ConOut, EFI_YELLOW | EFI_BACKGROUND_BLACK);
    Print(L"\n\nEAX: %.8x, EBX: %.8x, ECX: %.8x, EDX: %.8x\n", Eax, Ebx, Ecx, Edx);
    gST->ConOut->SetAttribute(gST->ConOut, EFI_WHITE | EFI_BACKGROUND_BLACK);

    //
    // A value of 1 indicates the processor supports the XSAVEOPT instruction -> EAX[0]
    //
    XSAVEOPT = Eax & 0x1;
    Print(L"Supports the XSAVEOPT instruction: %a\n", XSAVEOPT ? "Yes" : "No");

    //
    // EAX = 0xd, ECX > 1
    //
    SubIndex = 2;
    while (TRUE) {
      Index = 0xd;
      AsmCpuidEx (Index, SubIndex, &Eax, &Ebx, &Ecx, &Edx);

      if ((Eax == 0) && (Ebx == 0)) {
        break;
      } else {
        gST->ConOut->SetAttribute(gST->ConOut, EFI_YELLOW | EFI_BACKGROUND_BLACK);
        Print(L"\n\nEAX: %.8x, EBX: %.8x, ECX: %.8x, EDX: %.8x\n", Eax, Ebx, Ecx, Edx);
        gST->ConOut->SetAttribute(gST->ConOut, EFI_WHITE | EFI_BACKGROUND_BLACK);

        //
        // The size in bytes of the save area for an extended state feature associated with a valid sub-leaf index,
        // n. Each valid sub-leaf index maps to a valid bit in the XFEATURE_ENABLED_MASK register (XCR0) starting 
        // at bit position 2 -> EAX[31:0]
        // This field reports 0 if the sub-leaf index, n, is invalid.
        //
        SizeOfTheSaveAreaForAnExtendedState = Eax;
        Print(L"The size in bytes of the save area for an extended state feature: 0x%.8x\n", \
                SizeOfTheSaveAreaForAnExtendedState);

        //
        // The offset in bytes of the save area from the beginning of the XSAVE/XRSTOR area -> EBX[31:0]
        // This field reports 0 if the sub-leaf index, n, is invalid.
        //
        TheOffsetInBytesOfTheSaveArea = Ebx;
        Print(L"The offset in bytes of the save area from the beginning of the XSAVE/XRSTOR area: 0x%.8x\n", \
                TheOffsetInBytesOfTheSaveArea);

        SubIndex++;
      }
    }  

    return;
  }

  VOID
  Function_E0 (
    VOID
    )
  {
    UINT32    Index;
    UINT32    Eax;
    UINT32    Ebx;
    UINT32    Ecx;
    UINT32    Edx;

    UINT32    LargestExtendedFunctionNumber;

    gST->ConOut->ClearScreen(gST->ConOut);
    Print(L"CPUID Extended Function 0 (E) - Largest Extended Function\n\n");

    Index = 0x80000000;
    AsmCpuid (Index, &Eax, &Ebx, &Ecx, &Edx);
    gST->ConOut->SetAttribute(gST->ConOut, EFI_YELLOW | EFI_BACKGROUND_BLACK);
    Print(L"EAX: %.8x, EBX: %.8x, ECX: %.8x, EDX: %.8x\n\n", Eax, Ebx, Ecx, Edx);
    gST->ConOut->SetAttribute(gST->ConOut, EFI_WHITE | EFI_BACKGROUND_BLACK);

    //
    // Largest extended function number supported -> EAX[31:0]
    //
    LargestExtendedFunctionNumber = Eax;
    Print(L"Largest extended function: %x\n", LargestExtendedFunctionNumber);

    return;
  }

  VOID
  Function_E1 (
    VOID
    )
  {
    UINT32    Index;
    UINT32    Eax;
    UINT32    Ebx;
    UINT32    Ecx;
    UINT32    Edx;

    UINT32    LahfSahf;

    UINT32    Intel64;
    UINT32    RDTSCP;
    UINT32    OneGbPages;
    UINT32    XdBit;
    UINT32    SyscallSysret;

    gST->ConOut->ClearScreen(gST->ConOut);
    Print(L"CPUID Extended Function 1 (F) - Extended Feature Bits\n\n");

    Index = 0x80000001;
    AsmCpuid (Index, &Eax, &Ebx, &Ecx, &Edx);
    gST->ConOut->SetAttribute(gST->ConOut, EFI_YELLOW | EFI_BACKGROUND_BLACK);
    Print(L"EAX: %.8x, EBX: %.8x, ECX: %.8x, EDX: %.8x\n\n", Eax, Ebx, Ecx, Edx);
    gST->ConOut->SetAttribute(gST->ConOut, EFI_WHITE | EFI_BACKGROUND_BLACK);

    //
    // LAHF / SAHF -> ECX[0]
    //
    LahfSahf = Ecx & 0x1;
    Print(L"LAHF / SAHF: %a\n", LahfSahf ? "Supported" : "Unsupported");

    //
    // Intel® 64 -> EDX[29]
    //
    Intel64 = (Edx >> 29) & 0x1;
    Print(L"The processor supports Intel 64 Architecture extensions to the IA-32 Architecture: %a\n", 
            Intel64 ? "Yes" : "No");

    //
    // RDTSCP -> EDX[27]
    //
    RDTSCP = (Edx >> 27) & 0x1;
    Print(L"RDTSCP: %a\n", RDTSCP ? "Supported" : "Unsupported");

    //
    // 1 GB Pages -> EDX[26]
    //
    OneGbPages = (Edx >> 26) & 0x1;
    Print(L"The processor supports 1-GB pages: %a\n", OneGbPages ? "Yes" : "No");

    //
    // XD Bit -> EDX[20]
    //
    XdBit = (Edx >> 20) & 0x1;
    Print(L"Execution Disable Bit: %a\n", XdBit ? "Supported" : "Unsupported");
    
    //
    // SYSCALL / SYSRET -> EDX[11]
    //
    SyscallSysret = (Edx >> 11) & 0x1;
    Print(L"The processor supports the SYSCALL and SYSRET instructions: %a\n", SyscallSysret ? "Yes" : "No");

    return;
  }

  VOID
  Function_E2 (
    VOID
    )
  {
    UINT32    Index;
    UINT32    Eax;
    UINT32    Ebx;
    UINT32    Ecx;
    UINT32    Edx;
    UINT32    i;
    UINT32    ShiftBit;

    ShiftBit = 8;

    gST->ConOut->ClearScreen(gST->ConOut);
    Print(L"CPUID Extended Function 2 (G) - Processor Brand String\n\n");

    Index = 0x80000002;
    AsmCpuid (Index, &Eax, &Ebx, &Ecx, &Edx);
    gST->ConOut->SetAttribute(gST->ConOut, EFI_YELLOW | EFI_BACKGROUND_BLACK);
    Print(L"EAX: %.8x, EBX: %.8x, ECX: %.8x, EDX: %.8x\n\n", Eax, Ebx, Ecx, Edx);
    gST->ConOut->SetAttribute(gST->ConOut, EFI_WHITE | EFI_BACKGROUND_BLACK);
    
    Print(L"Processor Name Part1: "); 

    for (i = 0; i < 4; i++) {
      Print(L"%c", (UINT8)(Eax >> ShiftBit * i));
    }
    for (i = 0; i < 4; i++) {
      Print(L"%c", (UINT8)(Ebx >> ShiftBit * i));
    }
    for (i = 0; i < 4; i++) {
      Print(L"%c", (UINT8)(Ecx >> ShiftBit * i));
    }
    for (i = 0; i < 4; i++) {
      Print(L"%c", (UINT8)(Edx >> ShiftBit * i));
    }

    Print(L"\n");

    return;
  }

  VOID
  Function_E3 (
    VOID
    )
  {
    UINT32    Index;
    UINT32    Eax;
    UINT32    Ebx;
    UINT32    Ecx;
    UINT32    Edx;
    UINT32    i;
    UINT32    ShiftBit;

    ShiftBit = 8;

    gST->ConOut->ClearScreen(gST->ConOut);
    Print(L"CPUID Extended Function 3 (H) - Processor Brand String\n\n");

    Index = 0x80000003;
    AsmCpuid (Index, &Eax, &Ebx, &Ecx, &Edx);
    gST->ConOut->SetAttribute(gST->ConOut, EFI_YELLOW | EFI_BACKGROUND_BLACK);
    Print(L"EAX: %.8x, EBX: %.8x, ECX: %.8x, EDX: %.8x\n\n", Eax, Ebx, Ecx, Edx);
    gST->ConOut->SetAttribute(gST->ConOut, EFI_WHITE | EFI_BACKGROUND_BLACK);
    
    Print(L"Processor Name Part2: "); 

    for (i = 0; i < 4; i++) {
      Print(L"%c", (UINT8)(Eax >> ShiftBit * i));
    }
    for (i = 0; i < 4; i++) {
      Print(L"%c", (UINT8)(Ebx >> ShiftBit * i));
    }
    for (i = 0; i < 4; i++) {
      Print(L"%c", (UINT8)(Ecx >> ShiftBit * i));
    }
    for (i = 0; i < 4; i++) {
      Print(L"%c", (UINT8)(Edx >> ShiftBit * i));
    }

    Print(L"\n");

    return;
  }

  VOID
  Function_E4 (
    VOID
    )
  {
    UINT32    Index;
    UINT32    Eax;
    UINT32    Ebx;
    UINT32    Ecx;
    UINT32    Edx;
    UINT32    i;
    UINT32    ShiftBit;

    ShiftBit = 8;

    gST->ConOut->ClearScreen(gST->ConOut);
    Print(L"CPUID Extended Function 4 (I) - Processor Brand String\n\n");

    Index = 0x80000004;
    AsmCpuid (Index, &Eax, &Ebx, &Ecx, &Edx);
    gST->ConOut->SetAttribute(gST->ConOut, EFI_YELLOW | EFI_BACKGROUND_BLACK);
    Print(L"EAX: %.8x, EBX: %.8x, ECX: %.8x, EDX: %.8x\n\n", Eax, Ebx, Ecx, Edx);
    gST->ConOut->SetAttribute(gST->ConOut, EFI_WHITE | EFI_BACKGROUND_BLACK);
    
    Print(L"Processor Name Part3: "); 

    for (i = 0; i < 4; i++) {
      Print(L"%c", (UINT8)(Eax >> ShiftBit * i));
    }
    for (i = 0; i < 4; i++) {
      Print(L"%c", (UINT8)(Ebx >> ShiftBit * i));
    }
    for (i = 0; i < 4; i++) {
      Print(L"%c", (UINT8)(Ecx >> ShiftBit * i));
    }
    for (i = 0; i < 4; i++) {
      Print(L"%c", (UINT8)(Edx >> ShiftBit * i));
    }

    Print(L"\n");

    return;
  }

  VOID
  ShowFullBrandString (
    VOID
    )
  {
    UINT32    Index;
    UINT32    Eax;
    UINT32    Ebx;
    UINT32    Ecx;
    UINT32    Edx;
    UINT32    i;
    UINT32    ShiftBit;

    ShiftBit = 8;

    gST->ConOut->ClearScreen(gST->ConOut);
    Print(L"Full Processor Brand String\n\n");

    for (Index = 0x80000002; Index <= 0x80000004; Index++) {
      AsmCpuid (Index, &Eax, &Ebx, &Ecx, &Edx);

      for (i = 0; i < 4; i++) {
        Print(L"%c", (UINT8)(Eax >> ShiftBit * i));
      }
      for (i = 0; i < 4; i++) {
        Print(L"%c", (UINT8)(Ebx >> ShiftBit * i));
      }
      for (i = 0; i < 4; i++) {
        Print(L"%c", (UINT8)(Ecx >> ShiftBit * i));
      }
      for (i = 0; i < 4; i++) {
        Print(L"%c", (UINT8)(Edx >> ShiftBit * i));
      }
    }

    Print(L"\n");

    return;
  }

  VOID
  Function_E5 (
    VOID
    )
  {
    gST->ConOut->ClearScreen(gST->ConOut);
    Print(L"CPUID Extended Function 5 (J) - Reserved\n\n");

    Print(L"This function is reserved\n");

    return;
  }

  VOID
  Function_E6 (
    VOID
    )
  {
    UINT32    Index;
    UINT32    Eax;
    UINT32    Ebx;
    UINT32    Ecx;
    UINT32    Edx;

    UINT32 CacheSize;
    UINT32 CacheAssociativity;
    UINT32 CacheLineSize;

    gST->ConOut->ClearScreen(gST->ConOut);
    Print(L"CPUID Extended Function 6 (K) - Extended L2 Cache Features\n\n");

    Index = 0x80000006;
    AsmCpuid (Index, &Eax, &Ebx, &Ecx, &Edx);
    gST->ConOut->SetAttribute(gST->ConOut, EFI_YELLOW | EFI_BACKGROUND_BLACK);
    Print(L"EAX: %.8x, EBX: %.8x, ECX: %.8x, EDX: %.8x\n\n", Eax, Ebx, Ecx, Edx);
    gST->ConOut->SetAttribute(gST->ConOut, EFI_WHITE | EFI_BACKGROUND_BLACK);

    //
    // L2 Cache size described in 1-KB units -> ECX[31:16]
    //
    CacheSize = (Ecx >> 16) & 0xffff;
    Print(L"L2 Cache size: %d (KB)\n", CacheSize);


    //
    // L2 Cache Associativity -> ECX[15:12]
    //
    CacheAssociativity = (Ecx >> 12) & 0xf;
    Print(L"L2 Cache Associativity: ");
    switch (CacheAssociativity) {
    
    case 0x0:
      Print(L"Disabled\n");
      break;
    case 0x1:
      Print(L"Direct mapped\n");
      break;
    case 0x2:
      Print(L"2-Way\n");
      break;
    case 0x4:
      Print(L"4-Way\n");
      break;
    case 0x6:
      Print(L"8-Way\n");
      break;
    case 0x8:
      Print(L"16-Way\n");
      break;
    case 0xf:
      Print(L"Fully associative\n");
      break;
    }

    //
    // L2 Cache Line Size in bytes -> ECX[7:0]
    //
    CacheLineSize = Ecx & 0xff;
    Print(L"L2 Cache Line size: %d (Byte)\n", CacheLineSize);

    return;
  }

  VOID
  Function_E7 (
    VOID
    )
  {
    UINT32    Index;
    UINT32    Eax;
    UINT32    Ebx;
    UINT32    Ecx;
    UINT32    Edx;

    UINT32    TscInvariance;

    gST->ConOut->ClearScreen(gST->ConOut);
    Print(L"CPUID Extended Function 7 (L) - Advanced Power Management\n\n");

    Index = 0x80000007;
    AsmCpuid (Index, &Eax, &Ebx, &Ecx, &Edx);
    gST->ConOut->SetAttribute(gST->ConOut, EFI_YELLOW | EFI_BACKGROUND_BLACK);
    Print(L"EAX: %.8x, EBX: %.8x, ECX: %.8x, EDX: %.8x\n\n", Eax, Ebx, Ecx, Edx);
    gST->ConOut->SetAttribute(gST->ConOut, EFI_WHITE | EFI_BACKGROUND_BLACK);

    //
    // TSC Invariance -> EDX[8]
    //
    TscInvariance = (Edx >> 8) & 0x1;
    Print(L"TSC Invariance: %a\n", TscInvariance ? "Available" : "Not available");

    return;
  }

  VOID
  Function_E8 (
    VOID
    )
  {
    UINT32    Index;
    UINT32    Eax;
    UINT32    Ebx;
    UINT32    Ecx;
    UINT32    Edx;

    UINT32 VirtualAddressSize;
    UINT32 PhysicalAddressSize;

    gST->ConOut->ClearScreen(gST->ConOut);
    Print(L"CPUID Extended Function 8 (M) - Virtual and Physical Address Sizes\n\n");

    Index = 0x80000008;
    AsmCpuid (Index, &Eax, &Ebx, &Ecx, &Edx);
    gST->ConOut->SetAttribute(gST->ConOut, EFI_YELLOW | EFI_BACKGROUND_BLACK);
    Print(L"EAX: %.8x, EBX: %.8x, ECX: %.8x, EDX: %.8x\n\n", Eax, Ebx, Ecx, Edx);
    gST->ConOut->SetAttribute(gST->ConOut, EFI_WHITE | EFI_BACKGROUND_BLACK);

    //
    // Virtual Address Size -> EAX[15:8]
    //
    VirtualAddressSize = (Eax >> 8) & 0xff;
    Print(L"Virtual Address Size : %d (bits)\n", VirtualAddressSize);

    //
    // Physical Address Size -> EAX[7:0]
    //
    PhysicalAddressSize = Eax & 0xff;
    Print(L"Physical Address Size: %d (bits)\n", PhysicalAddressSize);

    return;
  }

  VOID
  MsrRead(
    VOID
    )
  {
    POSITION              CursorPosition;
    WRITE_BUFFER          WriteBuffer[InputAmount];
    UINT64                MsrValue;
    UINT32                AddressValue;

    InitializeArray(WriteBuffer);
    gST->ConOut->ClearScreen(gST->ConOut);
    gST->ConOut->EnableCursor(gST->ConOut, TRUE);

    Print(L"Model Specific Registers (MSR) Read (N)\n\n");
    Print(L"Please input the MSR address: 0x");

    AddressValue = InputValue(WriteBuffer, &CursorPosition);
    MsrValue = AsmReadMsr64(AddressValue);

    Print(L"\nEDX: %.8x, EAX: %.8x\n", (UINT32)(MsrValue >> 32), (UINT32)MsrValue);
    gST->ConOut->EnableCursor(gST->ConOut, FALSE);

    return;
  }

  VOID 
  InitializeArray(
    WRITE_BUFFER *WriteBuffer
    )
  {
    UINT32 i;

    for (i = 0; i < InputAmount; i++) {
      WriteBuffer[i].value = 0;
      WriteBuffer[i].position.column = 0;
      WriteBuffer[i].position.row = 0;
    }
  }

  UINT64 Power (
    UINT64 Base,
    UINT64 Index
    )
  {  
    if (Index == 0) {
      return 1;
    } else {
      return (Base * Power(Base, Index-1));
    }
  }

  UINT32 
  InputValue (
    WRITE_BUFFER *WriteBuffer, 
    POSITION *CursorPosition
    )
  {
    EFI_INPUT_KEY        InputKey;
    INT32                WriteCount;
    UINT32               Value, i;

    WriteCount = 0;
    Value = 0;

    while (TRUE) {
      gST->ConIn->ReadKeyStroke(gST->ConIn, &InputKey);

      if (WriteCount >= InputAmount) {
        for (i = 0; i < (UINT32)WriteCount; i++) {
          Value += (UINT32)(WriteBuffer[i].value * Power((UINT64)0x10, (UINT64)(WriteCount-i-1))); 
        }

        return Value;
      }

      switch(InputKey.UnicodeChar){
      case CHAR_NULL:
        continue;
      
      case CHAR_CARRIAGE_RETURN:
        for (i = 0; i < (UINT32)WriteCount; i++) {
          Value += (UINT32)(WriteBuffer[i].value * Power((UINT64)0x10, (UINT64)(WriteCount-i-1)));            
        }

        return Value;
      
      case CHAR_BACKSPACE:
        WriteCount--;
        if (WriteCount < 0) {
          WriteCount = 0;
          continue;
        }
        WriteBuffer[WriteCount].value = CHAR_NULL;
        Print(L"%c", InputKey.UnicodeChar); 
        
        continue;

      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
        WriteBuffer[WriteCount].value = InputKey.UnicodeChar - 48;
        Print(L"%c", InputKey.UnicodeChar);
        WriteCount++;
        continue;
      
      case 'a':
      case 'b':
      case 'c':
      case 'd':
      case 'e':
      case 'f':
        WriteBuffer[WriteCount].value = InputKey.UnicodeChar - 87;
        Print(L"%c", InputKey.UnicodeChar);
        WriteCount++;
        continue;
      }
    }
  }

  VOID
  MsrWrite(
    VOID
    )
  {
    POSITION              CursorPosition;
    WRITE_BUFFER          WriteBuffer[InputAmount];
    UINT64                MsrValue;
    UINT64                WriteValue;
    UINT32                AddressValue;
    UINT64                EaxValue;  
    UINT64                EdxValue;

    InitializeArray(WriteBuffer);
    gST->ConOut->ClearScreen(gST->ConOut);
    gST->ConOut->EnableCursor(gST->ConOut, TRUE);
    // (O)
    Print(L"Model Specific Registers (MSR) Read\n\n");
    Print(L"Please input the MSR address: 0x");
    AddressValue = InputValue(WriteBuffer, &CursorPosition);
    MsrValue = AsmReadMsr64(AddressValue);

    Print(L"Original MSR Value...\n");
    Print(L"EDX: %.8x, EAX: %.8x\n\n", (UINT32)(MsrValue >> 32), (UINT32)MsrValue);

    Print(L"Please input the MSR EDX value: 0x");
    EdxValue = InputValue(WriteBuffer, &CursorPosition);
    
    InitializeArray(WriteBuffer);
    Print(L"\n");

    Print(L"Please input the MSR EAX value: 0x");
    EaxValue = InputValue(WriteBuffer, &CursorPosition);

    WriteValue = EaxValue | (EdxValue << 32);

    AsmWriteMsr64(AddressValue, WriteValue);
    gST->ConOut->EnableCursor(gST->ConOut, FALSE);

    return;
  }

  VOID
  SetMainPageAppearance (
    VOID
    )
  {
    gST->ConOut->SetAttribute(gST->ConOut, EFI_YELLOW | EFI_BACKGROUND_BLACK);
    Print(L"11-CPU (CPUID & MSR)\n\n");
    gST->ConOut->SetAttribute(gST->ConOut, EFI_WHITE | EFI_BACKGROUND_BLACK);

    Print(L"  0. CPUID Function 0\n");
    Print(L"  1. CPUID Function 1\n");
    Print(L"  2. CPUID Function 2\n");
    Print(L"  3. CPUID Function 3\n");
    Print(L"  4. CPUID Function 4\n");
    Print(L"  5. CPUID Function 5\n");
    Print(L"  6. CPUID Function 6\n");
    Print(L"  7. CPUID Function 7\n");
    Print(L"  8. CPUID Function 8\n");
    Print(L"  9. CPUID Function 9\n");
    Print(L"  A. CPUID Function A\n");
    Print(L"  B. CPUID Function B\n");
    Print(L"  C. CPUID Function C\n");
    Print(L"  D. CPUID Function D\n");
    Print(L"  E. CPUID Extended Function 0x80000000\n");
    Print(L"  F. CPUID Extended Function 0x80000001\n");
    Print(L"  G. CPUID Extended Function 0x80000002\n");
    Print(L"  H. CPUID Extended Function 0x80000003\n");
    Print(L"  I. CPUID Extended Function 0x80000004\n");
    Print(L"  J. CPUID Extended Function 0x80000005\n");
    Print(L"  K. CPUID Extended Function 0x80000006\n");
    Print(L"  L. CPUID Extended Function 0x80000007\n");
    Print(L"  M. CPUID Extended Function 0x80000008\n");
    Print(L"  N. MSR Read\n");
    Print(L"  O. MSR Write\n");
    Print(L"  P. Show Whole Brand String\n");

    Print(L"\n[Opt]:Option   [Esc]:Escape\n");
  }

  VOID
  ShowMainPage (
    VOID
    )
  {
    gST->ConOut->ClearScreen(gST->ConOut);
    gST->ConOut->SetCursorPosition(gST->ConOut, 0, 0);
    gST->ConOut->EnableCursor(gST->ConOut, FALSE);

    SetMainPageAppearance();
  }

  VOID
  SetBranchPageSupplementAppearance (
    VOID
    )
  {
    Print(L"\n[F1]:Home   [Opt]:Option   [Esc]:Escape\n");
  }
*/

/*// MemoryUtility_12(?)
  #include <Uefi.h>
  #include <Library/UefiLib.h>
  #include <Library/UefiApplicationEntryPoint.h>
  #include <Library/UefiBootServicesTableLib.h>

  #define MAIN_PAGE_MODE   0
  #define BRANCH_PAGE_MODE 1
  #define GET_SIZE_MODE    2
  #define GET_ADDR_MODE    3
  #define WRITE_MODE       4
  #define SHOW_MODE        5
  #define ERROR_MODE       6

  typedef struct {
    INT16 column;         /// cursor column
    INT16 row;            /// cursor row
  } POSITION;

  typedef struct {
    UINT64    value;      /// write value
    POSITION  position;   /// cursor position
  } WRITE_BUFFER;

  VOID SetMainPageAppearance(VOID);
  VOID SetAllocateTypePageAppearance(VOID);
  VOID SetMemoryTypePageAppearance(VOID);  
  VOID SetGetSizePageAppearance(VOID); 
  VOID SetGetAddressPageAppearance(VOID);  
  VOID SetMemorySettingPageAppearance(VOID); 
  VOID SetRegisterPageAppearance(VOID);


  VOID ResetCursorPosition(POSITION *CursorPosition);
  VOID ShowMainPage(POSITION *CursorPosition);
  VOID JudgeFontColor(UINT8 Buffer);

  UINT64 Power (UINT64 Number, UINT64 Time);

  const POSITION  MainPage_ResetPosition           = {15, 5};
  const POSITION  AllocateTypePage_ResetPosition   = {15, 5};
  const POSITION  MemoryTypePage_ResetPosition     = {15, 5};
  const POSITION  MemorySettingPage_ResetPosition  = {5, 6};
  const POSITION  MemorySettingWrite_ResetPosition = {33, 6};
  const POSITION  RegistPage_ResetPosition         = {5, 4};
  const POSITION  ShowAddress_ResetPosition        = {2, 3};


  EFI_STATUS
  EFIAPI
  UefiMain (
    IN EFI_HANDLE ImageHandle, 
    IN EFI_SYSTEM_TABLE *SystemTable
    )
  {
    EFI_STATUS            Status;
    EFI_INPUT_KEY         InputKey;
    POSITION              CursorPosition;
    UINT8                 AllBranchPage;
    UINT8                 Mode;

    UINTN                 size;
    UINT8                 *Buffer;
    UINT64                Memory;

    UINT8                 EfiMemoryType;
    UINT8                 EfiAllocateType;
    BOOLEAN               Type;

    Mode                  = MAIN_PAGE_MODE;
    AllBranchPage         = 2;
    CursorPosition.column = 0;
    CursorPosition.row    = 0;

    size                  = 0;
    Buffer                = NULL;
    Memory                = 0;
    EfiMemoryType         = 0;
    EfiAllocateType       = 0;
    Type                  = 0;

    //
    // initialization and into the main page
    //
    gST->ConOut->ClearScreen(gST->ConOut);
    gST->ConOut->SetCursorPosition(gST->ConOut, 0, 0);
    gST->ConOut->EnableCursor(gST->ConOut, TRUE);
    ShowMainPage(&CursorPosition);
    
    //
    // choose mode loop
    //
    while (TRUE) {
      
      //
      // to change mode
      //
      ChangeMode:

      //
      // MAIN_PAGE_MODE
      // with up, down, F1, Esc key response
      //
      while (Mode == MAIN_PAGE_MODE) {
        gST->ConIn->ReadKeyStroke(gST->ConIn, &InputKey);

        if (InputKey.ScanCode == SCAN_ESC) {
          gST->ConOut->ClearScreen(gST->ConOut);
          goto Exit;
        }

        switch (InputKey.ScanCode) {

        case SCAN_UP:
          CursorPosition.row--;
          if (CursorPosition.row < MainPage_ResetPosition.row) {
            CursorPosition.row = MainPage_ResetPosition.row;
          }
          gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);    
          continue;

        case SCAN_DOWN:
          CursorPosition.row++;
          if (CursorPosition.row > (AllBranchPage + MainPage_ResetPosition.row - 1)) {
            CursorPosition.row = (AllBranchPage + MainPage_ResetPosition.row - 1);
          }
          gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);
          continue;

        case SCAN_F1:
          Mode = BRANCH_PAGE_MODE;

          if (CursorPosition.row == MainPage_ResetPosition.row) {
            Type = 1;
            SetAllocateTypePageAppearance();
            AllBranchPage = 3;
            CursorPosition = AllocateTypePage_ResetPosition;
            gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);
          } else if (CursorPosition.row == MainPage_ResetPosition.row + 1) {
            Type = 0;
            SetMemoryTypePageAppearance();
            AllBranchPage = 14;
            CursorPosition = MemoryTypePage_ResetPosition;
            gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);
          } 

          goto ChangeMode;
        }
      }

      //
      // BRANCH_PAGE_MODE
      // with F1, F2, Esc key response
      //
      while (Mode == BRANCH_PAGE_MODE) {
        gST->ConIn->ReadKeyStroke(gST->ConIn, &InputKey);

        if (InputKey.ScanCode == SCAN_ESC) {
          gST->ConOut->ClearScreen(gST->ConOut);
          goto Exit;
        }
        
        if (AllBranchPage == 3) {
          switch (InputKey.ScanCode) {

          case SCAN_UP:
            CursorPosition.row--;
            if (CursorPosition.row < AllocateTypePage_ResetPosition.row) {
              CursorPosition.row = AllocateTypePage_ResetPosition.row;
            }
            gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);    
            continue;

          case SCAN_DOWN:
            CursorPosition.row++;
            if (CursorPosition.row > (AllBranchPage + AllocateTypePage_ResetPosition.row - 1)) {
              CursorPosition.row = (AllBranchPage + AllocateTypePage_ResetPosition.row - 1);
            }
            gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);
            continue;

          case SCAN_F1:
            Mode = BRANCH_PAGE_MODE;

            if (CursorPosition.row == AllocateTypePage_ResetPosition.row) {
              SetMemoryTypePageAppearance();
              EfiAllocateType = AllocateAnyPages;
              AllBranchPage = 14;
              CursorPosition = MemoryTypePage_ResetPosition;
              gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);
            } else if (CursorPosition.row == AllocateTypePage_ResetPosition.row + 1) {
              SetMemoryTypePageAppearance();
              EfiAllocateType = AllocateMaxAddress;
              AllBranchPage = 14;
              CursorPosition = MemoryTypePage_ResetPosition;
              gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);
            } else if (CursorPosition.row == AllocateTypePage_ResetPosition.row + 2) {
              SetMemoryTypePageAppearance();
              EfiAllocateType = AllocateAddress;
              AllBranchPage = 14;
              CursorPosition = MemoryTypePage_ResetPosition;
              gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);
            } 

            goto ChangeMode;
          }
        } else if (AllBranchPage == 14) {
          switch (InputKey.ScanCode) {

          case SCAN_UP:
            CursorPosition.row--;
            if (CursorPosition.row < MemoryTypePage_ResetPosition.row) {
              CursorPosition.row = MemoryTypePage_ResetPosition.row;
            }
            gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);    
            continue;

          case SCAN_DOWN:
            CursorPosition.row++;
            if (CursorPosition.row > (AllBranchPage + MemoryTypePage_ResetPosition.row - 1)) {
              CursorPosition.row = (AllBranchPage + MemoryTypePage_ResetPosition.row - 1);
            }
            gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);
            continue;

          case SCAN_F1:
            if ((EfiAllocateType == AllocateAnyPages && Type == 1) || Type == 0) {
              SetGetSizePageAppearance();
              Mode = GET_SIZE_MODE;
              
            } else {
              SetGetAddressPageAppearance();
              Mode = GET_ADDR_MODE;
            }

            if (CursorPosition.row == MemoryTypePage_ResetPosition.row) {
              EfiMemoryType = EfiReservedMemoryType;
            } else if (CursorPosition.row == MemoryTypePage_ResetPosition.row + 1) {
              EfiMemoryType = EfiLoaderCode;
            } else if (CursorPosition.row == MemoryTypePage_ResetPosition.row + 2) {            
              EfiMemoryType = EfiLoaderData;          
            } else if (CursorPosition.row == MemoryTypePage_ResetPosition.row + 3) {            
              EfiMemoryType = EfiBootServicesCode;            
            } else if (CursorPosition.row == MemoryTypePage_ResetPosition.row + 4) {            
              EfiMemoryType = EfiBootServicesData;            
            } else if (CursorPosition.row == MemoryTypePage_ResetPosition.row + 5) {            
              EfiMemoryType = EfiRuntimeServicesCode;            
            } else if (CursorPosition.row == MemoryTypePage_ResetPosition.row + 6) {            
              EfiMemoryType = EfiRuntimeServicesData;            
            } else if (CursorPosition.row == MemoryTypePage_ResetPosition.row + 7) {            
              EfiMemoryType = EfiConventionalMemory;          
            } else if (CursorPosition.row == MemoryTypePage_ResetPosition.row + 8) {            
              EfiMemoryType = EfiUnusableMemory;            
            } else if (CursorPosition.row == MemoryTypePage_ResetPosition.row + 9) {            
              EfiMemoryType = EfiACPIReclaimMemory;            
            } else if (CursorPosition.row == MemoryTypePage_ResetPosition.row + 10) {            
              EfiMemoryType = EfiACPIMemoryNVS;            
            } else if (CursorPosition.row == MemoryTypePage_ResetPosition.row + 11) {            
              EfiMemoryType = EfiMemoryMappedIO;            
            } else if (CursorPosition.row == MemoryTypePage_ResetPosition.row + 12) {            
              EfiMemoryType = EfiMemoryMappedIOPortSpace;            
            } else if (CursorPosition.row == MemoryTypePage_ResetPosition.row + 13) {            
              EfiMemoryType = EfiPalCode;            
            }

            CursorPosition = MemorySettingWrite_ResetPosition;
            gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);

            goto ChangeMode;
          }
        }
        switch (InputKey.ScanCode) {
        
        case SCAN_F2:
          Mode = MAIN_PAGE_MODE; 
          AllBranchPage = 2;
          ShowMainPage(&CursorPosition);
          goto ChangeMode;
        }
      }

      //
      // GET_ADDR_MODE
      //
      if (Mode == GET_ADDR_MODE) {
        UINT8 WriteCount = 0;
        UINT8 WriteNum  = 16;
        UINT8 i;
        WRITE_BUFFER WriteBuffer[16];

        for (i = 0; i < WriteNum; i++) {
          WriteBuffer[i].value = 0;
          WriteBuffer[i].position = MemorySettingWrite_ResetPosition;
        }

        while (TRUE) {
          gST->ConIn->ReadKeyStroke(gST->ConIn, &InputKey);

          if (InputKey.ScanCode == SCAN_ESC) {
            gST->ConOut->ClearScreen(gST->ConOut);
            goto Exit;
          }
          
          if (WriteCount == WriteNum) {
            Mode = GET_SIZE_MODE;
            // Mode = ERROR_MODE;

            for (WriteCount = 0; WriteCount < WriteNum; WriteCount++) {
              Memory |= WriteBuffer[WriteCount].value << ((WriteNum-WriteCount-1) * 4);
            }

            if (Memory == 0) {
              Mode = GET_ADDR_MODE;
              goto ChangeMode;
            }

            SetGetSizePageAppearance();
            CursorPosition = MemorySettingWrite_ResetPosition;
            gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);

            goto ChangeMode;
          }

          if (('a' <= InputKey.UnicodeChar && InputKey.UnicodeChar <= 'f')) {
            WriteBuffer[WriteCount].value = (UINT8)InputKey.UnicodeChar - 87;
            WriteBuffer[WriteCount].position.column = CursorPosition.column;
            WriteBuffer[WriteCount].position.row = CursorPosition.row;
            Print(L"%c", InputKey.UnicodeChar);

            CursorPosition.column = CursorPosition.column + 1;
            gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);

            WriteCount++;
            continue;

          } else if (('0' <= InputKey.UnicodeChar && InputKey.UnicodeChar <= '9')) {
            WriteBuffer[WriteCount].value = InputKey.UnicodeChar - 48;
            WriteBuffer[WriteCount].position.column = CursorPosition.column;
            WriteBuffer[WriteCount].position.row = CursorPosition.row;
            Print(L"%c", InputKey.UnicodeChar);
        
            CursorPosition.column = CursorPosition.column + 1;
            gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);
            
            WriteCount++;
            continue;
          }
        }
      }

      //
      // GET_SIZE_MODE
      //
      if (Mode == GET_SIZE_MODE) {
        UINT8 WriteCount = 0;
        UINT8 WriteNum   = 4;
        UINT8 i;
        WRITE_BUFFER WriteBufferDecimal[4];

        for (i = 0; i < WriteNum; i++) {
          WriteBufferDecimal[i].value = 0;
          WriteBufferDecimal[i].position = MemorySettingWrite_ResetPosition;
        }

        while (TRUE) {
          gST->ConIn->ReadKeyStroke(gST->ConIn, &InputKey);

          if (InputKey.ScanCode == SCAN_ESC) {
            gST->ConOut->ClearScreen(gST->ConOut);
            goto Exit;
          }

          if (WriteCount == WriteNum) {
            Mode = WRITE_MODE;
            // Mode = ERROR_MODE;

            for (WriteCount = 0; WriteCount < WriteNum; WriteCount++) {
              size += WriteBufferDecimal[WriteCount].value * Power((UINT64)10, (UINT64)(WriteNum-WriteCount-1));            
            }

            if (size == 0) {
              Mode = GET_SIZE_MODE;
              goto ChangeMode;
            }

            if (Type == 0) {
              Status = gBS->AllocatePool(
                                      EfiMemoryType,
                                      size,
                                      &Buffer   // (VOID**)??
                                      );
              if (EFI_ERROR(Status)) {
                Mode = ERROR_MODE;
                gST->ConOut->ClearScreen(gST->ConOut);
                Print(L"%r,Please press F1.\n", Status);
                gST->ConOut->EnableCursor(gST->ConOut, FALSE);
                goto ChangeMode;
              }

            } else if (Type == 1) {
              Status = gBS->AllocatePages(
                                      EfiAllocateType,
                                      EfiMemoryType,
                                      size,
                                      &Memory
                                      );
              if (EFI_ERROR(Status)) {
                Mode = ERROR_MODE;
                gST->ConOut->ClearScreen(gST->ConOut);
                Print(L"%r,Please press F1.\n", Status);
                gST->ConOut->EnableCursor(gST->ConOut, FALSE);
                goto ChangeMode;
              }
            }

            goto ChangeMode;
          }
          
          if (('0' <= InputKey.UnicodeChar && InputKey.UnicodeChar <= '9')) {
            WriteBufferDecimal[WriteCount].value = InputKey.UnicodeChar - 48;
            WriteBufferDecimal[WriteCount].position.column = CursorPosition.column;
            WriteBufferDecimal[WriteCount].position.row = CursorPosition.row;
            Print(L"%c", InputKey.UnicodeChar);
      
            CursorPosition.column = CursorPosition.column + 1;
            gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);
            
            WriteCount++;
            
            continue;
          }

        }
      }

      //
      // WRITE_MODE
      //
      if (Mode == WRITE_MODE) {
        UINT8 LineCount   = 0;
        UINT8 WriteCount  = 0;
        UINT16 WriteNum   = 0;
        UINT8 i;
        BOOLEAN IsWriting = FALSE;
        BOOLEAN AddressOrValue = 0;   // 0 -> addr
        WRITE_BUFFER WriteBuffer[16];

        for (i = 0; i < 16; i++) {
          WriteBuffer[i].value = 0;
          WriteBuffer[i].position = MemorySettingWrite_ResetPosition;
        }

        while (TRUE) {
          while (IsWriting == FALSE) {
            if (AddressOrValue == 1) {  // 1 -> value

              IsWriting = !IsWriting;
              WriteNum = 2;
              
              if (LineCount == 13) {
                SetMemorySettingPageAppearance();
                gST->ConOut->EnableCursor(gST->ConOut, FALSE);
                LineCount = 0;
              }
              
              CursorPosition = MemorySettingPage_ResetPosition;
              CursorPosition.row = CursorPosition.row + LineCount;
              gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);
              Print(L"(1Byte) Set   value  with 0xXX");
              CursorPosition = MemorySettingWrite_ResetPosition;
              CursorPosition.row = CursorPosition.row + LineCount;
              gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);

              LineCount++;
              AddressOrValue = !AddressOrValue;

              break;
            }

            gST->ConIn->ReadKeyStroke(gST->ConIn, &InputKey);

            if (InputKey.ScanCode == SCAN_ESC) {
              gST->ConOut->ClearScreen(gST->ConOut);
              goto Exit;
            }

            switch (InputKey.ScanCode) {

            case SCAN_F1:
              IsWriting = !IsWriting;
              
              if (LineCount == 13) {
                SetMemorySettingPageAppearance();
                gST->ConOut->EnableCursor(gST->ConOut, FALSE);
                LineCount = 0;
              }

              
              WriteNum = 16;
              CursorPosition = MemorySettingPage_ResetPosition;
              CursorPosition.row = CursorPosition.row + LineCount;
              gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);
              Print(L"(64bit) Set  address with 0xXXXXXXXXXXXXXXXX");
              

              CursorPosition = MemorySettingWrite_ResetPosition;
              CursorPosition.row = CursorPosition.row + LineCount;
              gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);

              LineCount++;
              AddressOrValue = !AddressOrValue;
        
              break;

            case SCAN_F2:
              IsWriting = !IsWriting;
              WriteNum = 2;
              if (LineCount == 13) {
                SetMemorySettingPageAppearance();
                gST->ConOut->EnableCursor(gST->ConOut, FALSE);
                LineCount = 0;
              }
              CursorPosition = MemorySettingPage_ResetPosition;
              CursorPosition.row = CursorPosition.row + LineCount;
              gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);
              Print(L"(1Byte) Reset memory with 0xXX");
              CursorPosition = MemorySettingWrite_ResetPosition;
              CursorPosition.row = CursorPosition.row + LineCount;
              gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);
              LineCount++;
              break;

            case SCAN_F3:
              SetMemorySettingPageAppearance();
              gST->ConOut->EnableCursor(gST->ConOut, FALSE);
              LineCount = 0;
              
              continue;

            case SCAN_F4:
              Mode = SHOW_MODE;
              SetRegisterPageAppearance();
              CursorPosition = RegistPage_ResetPosition;
              gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);
              goto ChangeMode;  
            }
            
          }

          while (IsWriting == TRUE) {
            gST->ConIn->ReadKeyStroke(gST->ConIn, &InputKey);

            if (InputKey.ScanCode == SCAN_ESC) {
              gST->ConOut->ClearScreen(gST->ConOut);
              goto Exit;
            }

            if (WriteCount == WriteNum) {
              WriteCount = 0;
              // Print(L"\n  %d\n  %d\n  %d\n  %d\n", WriteCount, WriteNum, IsWriting, AddressOrValue);

              IsWriting = !IsWriting;
              break;
            }

            

            if (('a' <= InputKey.UnicodeChar && InputKey.UnicodeChar <= 'f')) {
              WriteBuffer[WriteCount].value = (UINT8)InputKey.UnicodeChar - 87;
              WriteBuffer[WriteCount].position.column = CursorPosition.column;
              WriteBuffer[WriteCount].position.row = CursorPosition.row;
              Print(L"%c", InputKey.UnicodeChar);

              CursorPosition.column = CursorPosition.column + 1;
              
              gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);
              WriteCount++;
              continue;

            } else if (('0' <= InputKey.UnicodeChar && InputKey.UnicodeChar <= '9')) {
              WriteBuffer[WriteCount].value = InputKey.UnicodeChar - 48;
              WriteBuffer[WriteCount].position.column = CursorPosition.column;
              
              WriteBuffer[WriteCount].position.row = CursorPosition.row;
              
              Print(L"%c", InputKey.UnicodeChar);
              

              CursorPosition.column = CursorPosition.column + 1;
              
              gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);
              
              WriteCount++;
              
              continue;
            }
          }
        }
        
      }
      
      //
      // SHOW_MODE
      // 
      while (Mode == SHOW_MODE) {

      }

      //
      // ERROR_MODE
      //
      while (Mode == ERROR_MODE) {
        gST->ConIn->ReadKeyStroke(gST->ConIn, &InputKey);

        switch (InputKey.ScanCode) {
        
        case SCAN_F1:
          Mode = MAIN_PAGE_MODE;
          gBS->FreePages(
                      Memory,
                      size
                      );
          gBS->FreePool(Buffer); 
          AllBranchPage = 2;
          size = 0;
          ShowMainPage(&CursorPosition);
          gST->ConOut->EnableCursor(gST->ConOut, TRUE);
          goto ChangeMode;

        case SCAN_F2:
          gST->ConOut->ClearScreen(gST->ConOut);

          Print(L"Type            ->%d\n", Type);
          Print(L"EfiAllocateType ->%d\n", EfiAllocateType);
          Print(L"EfiMemoryType   ->%d\n", EfiMemoryType);
          Print(L"size            ->%d\n", size);
          Print(L"Buffer(0)       ->%p\n", Buffer);
          Print(L"Memory(1)       ->%p", Memory);

          continue;
        }
      }
    }

    

    // for (EfiMemoryType = 0; EfiMemoryType < EfiMaxMemoryType; EfiMemoryType++) {
    //   Print(L"Type\t->%x\n", EfiMemoryType);

    //   Buf = NULL;
    //   Status = gBS->AllocatePool(
    //                  EfiMemoryType,
    //                  BufferSize,
    //                  &Buf
    //                  );

    //   if (EFI_ERROR(Status)) {
    //     gST->ConOut->ClearScreen(gST->ConOut);
    //     Print(L"%r\n", Status);
    //     gST->ConOut->EnableCursor(gST->ConOut, FALSE);
    //     continue;
    //   }

    //   gBS->SetMem(
    //            Buf,
    //            1,
    //            0xff
    //            );

    //   Print(L"Buf\t->%x\n", Buf);
    //   Print(L"*Buf\t->%x\n", *Buf);
      
    //   gBS->FreePool(Buf); 
    // }

    //
    // to get out
    //
    Exit:

    Status = EFI_SUCCESS;

    return Status;
  }

  VOID 
  SetMainPageAppearance (
    VOID
    )
  {
    gST->ConOut->ClearScreen(gST->ConOut);
    gST->ConOut->SetAttribute(gST->ConOut, EFI_WHITE | EFI_BACKGROUND_BLACK);

    Print(L"|====================================================|\n");
    Print(L"|                                                    |\n");
    Print(L"|                  12-Memory_utility                 |\n");
    Print(L"|                                                    |\n");
    Print(L"|====================================================|\n");
    Print(L"|              Allocate Memory By Page               |\n");
    Print(L"|              Allocate Memory By Pool               |\n");
    Print(L"|====================================================|\n");
    Print(L"| [Arrow key] : Choose                               |\n");
    Print(L"| [F1] : Enter                                       |\n");
    Print(L"| [Esc] : Escape                                     |\n");
    Print(L"|====================================================|\n");

    return;
  }

  VOID 
  SetAllocateTypePageAppearance (
    VOID
    )
  {
    gST->ConOut->ClearScreen(gST->ConOut);
    gST->ConOut->SetAttribute(gST->ConOut, EFI_WHITE | EFI_BACKGROUND_BLACK);

    Print(L"|====================================================|\n");
    Print(L"|                                                    |\n");
    Print(L"|                   Allocate Type                    |\n");
    Print(L"|                                                    |\n");
    Print(L"|====================================================|\n");
    Print(L"|              Allocate Any Pages                    |\n");
    Print(L"|              Allocate Max Address                  |\n");
    Print(L"|              Allocate Address                      |\n");
    Print(L"|====================================================|\n");
    Print(L"| [Arrow key] : Choose     [Esc] : Escape            |\n");
    Print(L"| [F1] : Enter             [F2] : Home               |\n");
    Print(L"|====================================================|\n");

    return;
  }

  VOID 
  SetMemoryTypePageAppearance (
    VOID
    )
  {
    gST->ConOut->ClearScreen(gST->ConOut);
    gST->ConOut->SetAttribute(gST->ConOut, EFI_WHITE | EFI_BACKGROUND_BLACK);

    Print(L"|====================================================|\n");
    Print(L"|                                                    |\n");
    Print(L"|                    Memory Type                     |\n");
    Print(L"|                                                    |\n");
    Print(L"|====================================================|\n");
    Print(L"|              Reserved Memory                       |\n");
    Print(L"|              Loader Code                           |\n");
    Print(L"|              Loader Data                           |\n");
    Print(L"|              Boot Service Code                     |\n");
    Print(L"|              Boot Service Data                     |\n");
    Print(L"|              Runtime Service Code                  |\n");
    Print(L"|              Runtime Service Data                  |\n");
    Print(L"|              Conventional Memory                   |\n");
    Print(L"|              Unusable Memory                       |\n");
    Print(L"|              ACPI Reclaim Memory                   |\n");
    Print(L"|              ACPI NVS Memory                       |\n");
    Print(L"|              Memory Mapped IO                      |\n");
    Print(L"|              Memory Mapped IO Port Space           |\n");
    Print(L"|              PAL Code                              |\n");
    Print(L"|====================================================|\n");
    Print(L"| [Arrow key] : Choose     [Esc] : Escape            |\n");
    Print(L"| [F1] : Enter             [F2] : Home               |\n");
    Print(L"|====================================================|\n");

    return;
  }

  VOID 
  SetGetSizePageAppearance (
    VOID
    )
  {
    gST->ConOut->ClearScreen(gST->ConOut);
    gST->ConOut->SetAttribute(gST->ConOut, EFI_WHITE | EFI_BACKGROUND_BLACK);

    Print(L"|====================================================|\n");
    Print(L"|                                                    |\n");
    Print(L"|                     Get Size                       |\n");
    Print(L"|                                                    |\n");
    Print(L"|====================================================|\n");
    Print(L"|              Please set size.                      |\n");
    Print(L"|              Set  size  with 0xXXXXXXXXXXXXXXXX    |\n");
    Print(L"|                                                    |\n");
    Print(L"|====================================================|\n");
    Print(L"| [Num]:Number                                       |\n");
    Print(L"| [Esc]:Escape                                       |\n");
    Print(L"|====================================================|\n");

    return;
  }

  VOID 
  SetGetAddressPageAppearance (
    VOID
    )
  {
    gST->ConOut->ClearScreen(gST->ConOut);
    gST->ConOut->SetAttribute(gST->ConOut, EFI_WHITE | EFI_BACKGROUND_BLACK);

    Print(L"|====================================================|\n");
    Print(L"|                                                    |\n");
    Print(L"|                     Get Address                    |\n");
    Print(L"|                                                    |\n");
    Print(L"|====================================================|\n");
    Print(L"|            Please set address.                     |\n");
    Print(L"|            Set  address with 0xXXXXXXXXXXXXXXXX    |\n");
    Print(L"|                                                    |\n");
    Print(L"|====================================================|\n");
    Print(L"| [Num]:Number                                       |\n");
    Print(L"| [Esc]:Escape                                       |\n");
    Print(L"|====================================================|\n");

    return;
  }

  VOID 
  SetMemorySettingPageAppearance (
    VOID
    )
  {
    gST->ConOut->ClearScreen(gST->ConOut);
    gST->ConOut->SetAttribute(gST->ConOut, EFI_WHITE | EFI_BACKGROUND_BLACK);

    Print(L"|====================================================|\n");
    Print(L"|                                                    |\n");
    Print(L"|                  Memory Setting                    |\n");
    Print(L"|                                                    |\n");
    Print(L"|====================================================|\n");
    Print(L"|           Please press button to modify.           |\n");
    Print(L"|                                                    |\n");
    Print(L"|                                                    |\n");
    Print(L"|                                                    |\n");
    Print(L"|                                                    |\n");
    Print(L"|                                                    |\n");
    Print(L"|                                                    |\n");
    Print(L"|                                                    |\n");
    Print(L"|                                                    |\n");
    Print(L"|                                                    |\n");
    Print(L"|                                                    |\n");
    Print(L"|                                                    |\n");
    Print(L"|                                                    |\n");
    Print(L"|                                                    |\n");
    Print(L"|====================================================|\n");
    Print(L"| [F1]:Set       [F2]:Reset     [F3]:Clean Screen    |\n");
    Print(L"| [F4]:Show      [Esc]:Escape                        |\n");
    Print(L"|====================================================|\n");

    return;
  }

  /**
    To set register page appearance.

  **/
  VOID 
  SetRegisterPageAppearance (
    VOID
    )
  {
    gST->ConOut->ClearScreen(gST->ConOut);
    gST->ConOut->SetAttribute(gST->ConOut, EFI_WHITE | EFI_BACKGROUND_BLACK);

    Print(L"|                                                    |\n");
    Print(L"|====================================================|\n");
    Print(L"|  | 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F |\n");
    Print(L"|====================================================|\n");
    Print(L"|00|                                                 |\n");
    Print(L"|10|                                                 |\n");
    Print(L"|20|                                                 |\n");
    Print(L"|30|                                                 |\n");
    Print(L"|40|                                                 |\n");
    Print(L"|50|                                                 |\n");
    Print(L"|60|                                                 |\n");
    Print(L"|70|                                                 |\n");
    Print(L"|80|                                                 |\n");
    Print(L"|90|                                                 |\n");
    Print(L"|A0|                                                 |\n");
    Print(L"|B0|                                                 |\n");
    Print(L"|C0|                                                 |\n");
    Print(L"|D0|                                                 |\n");
    Print(L"|E0|                                                 |\n");
    Print(L"|F0|                                                 |\n");
    Print(L"|====================================================|\n");
    Print(L"| [Arrow key]:Choose   [Esc]:Escape   [F1]:Home      |\n");
    Print(L"|====================================================|\n");

    return;
  }

  VOID 
  ShowMainPage (
    POSITION *CursorPosition
    )
  {
    SetMainPageAppearance();
    *CursorPosition = MainPage_ResetPosition;
    gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition->column, CursorPosition->row);
    gST->ConOut->EnableCursor(gST->ConOut, TRUE);

    return;
  }

  UINT64 Power (UINT64 Number, UINT64 Time)
  {  
    if (Time == 0) {
      return 1;
    } else {
      return (Number * Power(Number, Time-1));
    }
  }
*/

/*// FileSystem_14(v1)
  #include <Uefi.h>
  #include <Library/UefiLib.h>
  #include <Library/UefiApplicationEntryPoint.h>
  #include <Library/UefiBootServicesTableLib.h>

  #include <Protocol/LoadedImage.h>
  #include <Protocol/SimpleFileSystem.h>

  #include <Protocol/EfiShellParameters.h>
  #include <Protocol/EfiShellInterface.h>

  #include <Guid/FileInfo.h>
  #include <Guid/FileSystemInfo.h>

  #include <Library/MemoryAllocationLib.h>

  #define InputAmount    50
  #define STRING_MATCH   0
  #define STRING_UNMATCH 1

  VOID 
  InitializeArray(
    CHAR16 *Buffer,
    UINT64 BufferSize
    );

  CHAR16* 
  InputWord (
    VOID
    );

  EFI_STATUS
  CreatFile (
    EFI_FILE  *Root,
    CHAR16    *FileName
    );

  EFI_STATUS
  DeleteFile (
    EFI_FILE  *Root,
    CHAR16    *FileName
    );

  EFI_STATUS
  ReadFile (
    EFI_FILE  *Root,
    CHAR16    *FileName
    );

  EFI_STATUS
  WriteFile (
    EFI_FILE  *Root,
    CHAR16    *FileName
    );

  EFI_FILE_INFO*
  GetFileInfo (
    EFI_FILE  *Root,
    CHAR16    *FileName
    );

  VOID
  ShowFileInfo (
    EFI_FILE_INFO *Buffer
    );

  EFI_FILE_SYSTEM_INFO*
  GetSystemInfo (
    EFI_FILE  *Root
    );

  VOID
  ShowSystemInfo (
    EFI_FILE_SYSTEM_INFO *SystemInfo
    );

  VOID
  ShowHelp(
    VOID
    );

  EFI_STATUS
  CopyFile (
    EFI_FILE  *Root,
    CHAR16    *CopyFile,
    CHAR16    *PasteFile
    );

  EFI_STATUS
  MergeFile (
    EFI_FILE  *Root,
    CHAR16    *FileName1,
    CHAR16    *FileName2
    );

  EFI_STATUS
  EFIAPI
  UefiMain (
    IN EFI_HANDLE ImageHandle, 
    IN EFI_SYSTEM_TABLE *SystemTable
    )
  {
    EFI_STATUS                        Status;
    EFI_LOADED_IMAGE_PROTOCOL         *Image;
    EFI_SIMPLE_FILE_SYSTEM_PROTOCOL   *SimpleFileSystem;
    EFI_FILE                          *Root;
    CHAR16                            Cmd[9][3] = {L"-h", L"-n", L"-r", L"-w", \
                                                  L"-c", L"-d", L"-i", L"-m", L"-I"};
    BOOLEAN                           OpenSuccess;

    CHAR16                            **Argv;
    UINT64                            Argc;
    EFI_SHELL_PARAMETERS_PROTOCOL     *EfiShellParametersProtocol;
    EFI_SHELL_INTERFACE               *EfiShellInterfaceProtocol;

    Root = 0;
    OpenSuccess = FALSE;

    gST->ConOut->ClearScreen(gST->ConOut);

    //
    // Locate Correct SimpleFileSystemProtocol
    //
    // First Locate LoadedImage By main function's ImageHandle
    // Second Locate SimpleFileSystemProtocol By LoadedImage's DeviceHandle
    //
    Status = gBS->HandleProtocol(
                    ImageHandle,
                    &gEfiLoadedImageProtocolGuid,
                    &Image
                    );
    if (Status == EFI_SUCCESS) {
      // Print(L"Locate LoadedImageProtocol Success\n");
      Status = gBS->HandleProtocol(
                      Image->DeviceHandle,
                      &gEfiSimpleFileSystemProtocolGuid,
                      &SimpleFileSystem
                      );
      if (Status == EFI_SUCCESS) {
        // Print(L"Locate SimpleFileSystemProtocol Success\n");
        Status = SimpleFileSystem->OpenVolume(
                            SimpleFileSystem,
                            &Root
                            );
        if (Status == EFI_SUCCESS) {
          // Print(L"Locate OpenVolume Success\n\n\n");
          
          OpenSuccess = TRUE;
        }
      }
    }


    //
    // Get Argv、Argc
    //
    Status = gBS->OpenProtocol(
                    ImageHandle,
                    &gEfiShellParametersProtocolGuid,
                    (VOID **)&EfiShellParametersProtocol,
                    ImageHandle,
                    NULL,
                    EFI_OPEN_PROTOCOL_GET_PROTOCOL
                    );
    if (EFI_ERROR(Status)) {
      Status = gBS->OpenProtocol(
                      ImageHandle,
                      &gEfiShellInterfaceGuid,
                      (VOID **)&EfiShellInterfaceProtocol,
                      ImageHandle,
                      NULL,
                      EFI_OPEN_PROTOCOL_GET_PROTOCOL
                      );
      if (EFI_ERROR(Status)) {
        return Status;
      }
      Argc = EfiShellInterfaceProtocol->Argc;
      Argv = EfiShellInterfaceProtocol->Argv;
    } else {
      Argc = EfiShellParametersProtocol->Argc;
      Argv = EfiShellParametersProtocol->Argv;
    }

    if (Argc == 1) {
      Print(L"Input invalid !!!\n");

    } else {
      if (StrCmp(Argv[1], Cmd[0]) == STRING_MATCH) {
        // help
        if (Argc == 2) {
          ShowHelp();
        } else {
          Print(L"Input invalid !!!\n");
        }

      } else if (StrCmp(Argv[1], Cmd[1]) == STRING_MATCH) {
        // create
        if (Argc == 3) {
          CreatFile(Root, Argv[2]);
        } else {
          Print(L"Input invalid !!!\n");
        }
        
      } else if (StrCmp(Argv[1], Cmd[2]) == STRING_MATCH) {
        // read
        if (Argc == 3) {
          ReadFile(Root, Argv[2]);
        } else {
          Print(L"Input invalid !!!\n");
        }
        
      } else if (StrCmp(Argv[1], Cmd[3]) == STRING_MATCH) {
        // write WriteFile
        if (Argc == 3) {
          WriteFile(Root, Argv[2]);
        } else {
          Print(L"Input invalid !!!\n");
        }
        
      } else if (StrCmp(Argv[1], Cmd[4]) == STRING_MATCH) {
        // copy
        if (Argc == 4) {
          CopyFile(Root, Argv[2], Argv[3]);
        } else {
          Print(L"Input invalid !!!\n");
        }
        
      } else if (StrCmp(Argv[1], Cmd[5]) == STRING_MATCH) {
        // delete
        if (Argc == 3) {
          DeleteFile(Root, Argv[2]);
        } else {
          Print(L"Input invalid !!!\n");
        }
      } else if (StrCmp(Argv[1], Cmd[6]) == STRING_MATCH) {
        // info
        if (Argc == 3) {
          ShowFileInfo(GetFileInfo(Root, Argv[2]));
        } else {
          Print(L"Input invalid !!!\n");
        }
      } else if (StrCmp(Argv[1], Cmd[7]) == STRING_MATCH) {
        // merge
        if (Argc == 4) {
          MergeFile(Root, Argv[2], Argv[3]);
        } else {
          Print(L"Input invalid !!!\n");
        }
      } else if (StrCmp(Argv[1], Cmd[8]) == STRING_MATCH) {
        // SysInfo
        if (Argc == 2) {
          ShowSystemInfo(GetSystemInfo(Root));
        } else {
          Print(L"Input invalid !!!\n");
        }
      }
    }

    Status = EFI_SUCCESS;

    return Status;
  }

  /**
    This Function Show Help
  **/
  VOID
  ShowHelp(
    VOID
    ) 
  {
    Print(L"h Show Help\n");
    Print(L"n Creat  File  -n <FileName>\n");
    Print(L"r Read   File  -r <FileName>\n");
    Print(L"w Write  File  -w <FileName>\n");
    Print(L"d Delete File  -d <FileName>\n");
    Print(L"c copy   File  -c <FileName> <FileName>\n");
    Print(L"m Merge  File  -m <FileName> <FileName>\n");
    Print(L"i File Information  -i <FileName> or -i, Show SystemInfo\n");
  }

  EFI_STATUS
  CreatFile (
    EFI_FILE  *Root,
    CHAR16    *FileName
    )
  {
    EFI_STATUS  Status;
    EFI_FILE    *FileHandle;

    Status = Root->Open(
                    Root,
                    &FileHandle,
                    FileName,
                    EFI_FILE_MODE_READ,
                    EFI_FILE_ARCHIVE
                    );

    if (EFI_ERROR(Status)) {
      Print(L"Open fail: %r\n", Status);
      Print(L"Create new file.\n");

      Status = Root->Open(
                      Root,
                      &FileHandle,
                      FileName,
                      EFI_FILE_MODE_READ | EFI_FILE_MODE_WRITE | EFI_FILE_MODE_CREATE,
                      0
                      );
      if (EFI_ERROR(Status)) {
        Print(L"Create fail: %r\n", Status);
        return Status;
      } 
      
      Status = Root->Close(FileHandle);
      if (EFI_ERROR(Status)) {
        Print(L"Close fail: %r\n", Status);
      }
      return Status;

    } else {
      Print(L"This file already existed.\n");
      Status = Root->Close(FileHandle);
      if (EFI_ERROR(Status)) {
        Print(L"Close fail: %r\n", Status);
      }
      return Status;
    }
  }

  EFI_STATUS
  DeleteFile (
    EFI_FILE  *Root,
    CHAR16    *FileName
    )
  {
    EFI_STATUS  Status;
    EFI_FILE    *FileHandle;

    Status = Root->Open(
                    Root,
                    &FileHandle,
                    FileName,
                    EFI_FILE_MODE_READ | EFI_FILE_MODE_WRITE,
                    0
                    );
    if (EFI_ERROR(Status)) {
      Print(L"Open fail: %r\n", Status);
      Print(L"File not found !!!\n");
      return Status;
    } 
    
    Status = FileHandle->Delete(FileHandle);
    if (EFI_ERROR(Status)) {
      Print(L"Delete fail: %r\n", Status);
      return Status;
    } else {
      Print(L"This file is deleted.\n");
      return Status;
    }
  }

  EFI_FILE_INFO*
  GetFileInfo (
    EFI_FILE  *Root,
    CHAR16    *FileName
    )
  {
    EFI_STATUS     Status;
    EFI_FILE       *FileHandle;
    UINT64         BufferSize = 0;
    EFI_FILE_INFO  *Buffer = NULL;

    Status = Root->Open(
                    Root,
                    &FileHandle,
                    FileName,
                    EFI_FILE_MODE_READ,
                    0
                    );
    if (EFI_ERROR(Status)) {
      Print(L"Open fail: %r\n", Status);
      return NULL;
    } else {
      Status = Root->GetInfo(
                              FileHandle,
                              &gEfiFileInfoGuid,
                              &BufferSize,
                              Buffer
                              );
      if (Status == EFI_BUFFER_TOO_SMALL) {
        gBS->AllocatePool(
                      EfiRuntimeServicesData,
                      BufferSize,                        
                      &Buffer
                      );
        Status = FileHandle->GetInfo(
                          FileHandle,
                          &gEfiFileInfoGuid,
                          &BufferSize,
                          Buffer
                          );
        if (EFI_ERROR(Status)) {
          Print(L"Get information fail: %r\n", Status);
          gBS->FreePool(Buffer);
          return NULL;
        } else {
          Status = Root->Close(FileHandle);
          if (EFI_ERROR(Status)) {
            Print(L"Close fail: %r\n", Status);
            return NULL;
          } else {
            // gBS->FreePool(Buffer);
            return Buffer;
          }
        }
      } else {
        Status = Root->Close(FileHandle);
        if (EFI_ERROR(Status)) {
          Print(L"Close fail: %r\n", Status);
          return NULL;
        } else {
          // gBS->FreePool(Buffer);
          return Buffer;
        }
      }
    }
  }

  EFI_FILE_SYSTEM_INFO*
  GetSystemInfo (
    EFI_FILE  *Root
    )
  {
    EFI_STATUS            Status;
    EFI_FILE_SYSTEM_INFO  *Buffer;
    UINT64                BufferSize;

    Buffer = NULL;
    BufferSize = 0;

    Status = Root->GetInfo(
                        Root,
                        &gEfiFileSystemInfoGuid,
                        &BufferSize,
                        Buffer
                        );
    if (Status == EFI_BUFFER_TOO_SMALL) {
      gBS->AllocatePool(
                    EfiRuntimeServicesData,
                    BufferSize,                        
                    &Buffer
                    );
      Status = Root->GetInfo(
                          Root,
                          &gEfiFileSystemInfoGuid,
                          &BufferSize,
                          Buffer
                          );
      if (EFI_ERROR(Status)) {
        Print(L"Get system information fail: %r.\n", Status);
        gBS->FreePool(Buffer);
        return NULL;

      } else {
        return Buffer;
      }
    } else {
      return Buffer;
    }
  }

  VOID
  ShowSystemInfo (
    EFI_FILE_SYSTEM_INFO *SystemInfo
    )
  {
    if (SystemInfo != NULL) {
      Print (L"Read Only    : %s\n", (SystemInfo->ReadOnly)? L"TRUE":L"FALSE");
      Print (L"Volume Size  : %ld Byte\n", SystemInfo->VolumeSize);
      Print (L"Free Space   : %ld Byte\n", SystemInfo->FreeSpace);
      Print (L"Block Size   : %d Byte\n", SystemInfo->BlockSize);
      Print (L"Volume Label : %s\n", SystemInfo->VolumeLabel);
      return;

    } else {
      Print(L"File not found !!!\n");
    }
  }

  VOID
  ShowFileInfo (
    EFI_FILE_INFO *Buffer
    )
  {
    if (Buffer != NULL) {
      Print (L"File Name         : %s\n", Buffer->FileName);
      Print (L"File Size         : %d Byte\n", Buffer->FileSize);
      Print (L"Physical Size     : %d Byte\n", Buffer->PhysicalSize);
      Print (L"Create Time       : %t\n", Buffer->CreateTime);
      Print (L"LastAccess Time   : %t\n", Buffer->LastAccessTime);
      Print (L"Modification Time : %t\n", Buffer->ModificationTime);
      Print (L"Attribute         : %d\n", Buffer->Attribute);
      return;
    } else {
      Print(L"File not found !!!\n");
    }
  }

  EFI_STATUS
  ReadFile (
    EFI_FILE  *Root,
    CHAR16    *FileName
    )
  {
    EFI_STATUS      Status;
    EFI_FILE        *FileHandle;
    UINT64          BufferSize;
    CHAR16          *Buffer = NULL;

    if (GetFileInfo(Root, FileName) == NULL) {
      Print(L"File not found !!!\n");
      return EFI_NOT_FOUND;
    } else {
      BufferSize = GetFileInfo(Root, FileName)->FileSize;

      if (BufferSize == 0) {
        Print(L"No content !!!\n");
        return EFI_SUCCESS;
      }
    }

    gBS->AllocatePool(
                  EfiRuntimeServicesData,
                  BufferSize,                        
                  &Buffer
                  );

    Status = Root->Open(
                    Root,
                    &FileHandle,
                    FileName,
                    EFI_FILE_MODE_READ,
                    0
                    );

    if (EFI_ERROR(Status)) {
      Print(L"Open fail: %r\n", Status);
      return Status;
    } else {
      Status = FileHandle->Read(
                            FileHandle,
                            &BufferSize,
                            Buffer
                            );
      if (EFI_ERROR(Status)) {
        Print(L"Read fail: %r\n", Status);
        Status = Root->Close(FileHandle);
        if (EFI_ERROR(Status)) {
          Print(L"Close fail: %r\n", Status);
        }
        return Status;
      } else {
        Status = Root->Close(FileHandle);
        if (EFI_ERROR(Status)) {
          Print(L"Close fail: %r\n", Status);
          return Status;
        } else {
          Print(L"File content:\n");
          Print(L"%s\n", Buffer);
          FreePool(Buffer);
          return Status;
        }      
      }
    }
  }

  EFI_STATUS
  WriteFile (
    EFI_FILE  *Root,
    CHAR16    *FileName
    )
  {
    EFI_STATUS      Status;
    EFI_FILE        *FileHandle;

    UINT64          BufferSize;
    CHAR16          *Buffer;

    Buffer = InputWord();
    BufferSize = StrLen(Buffer) * 2;

    Status = Root->Open(
                    Root,
                    &FileHandle,
                    FileName,
                    EFI_FILE_MODE_READ | EFI_FILE_MODE_WRITE,
                    0
                    );

    if (EFI_ERROR(Status)) {
      Print(L"\nOpen fail: %r\n", Status);
      FreePool(Buffer);
      return Status;
    } else {
      FileHandle->Write(
                    FileHandle,
                    &BufferSize,
                    Buffer
                    );
      if (EFI_ERROR(Status)) {
        Print(L"\nWrite fail: %r\n", Status);
        Status = Root->Close(FileHandle);
        if (EFI_ERROR(Status)) {
          Print(L"\nClose fail: %r\n", Status);
        }
        return Status;
        
      } else {
        Status = Root->Close(FileHandle);
        if (EFI_ERROR(Status)) {
          Print(L"\nClose fail: %r\n", Status);
          return Status;
        } else {
          Print(L"\nWrite done\n");        
          FreePool(Buffer);
          return Status;
        }
      }
    }
  }

  VOID 
  InitializeArray(
    CHAR16 *Buffer,
    UINT64 BufferSize
    )
  {
    UINT32  i;

    for (i = 0; i < BufferSize; i++) {
      Buffer[i] = 0;
    }

    return;
  }

  CHAR16* 
  InputWord (
    VOID
    )
  {
    EFI_INPUT_KEY        InputKey;
    INT32                Count;
    CHAR16               *Buffer;
    CHAR16               *OldBuffer = NULL;
    UINT32               AllocateSize;
    UINT32 i;

    Count = 0;
    AllocateSize = 10;
    Buffer = AllocatePool(AllocateSize);

    InitializeArray(Buffer, AllocateSize);

    while (TRUE) {
      gST->ConIn->ReadKeyStroke(gST->ConIn, &InputKey);

      if (Count >= (INT32)AllocateSize) {
        OldBuffer = Buffer;
        Buffer = ReallocatePool(AllocateSize, AllocateSize + 10, NULL);
        AllocateSize += 10;
        InitializeArray(Buffer, AllocateSize);
        for (i = 0; i < AllocateSize-10; i++) {
          Buffer[i] = OldBuffer[i];
        }
      }

      switch(InputKey.UnicodeChar){
      case CHAR_NULL:
        continue;
      
      case CHAR_CARRIAGE_RETURN:
        FreePool(OldBuffer);
        return Buffer;
      
      case CHAR_BACKSPACE:
        Count--;
        if (Count < 0) {
          Count = 0;
        }
        Buffer[Count] = CHAR_NULL;
        Print(L"%c", InputKey.UnicodeChar); 
        
        continue;

      default:
        Buffer[Count] = InputKey.UnicodeChar;
        Print(L"%c", InputKey.UnicodeChar);
        Count++;
        continue;
      }
    }
  }

  EFI_STATUS
  CopyFile (
    EFI_FILE  *Root,
    CHAR16    *CopyFile,
    CHAR16    *PasteFile
    )
  {
    CHAR16  *Buffer = NULL;
    EFI_STATUS  Status;
    EFI_FILE    *FileHandle = NULL;
    UINT64 BufferSize;

    //
    // copy
    //
    if (GetFileInfo(Root, CopyFile) == NULL) {
      Print(L"File %s not found !!!\n", CopyFile);
      return EFI_NOT_FOUND;
    } else {
      BufferSize = GetFileInfo(Root, CopyFile)->FileSize;

      if (BufferSize == 0) {
        return EFI_SUCCESS;
      } else {
        Buffer = AllocatePool(BufferSize);
      }
    }

    Status = Root->Open(
                    Root,
                    &FileHandle,
                    CopyFile,
                    EFI_FILE_MODE_READ,
                    0
                    );

    if (EFI_ERROR(Status)) {
      Print(L"Open fail: %r\n", Status);
      return Status;
    } else {
      Status = FileHandle->Read(
                            FileHandle,
                            &BufferSize,
                            Buffer
                            );
      if (EFI_ERROR(Status)) {
        Print(L"Read fail: %r\n", Status);
        Status = Root->Close(FileHandle);
        if (EFI_ERROR(Status)) {
          Print(L"Close fail: %r\n", Status);
        }
        return Status;
      } else {
        Status = Root->Close(FileHandle);
        if (EFI_ERROR(Status)) {
          Print(L"Close fail: %r\n", Status);
          return Status;
        }
      }
    }

    //
    // patse
    //
    Status = Root->Open(
                    Root,
                    &FileHandle,
                    PasteFile,
                    EFI_FILE_MODE_READ | EFI_FILE_MODE_WRITE | EFI_FILE_MODE_CREATE,
                    0
                    );

    if (EFI_ERROR(Status)) {
      Print(L"\nOpen fail: %r\n", Status);
      return Status;
    } else {
      FileHandle->Write(
                    FileHandle,
                    &BufferSize,
                    Buffer
                    );
      if (EFI_ERROR(Status)) {
        Print(L"\nWrite fail: %r\n", Status);
        Status = Root->Close(FileHandle);
        if (EFI_ERROR(Status)) {
          Print(L"\nClose fail: %r\n", Status);
        }
        return Status;
        
      } else {
        Status = Root->Close(FileHandle);
        if (EFI_ERROR(Status)) {
          Print(L"\nClose fail: %r\n", Status);
          return Status;
        } else {
          Print(L"Copy done\n");        
          FreePool(Buffer);
          return Status;
        }
      }
    }
  }

  EFI_STATUS
  MergeFile (
    EFI_FILE  *Root,
    CHAR16    *DestinationFile,
    CHAR16    *SourceFile
    )
  {
    CHAR16  *Buffer = NULL;
    EFI_STATUS  Status;
    EFI_FILE    *FileHandle = NULL;
    UINT64 BufferSize;
    UINT64 Position;

    //
    // copy SourceFile
    //
    if (GetFileInfo(Root, SourceFile) == NULL) {
      Print(L"File %s not found !!!\n", SourceFile);
      return EFI_NOT_FOUND;
    } else {
      BufferSize = GetFileInfo(Root, SourceFile)->FileSize;

      if (BufferSize == 0) {
        return EFI_SUCCESS;
      } else {
        Buffer = AllocatePool(BufferSize);
      }
    }

    Status = Root->Open(
            Root,
            &FileHandle,
            SourceFile,
            EFI_FILE_MODE_READ,
            0
            );
    if (EFI_ERROR(Status)) {
      Print(L"Open fail: %r\n", Status);
      return Status;
    }

    Status = FileHandle->Read(
                  FileHandle,
                  &BufferSize,
                  Buffer
                  );
    if (EFI_ERROR(Status)) {
      Print(L"Read fail: %r\n", Status);
      return Status;
    }

    Status = Root->Close(FileHandle);
    if (EFI_ERROR(Status)) {
      Print(L"Close fail: %r\n", Status);
      return Status;
    }

    //
    // set PasteFile position
    //
    if (GetFileInfo(Root, DestinationFile) == NULL) {
      Print(L"File %s not found !!!\n", DestinationFile);
      return EFI_NOT_FOUND;
    } else {
      Position = GetFileInfo(Root, DestinationFile)->FileSize;
    }

    //
    // patse
    //
    Status = Root->Open(
                    Root,
                    &FileHandle,
                    DestinationFile,
                    EFI_FILE_MODE_READ | EFI_FILE_MODE_WRITE,
                    0
                    );
    if (EFI_ERROR(Status)) {
      Print(L"Open fail: %r\n", Status);
      return Status;
    }

    Status = FileHandle->SetPosition(FileHandle, Position);
    if (EFI_ERROR(Status)) {
      Print(L"Set position fail: %r\n", Status);
      return Status;
    }

    Status = FileHandle->Write(
                            FileHandle,
                            &BufferSize,
                            Buffer
                            );
    if (EFI_ERROR(Status)) {
      Print(L"Write fail: %r\n", Status);
      return Status;
    }

    Status = Root->Close(FileHandle);
    if (EFI_ERROR(Status)) {
      Print(L"Close fail: %r\n", Status);
      return Status;
    }

    Print(L"Merge to %s\n", DestinationFile);
    return Status;
  }
*/

/*// Variable_15(v1)
  #include <Uefi.h>
  #include <Library/UefiLib.h>
  #include <Library/UefiApplicationEntryPoint.h>
  #include <Library/UefiBootServicesTableLib.h>
  #include <Library/UefiRuntimeServicesTableLib.h>
  #include <Library/MemoryAllocationLib.h>
  #include <Library/BaseMemoryLib.h>

  #define WORD_INITIAL_SIZE    10
  #define WORD_SIZE_INCREMENT  10

  #define VALUE_INITIAL_SIZE   1
  #define VALUE_SIZE_INCREMENT 1

  VOID
  ShowMainPage (
    VOID
    );

  VOID
  PressStop (
    VOID
    );

  EFI_STATUS
  SetCreateVariable (
    VOID
    );

  EFI_STATUS
  DeleteVariable (
    VOID
    );

  UINT64
  InputValueH (
    VOID
    );

  UINT64 
  Power (
    UINT64 Base, 
    UINT64 Index
    );

  EFI_GUID 
  ParseGuid (
    UINT64 *Buffer
    );

  CHAR16* 
  InputWord (
    VOID
    );

  UINT64
  InputValueD (
    VOID
    );

  UINT64*
  InputGuid (
    UINT64  *Buffer
    );

  EFI_STATUS
  SearchAllVariable (
    VOID
    );

  EFI_STATUS
  SearchVariableByName (
    VOID
    );

  EFI_STATUS
  SearchVariableByGuid (
    VOID
    );

  VOID
  InitializeArray_8 (
    CHAR8 *Buffer,
    UINT64 BufferSize
    );

  VOID
  InitializeArray_16 (
    CHAR16 *Buffer,
    UINT64 BufferSize
    );

  EFI_STATUS
  EFIAPI
  UefiMain (
    IN EFI_HANDLE ImageHandle, 
    IN EFI_SYSTEM_TABLE *SystemTable
    )
  {
    EFI_STATUS      Status;
    EFI_INPUT_KEY   InputKey;

    gST->ConOut->ClearScreen(gST->ConOut);
    ShowMainPage();

    while (TRUE) {
      gST->ConIn->ReadKeyStroke(gST->ConIn, &InputKey);

      if (InputKey.ScanCode == SCAN_ESC) {
        gST->ConOut->ClearScreen(gST->ConOut);
        break;
      }

      switch (InputKey.ScanCode) {

      case SCAN_F1:
        gST->ConOut->ClearScreen(gST->ConOut);
        SearchAllVariable();
        PressStop();
        ShowMainPage();
        continue;

      case SCAN_F2:
        gST->ConOut->ClearScreen(gST->ConOut);
        SearchVariableByName();
        PressStop();
        ShowMainPage();
        continue;

      case SCAN_F3:
        gST->ConOut->ClearScreen(gST->ConOut);
        SearchVariableByGuid();
        PressStop();
        ShowMainPage();
        continue;

      case SCAN_F4:
        gST->ConOut->ClearScreen(gST->ConOut);
        SetCreateVariable();
        PressStop();
        ShowMainPage();
        continue;
      
      case SCAN_F5:
        gST->ConOut->ClearScreen(gST->ConOut);
        DeleteVariable();
        PressStop();
        ShowMainPage();
        continue;
      }
    }

    Status = EFI_SUCCESS;

    return Status; 
  }


  UINT64*
  InputGuid (
    UINT64  *Buffer
    )
  {
    EFI_INPUT_KEY        InputKey;
    INT32                WriteCount;

    WriteCount = 0;

    while (TRUE) {
      gST->ConIn->ReadKeyStroke(gST->ConIn, &InputKey);

      if (WriteCount == 32) {
        return Buffer;
      }

      if (('a' <= InputKey.UnicodeChar && InputKey.UnicodeChar <= 'f')) {
        
        Buffer[WriteCount] = InputKey.UnicodeChar - 87;
        Print(L"%c", InputKey.UnicodeChar);
        WriteCount++;
        
        continue;

      } else if (('0' <= InputKey.UnicodeChar && InputKey.UnicodeChar <= '9')) {
        Buffer[WriteCount] = InputKey.UnicodeChar - 48;
        Print(L"%c", InputKey.UnicodeChar);
        WriteCount++;

        continue;
      } else if (InputKey.UnicodeChar == CHAR_BACKSPACE) {

        WriteCount--;
      
        if(WriteCount < 0) {
          WriteCount = 0;
        } 
      
        Buffer[WriteCount] = CHAR_NULL;
        Print(L"%c", InputKey.UnicodeChar);

        continue;
      }
    }
  }


  EFI_STATUS
  SearchVariableByGuid (
    VOID
    )
  {
    EFI_STATUS      Status;
    EFI_INPUT_KEY   InputKey;
    UINT32          Count;
    UINT32          i;

    UINT64          VariableSize;
    CHAR16          *VariableName;
    EFI_GUID        VendorGuid;

    UINT64          OldNameSize;
    CHAR16          *OldName;
      
    UINT32          Attributes;
    UINT64          DataSize;
    UINT8           *Data;

    UINT64          OldDataSize;
    UINT8           *OldData;

    UINT64          Buffer[32];
    EFI_GUID        SearchGuid;

    VariableSize = 2;
    VariableName = AllocateZeroPool(VariableSize);

    Attributes = 0;
    DataSize = 0;
    Data = AllocateZeroPool(DataSize);
    
    Print(L"Please input search GUID.\n");
    SearchGuid = ParseGuid(InputGuid(Buffer));

    gST->ConOut->ClearScreen(gST->ConOut);

    Count = 1;
    while (TRUE) {
      OldNameSize = VariableSize;
      OldName = VariableName;
      OldDataSize = DataSize;
      OldData = Data;

      Status = gRT->GetNextVariableName(
                                  &VariableSize,
                                  VariableName,
                                  &VendorGuid 
                                  );
      if (EFI_ERROR(Status) && Status != EFI_BUFFER_TOO_SMALL) {
        Print(L"%r\n", Status);
        Print(L"Press any key to back main page.\n");
        break;
      }

      if (Status == EFI_BUFFER_TOO_SMALL) {
        VariableName = ReallocatePool(OldNameSize, VariableSize, NULL);
        InitializeArray_16(VariableName, VariableSize);
        gBS->CopyMem(VariableName, OldName, OldNameSize);
        Status = gRT->GetNextVariableName(
                                  &VariableSize,
                                  VariableName,
                                  &VendorGuid 
                                  );
        if (EFI_ERROR(Status)) {
          Print(L"%r\n", Status);
          break;
        }

        Status = gRT->GetVariable(
                              VariableName,
                              &VendorGuid,
                              &Attributes,
                              &DataSize,
                              (VOID*)Data
                              );
        if (EFI_ERROR(Status) && Status != EFI_BUFFER_TOO_SMALL) {
          Print(L"%r\n", Status);
          break;
        } 
        
        if (Status == EFI_BUFFER_TOO_SMALL) {
          Data = ReallocatePool(OldDataSize, DataSize, NULL);
          InitializeArray_8(Data, DataSize);
          gBS->CopyMem(Data, OldData, OldDataSize);
          Status = gRT->GetVariable(
                              VariableName,
                              &VendorGuid,
                              &Attributes,
                              &DataSize,
                              (VOID*)Data
                              );
          if (EFI_ERROR(Status)) {
            Print(L"%r\n", Status);
            break;
          }
          if (CompareMem(&SearchGuid, &VendorGuid, sizeof(EFI_GUID)) == EFI_SUCCESS) {
            Print(L"No. %d\n", Count);
            Print(L"Variable Name : %s\n", VariableName);
            Print(L"Variable GUID : %g\n", VendorGuid);
            Print(L"Attributes    : %d\n", Attributes);
            Print(L"Data Size     : %d\n", DataSize);
            Print(L"Data :\n");
            for (i = 0; i < DataSize; i++) {
              Print(L"%3.2x", *(Data + i));
              if ((i % 16) == 15 || i == DataSize - 1) Print(L"\n");
            }
            gST->ConOut->SetAttribute(gST->ConOut, EFI_WHITE | EFI_BACKGROUND_BLACK);
            Print(L"[Down]:Next   [Esc]:Escape\n");
            gST->ConOut->SetAttribute(gST->ConOut, EFI_LIGHTGRAY | EFI_BACKGROUND_BLACK);
          }

        } else {
          if (CompareMem(&SearchGuid, &VendorGuid, sizeof(EFI_GUID)) == EFI_SUCCESS) {
            Print(L"No. %d\n", Count);
            Print(L"Variable Name : %s\n", VariableName);
            Print(L"Variable GUID : %g\n", VendorGuid);
            Print(L"Attributes    : %d\n", Attributes);
            Print(L"Data Size     : %d\n", DataSize);
            Print(L"Data :\n");
            for (i = 0; i < DataSize; i++) {
              Print(L"%3.2x", *(Data + i));
              if ((i % 16) == 15 || i == DataSize - 1) Print(L"\n");
            }
            gST->ConOut->SetAttribute(gST->ConOut, EFI_WHITE | EFI_BACKGROUND_BLACK);
            Print(L"[Down]:Next   [Esc]:Escape\n");
            gST->ConOut->SetAttribute(gST->ConOut, EFI_LIGHTGRAY | EFI_BACKGROUND_BLACK);
          }
        }

      } else {
        Status = gRT->GetVariable(
                              VariableName,
                              &VendorGuid,
                              &Attributes,
                              &DataSize,
                              (VOID*)Data
                              );
        if (EFI_ERROR(Status) && Status != EFI_BUFFER_TOO_SMALL) {
          Print(L"%r\n", Status);
          break;
        } 
        
        if (Status == EFI_BUFFER_TOO_SMALL) {
          Data = ReallocatePool(OldDataSize, DataSize, NULL);
          InitializeArray_8(Data, DataSize);
          gBS->CopyMem(Data, OldData, OldDataSize);
          Status = gRT->GetVariable(
                              VariableName,
                              &VendorGuid,
                              &Attributes,
                              &DataSize,
                              (VOID*)Data
                              );
          if (EFI_ERROR(Status)) {
            Print(L"%r\n", Status);
            break;
          }
          if (CompareMem(&SearchGuid, &VendorGuid, sizeof(EFI_GUID)) == EFI_SUCCESS) {
            Print(L"No. %d\n", Count);
            Print(L"Variable Name : %s\n", VariableName);
            Print(L"Variable GUID : %g\n", VendorGuid);
            Print(L"Attributes    : %d\n", Attributes);
            Print(L"Data Size     : %d\n", DataSize);
            Print(L"Data :\n");
            for (i = 0; i < DataSize; i++) {
              Print(L"%3.2x", *(Data + i));
              if ((i % 16) == 15 || i == DataSize - 1) Print(L"\n");
            }
            gST->ConOut->SetAttribute(gST->ConOut, EFI_WHITE | EFI_BACKGROUND_BLACK);
            Print(L"[Down]:Next   [Esc]:Escape\n");
            gST->ConOut->SetAttribute(gST->ConOut, EFI_LIGHTGRAY | EFI_BACKGROUND_BLACK);
          }
    
        } else {
          if (CompareMem(&SearchGuid, &VendorGuid, sizeof(EFI_GUID)) == EFI_SUCCESS) {
            Print(L"No. %d\n", Count);
            Print(L"Variable Name : %s\n", VariableName);
            Print(L"Variable GUID : %g\n", VendorGuid);
            Print(L"Attributes    : %d\n", Attributes);
            Print(L"Data Size     : %d\n", DataSize);
            Print(L"Data :\n");
            for (i = 0; i < DataSize; i++) {
              Print(L"%3.2x", *(Data + i));
              if ((i % 16) == 15 || i == DataSize - 1) Print(L"\n");
            }
            gST->ConOut->SetAttribute(gST->ConOut, EFI_WHITE | EFI_BACKGROUND_BLACK);
            Print(L"[Down]:Next   [Esc]:Escape\n");
            gST->ConOut->SetAttribute(gST->ConOut, EFI_LIGHTGRAY | EFI_BACKGROUND_BLACK);
          }
        }
      }
      
      while (CompareMem(&SearchGuid, &VendorGuid, sizeof(EFI_GUID)) == EFI_SUCCESS) {
        gST->ConIn->ReadKeyStroke(gST->ConIn, &InputKey);

        if (InputKey.ScanCode == SCAN_ESC) {
          gST->ConOut->ClearScreen(gST->ConOut);
          Print(L"Press any key to back main page.\n");
          goto GuidExit;
        }

        if (InputKey.ScanCode == SCAN_DOWN) {
          gST->ConOut->ClearScreen(gST->ConOut);
          Count++;
          break;
        }
      }
    }   


    GuidExit:

    FreePool(VariableName);
    FreePool(Data);
    Status = EFI_SUCCESS;

    return Status;
  }

  CHAR16* 
  InputWord (
    VOID
    )
  {
    EFI_INPUT_KEY    InputKey;
    INT32            Count;           // The amount of we input.
    UINT32           AllocateSize;
    UINT32           i;               // For loop count.
    CHAR16           *Buffer;
    CHAR16           *OldBuffer;

    Count = 0;
    AllocateSize = WORD_INITIAL_SIZE;
    Buffer = NULL;
    OldBuffer = NULL;

    Buffer = AllocatePool(AllocateSize);
    InitializeArray_16(Buffer, AllocateSize);

    while (TRUE) {
      gST->ConIn->ReadKeyStroke(gST->ConIn, &InputKey);

      if (Count >= (INT32)AllocateSize) {
        OldBuffer = Buffer;
        Buffer = ReallocatePool(AllocateSize, AllocateSize + WORD_SIZE_INCREMENT, NULL);
        AllocateSize += WORD_SIZE_INCREMENT;
        InitializeArray_16(Buffer, AllocateSize);
        for (i = 0; i < AllocateSize - WORD_SIZE_INCREMENT; i++) {
          Buffer[i] = OldBuffer[i];
        }
      }

      switch(InputKey.UnicodeChar){
      case CHAR_NULL:
        continue;
      
      case CHAR_CARRIAGE_RETURN:
        *(Buffer + AllocateSize) = 0;
        FreePool(OldBuffer);
        return Buffer;
      
      case CHAR_BACKSPACE:
        Count--;
        if (Count < 0) {
          Count = 0;
        }
        Buffer[Count] = CHAR_NULL;
        Print(L"%c", InputKey.UnicodeChar); 
        
        continue;

      default:
        Buffer[Count] = InputKey.UnicodeChar;
        Print(L"%c", InputKey.UnicodeChar);
        Count++;
        continue;
      }
    }
  }

  EFI_STATUS
  DeleteVariable (
    VOID
    )
  {
    EFI_STATUS      Status;

    CHAR16          *VariableName;
    EFI_GUID        VendorGuid;

    UINT32          Attributes;
    UINT64          DataSize;
    UINT8           *Data;

    UINT64          GuidBuffer[32];

    Attributes = 0;
    DataSize = 0;
    Data = NULL;

    gST->ConOut->ClearScreen(gST->ConOut);

    Print(L"Please input name.\n");
    VariableName = InputWord();

    Print(L"\nPlease input GUID.\n");
    VendorGuid = ParseGuid(InputGuid(GuidBuffer));

    Status = gRT->SetVariable(
                          VariableName,
                          &VendorGuid,
                          Attributes,
                          DataSize,
                          Data
                          );
    if (EFI_ERROR(Status)) {
      Print(L"%r\n", Status);
      return Status;

    } else {
      Print(L"\nDelete done.\n");
      Print(L"Press any key to back main page.\n");
      return Status;
    } 
  }

  EFI_STATUS
  SetCreateVariable (
    VOID
    )
  {
    EFI_STATUS      Status;
    CHAR16          *VariableName;
    EFI_GUID        VendorGuid;
    UINT32          Attributes;
    UINT64          DataSize;
    UINT8           *Data;
    UINT32 i;

    UINT64          GuidBuffer[32];

    gST->ConOut->ClearScreen(gST->ConOut);

    Print(L"Please input name.\n");
    VariableName = InputWord();

    Print(L"\nPlease input GUID.\n");
    VendorGuid = ParseGuid(InputGuid(GuidBuffer));

    Print(L"\nPlease input attributes.\n");
    Attributes = (UINT32)InputValueD();

    Print(L"\nPlease input data size.\n");
    DataSize = InputValueD();

    Print(L"\nPlease input data in byte.\n");
    Data = AllocateZeroPool(DataSize);
    for (i = 0; i < DataSize; i++) {
      Print(L" ");
      *(Data + (UINT8)i) = (UINT8)InputValueH();
      if ((i % 16) == 15) Print(L"\n");
    }

    Status = gRT->SetVariable(
                          VariableName,
                          &VendorGuid,
                          Attributes,
                          DataSize,
                          Data
                          );
    if (EFI_ERROR(Status)) {
      Print(L"%r\n", Status);
      return Status;

    } else {
      Print(L"\nSet done.\n");
      Print(L"Press any key to back main page.\n");
      return Status;
    }  
  }

  UINT64
  InputValueH (
    VOID
    )
  {
    EFI_INPUT_KEY    InputKey;
    INT64            Count;           // The amount of we input.
    UINT64           AllocateSize;
    UINT64           i;               // For loop count.
    CHAR8           *Buffer;
    CHAR8           *OldBuffer;

    UINT64          ReturnValue;

    Count = 0;
    AllocateSize = VALUE_INITIAL_SIZE;
    Buffer = NULL;
    OldBuffer = NULL;

    ReturnValue = 0;

    Buffer = AllocatePool(AllocateSize);
    InitializeArray_8(Buffer, AllocateSize);

    while (TRUE) {
      gST->ConIn->ReadKeyStroke(gST->ConIn, &InputKey);

      if (Count >= (INT64)AllocateSize) {
        OldBuffer = Buffer;
        Buffer = ReallocatePool(AllocateSize, AllocateSize + VALUE_SIZE_INCREMENT, NULL);
        AllocateSize += VALUE_SIZE_INCREMENT;
        InitializeArray_8(Buffer, AllocateSize);
        for (i = 0; i < (AllocateSize - VALUE_SIZE_INCREMENT); i++) {
          Buffer[i] = OldBuffer[i];
        }
      }

      if (('0' <= InputKey.UnicodeChar && InputKey.UnicodeChar <= '9')) {
        Buffer[Count] = (CHAR8)InputKey.UnicodeChar - 48;
        Print(L"%x", Buffer[Count]);
        Count++;
        continue;

      } else if (('a' <= InputKey.UnicodeChar && InputKey.UnicodeChar <= 'f')) {
        Buffer[Count] = (CHAR8)InputKey.UnicodeChar - 87;
        Print(L"%x", Buffer[Count]);
        Count++;
        continue;

      } else if (InputKey.UnicodeChar == CHAR_BACKSPACE) {
        Count--;
        if (Count < 0) {
          Count = 0;
        }
        Buffer[Count] = CHAR_NULL;
        Print(L"%c", InputKey.UnicodeChar);
        continue;

      } else if (InputKey.UnicodeChar == CHAR_CARRIAGE_RETURN) {
        for (i = 0; i < (UINT64)Count; i++) {
          ReturnValue += Buffer[i] * Power((UINT64)0x10, (UINT64)(Count-i-1));            
        }
        
        FreePool(Buffer);
        FreePool(OldBuffer);
        return ReturnValue;
      }
    }
  }

  UINT64
  InputValueD (
    VOID
    )
  {
    EFI_INPUT_KEY    InputKey;
    INT64            Count;           // The amount of we input.
    UINT64           AllocateSize;
    UINT64           i;               // For loop count.
    CHAR8           *Buffer;
    CHAR8           *OldBuffer;

    UINT64          ReturnValue;

    Count = 0;
    AllocateSize = VALUE_INITIAL_SIZE;
    // AllocateSize = 0;
    Buffer = NULL;
    OldBuffer = NULL;

    ReturnValue = 0;

    Buffer = AllocatePool(AllocateSize);
    InitializeArray_8(Buffer, AllocateSize);

    while (TRUE) {
      gST->ConIn->ReadKeyStroke(gST->ConIn, &InputKey);

      if (Count >= (INT64)AllocateSize) {
        OldBuffer = Buffer;
        Buffer = ReallocatePool(AllocateSize, AllocateSize + VALUE_SIZE_INCREMENT, NULL);
        AllocateSize += VALUE_SIZE_INCREMENT;
        InitializeArray_8(Buffer, AllocateSize);
        for (i = 0; i < (AllocateSize - VALUE_SIZE_INCREMENT); i++) {
          Buffer[i] = OldBuffer[i];
        }
      }

      if (('0' <= InputKey.UnicodeChar && InputKey.UnicodeChar <= '9')) {
        Buffer[Count] = (CHAR8)InputKey.UnicodeChar - 48;
        Print(L"%d", Buffer[Count]);
        Count++;
        continue;

      } else if (InputKey.UnicodeChar == CHAR_BACKSPACE) {
        Count--;
        if (Count < 0) {
          Count = 0;
        }
        Buffer[Count] = CHAR_NULL;
        Print(L"%c", InputKey.UnicodeChar);
        continue;

      } else if (InputKey.UnicodeChar == CHAR_CARRIAGE_RETURN) {
        for (i = 0; i < (UINT64)Count; i++) {
          ReturnValue += Buffer[i] * Power((UINT64)10, (UINT64)(Count-i-1));            
        }
        
        FreePool(Buffer);
        FreePool(OldBuffer);
        return ReturnValue;
      }
    }
  }

  UINT64 
  Power (
    UINT64 Base,
    UINT64 Index
    )
  {  
    if (Index == 0) {
      return 1;
    } else {
      return (Base * Power(Base, Index-1));
    }
  }

  EFI_GUID 
  ParseGuid (
    UINT64 *Buffer
    )
  {
    EFI_GUID TestGuid;
    UINT32   i;
    UINT32   j;
    
    TestGuid.Data1 = 0;
    TestGuid.Data2 = 0;
    TestGuid.Data3 = 0;
    

    for (i = 0; i < 8; i++) {
      TestGuid.Data4[i] = 0;
    }

    for (i = 0; i < 8; i++) {
      TestGuid.Data1 |= Buffer[i] << ((8-i-1) * 4);
    }

    for (i = 8; i < 12; i++) {
      TestGuid.Data2 |= Buffer[i] << ((12-i-1) * 4);
    }

    for (i = 12; i < 16; i++) {
      TestGuid.Data3 |= Buffer[i] << ((16-i-1) * 4);
    }

    for (j = 0; j < 8; j++) {
      for (i = 16 + 2*j; i < 18 + 2*j; i++) {
        TestGuid.Data4[j] |= Buffer[i] << (((18+2*j)-i-1) * 4);
      }
    }

    return TestGuid;
  }

  EFI_STATUS
  SearchVariableByName (
    VOID
    )
  {
    EFI_STATUS      Status;
    EFI_INPUT_KEY   InputKey;
    UINT32          Count;
    UINT32          i;

    UINT64          VariableSize;
    CHAR16          *VariableName;
    EFI_GUID        VendorGuid;

    UINT64          OldNameSize;
    CHAR16          *OldName;
      
    UINT32          Attributes;
    UINT64          DataSize;
    UINT8           *Data;

    UINT64          OldDataSize;
    UINT8           *OldData;

    CHAR16          *SearchName;

    VariableSize = 2;
    VariableName = AllocateZeroPool(VariableSize);

    Attributes = 0;
    DataSize = 0;
    Data = AllocateZeroPool(DataSize);

    Print(L"Please input search name.\n");
    SearchName = InputWord();

    gST->ConOut->ClearScreen(gST->ConOut);

    Count = 1;
    while (TRUE) {
      OldNameSize = VariableSize;
      OldName = VariableName;
      OldDataSize = DataSize;
      OldData = Data;

      Status = gRT->GetNextVariableName(
                                  &VariableSize,
                                  VariableName,
                                  &VendorGuid 
                                  );
      if (EFI_ERROR(Status) && Status != EFI_BUFFER_TOO_SMALL) {
        Print(L"%r\n", Status);
        Print(L"Press any key to back main page.\n");
        break;
      }

      if (Status == EFI_BUFFER_TOO_SMALL) {
        VariableName = ReallocatePool(OldNameSize, VariableSize, NULL);
        InitializeArray_16(VariableName, VariableSize);
        gBS->CopyMem(VariableName, OldName, OldNameSize);
        Status = gRT->GetNextVariableName(
                                  &VariableSize,
                                  VariableName,
                                  &VendorGuid 
                                  );
        if (EFI_ERROR(Status)) {
          Print(L"%r\n", Status);
          break;
        }

        Status = gRT->GetVariable(
                              VariableName,
                              &VendorGuid,
                              &Attributes,
                              &DataSize,
                              (VOID*)Data
                              );
        if (EFI_ERROR(Status) && Status != EFI_BUFFER_TOO_SMALL) {
          Print(L"%r\n", Status);
          break;
        } 
        
        if (Status == EFI_BUFFER_TOO_SMALL) {
          Data = ReallocatePool(OldDataSize, DataSize, NULL);
          InitializeArray_8(Data, DataSize);
          gBS->CopyMem(Data, OldData, OldDataSize);
          Status = gRT->GetVariable(
                              VariableName,
                              &VendorGuid,
                              &Attributes,
                              &DataSize,
                              (VOID*)Data
                              );
          if (EFI_ERROR(Status)) {
            Print(L"%r\n", Status);
            break;
          }
          if (StrCmp(SearchName, VariableName) == EFI_SUCCESS) {
            Print(L"No. %d\n", Count);
            Print(L"Variable Name : %s\n", VariableName);
            Print(L"Variable GUID : %g\n", VendorGuid);
            Print(L"Attributes    : %d\n", Attributes);
            Print(L"Data Size     : %d\n", DataSize);
            Print(L"Data :\n");
            for (i = 0; i < DataSize; i++) {
              Print(L"%3.2x", *(Data + i));
              if ((i % 16) == 15 || i == DataSize - 1) Print(L"\n");
            }
            gST->ConOut->SetAttribute(gST->ConOut, EFI_WHITE | EFI_BACKGROUND_BLACK);
            Print(L"[Down]:Next   [Esc]:Escape\n");
            gST->ConOut->SetAttribute(gST->ConOut, EFI_LIGHTGRAY | EFI_BACKGROUND_BLACK);
          }

        } else {
          if (StrCmp(SearchName, VariableName) == EFI_SUCCESS) {
            Print(L"No. %d\n", Count);
            Print(L"Variable Name : %s\n", VariableName);
            Print(L"Variable GUID : %g\n", VendorGuid);
            Print(L"Attributes    : %d\n", Attributes);
            Print(L"Data Size     : %d\n", DataSize);
            Print(L"Data :\n");
            for (i = 0; i < DataSize; i++) {
              Print(L"%3.2x", *(Data + i));
              if ((i % 16) == 15 || i == DataSize - 1) Print(L"\n");
            }
            gST->ConOut->SetAttribute(gST->ConOut, EFI_WHITE | EFI_BACKGROUND_BLACK);
            Print(L"[Down]:Next   [Esc]:Escape\n");
            gST->ConOut->SetAttribute(gST->ConOut, EFI_LIGHTGRAY | EFI_BACKGROUND_BLACK);
          }
        }

      } else {
        Status = gRT->GetVariable(
                              VariableName,
                              &VendorGuid,
                              &Attributes,
                              &DataSize,
                              (VOID*)Data
                              );
        if (EFI_ERROR(Status) && Status != EFI_BUFFER_TOO_SMALL) {
          Print(L"%r\n", Status);
          break;
        } 
        
        if (Status == EFI_BUFFER_TOO_SMALL) {
          Data = ReallocatePool(OldDataSize, DataSize, NULL);
          InitializeArray_8(Data, DataSize);
          gBS->CopyMem(Data, OldData, OldDataSize);
          Status = gRT->GetVariable(
                              VariableName,
                              &VendorGuid,
                              &Attributes,
                              &DataSize,
                              (VOID*)Data
                              );
          if (EFI_ERROR(Status)) {
            Print(L"%r\n", Status);
            break;
          }
          if (StrCmp(SearchName, VariableName) == EFI_SUCCESS) {
            Print(L"No. %d\n", Count);
            Print(L"Variable Name : %s\n", VariableName);
            Print(L"Variable GUID : %g\n", VendorGuid);
            Print(L"Attributes    : %d\n", Attributes);
            Print(L"Data Size     : %d\n", DataSize);
            Print(L"Data :\n");
            for (i = 0; i < DataSize; i++) {
              Print(L"%3.2x", *(Data + i));
              if ((i % 16) == 15 || i == DataSize - 1) Print(L"\n");
            }
            gST->ConOut->SetAttribute(gST->ConOut, EFI_WHITE | EFI_BACKGROUND_BLACK);
            Print(L"[Down]:Next   [Esc]:Escape\n");
            gST->ConOut->SetAttribute(gST->ConOut, EFI_LIGHTGRAY | EFI_BACKGROUND_BLACK);
          }
    
        } else {
          if (StrCmp(SearchName, VariableName) == EFI_SUCCESS) {
            Print(L"No. %d\n", Count);
            Print(L"Variable Name : %s\n", VariableName);
            Print(L"Variable GUID : %g\n", VendorGuid);
            Print(L"Attributes    : %d\n", Attributes);
            Print(L"Data Size     : %d\n", DataSize);
            Print(L"Data :\n");
            for (i = 0; i < DataSize; i++) {
              Print(L"%3.2x", *(Data + i));
              if ((i % 16) == 15 || i == DataSize - 1) Print(L"\n");
            }
            gST->ConOut->SetAttribute(gST->ConOut, EFI_WHITE | EFI_BACKGROUND_BLACK);
            Print(L"[Down]:Next   [Esc]:Escape\n");
            gST->ConOut->SetAttribute(gST->ConOut, EFI_LIGHTGRAY | EFI_BACKGROUND_BLACK);
          }
        }
      }
      
      while (StrCmp(SearchName, VariableName) == EFI_SUCCESS) {
        gST->ConIn->ReadKeyStroke(gST->ConIn, &InputKey);

        if (InputKey.ScanCode == SCAN_ESC) {
          gST->ConOut->ClearScreen(gST->ConOut);
          Print(L"Press any key to back main page.\n");
          goto NameExit;
        }

        if (InputKey.ScanCode == SCAN_DOWN) {
          gST->ConOut->ClearScreen(gST->ConOut);
          Count++;
          break;
        }
      }
    }   


    NameExit:

    FreePool(VariableName);
    FreePool(Data);
    Status = EFI_SUCCESS;

    return Status;
  }


  EFI_STATUS
  SearchAllVariable (
    VOID
    )
  {
    EFI_STATUS      Status;
    EFI_INPUT_KEY   InputKey;
    UINT32          Count;
    UINT32          i;

    UINT64          VariableSize;
    CHAR16          *VariableName;
    EFI_GUID        VendorGuid;

    UINT64          OldNameSize;
    CHAR16          *OldName;
      
    UINT32          Attributes;
    UINT64          DataSize;
    UINT8           *Data;

    UINT64          OldDataSize;
    UINT8           *OldData;

    VariableSize = 2;
    VariableName = AllocateZeroPool(VariableSize);

    Attributes = 0;
    DataSize = 0;
    Data = AllocateZeroPool(DataSize);

    Count = 1;
    while (TRUE) {
      OldNameSize = VariableSize;
      OldName = VariableName;
      OldDataSize = DataSize;
      OldData = Data;

      Status = gRT->GetNextVariableName(
                                  &VariableSize,
                                  VariableName,
                                  &VendorGuid 
                                  );
      if (EFI_ERROR(Status) && Status != EFI_BUFFER_TOO_SMALL) {
        Print(L"%r\n", Status);
        Print(L"Press any key to back main page.\n");
        break;
      }

      if (Status == EFI_BUFFER_TOO_SMALL) {
        VariableName = ReallocatePool(OldNameSize, VariableSize, NULL);
        InitializeArray_16(VariableName, VariableSize);
        gBS->CopyMem(VariableName, OldName, OldNameSize);
        Status = gRT->GetNextVariableName(
                                  &VariableSize,
                                  VariableName,
                                  &VendorGuid 
                                  );
        if (EFI_ERROR(Status)) {
          Print(L"%r\n", Status);
          break;
        }

        Status = gRT->GetVariable(
                              VariableName,
                              &VendorGuid,
                              &Attributes,
                              &DataSize,
                              (VOID*)Data
                              );
        if (EFI_ERROR(Status) && Status != EFI_BUFFER_TOO_SMALL) {
          Print(L"%r\n", Status);
          break;
        } 
        
        if (Status == EFI_BUFFER_TOO_SMALL) {
          Data = ReallocatePool(OldDataSize, DataSize, NULL);
          InitializeArray_8(Data, DataSize);
          gBS->CopyMem(Data, OldData, OldDataSize);
          Status = gRT->GetVariable(
                              VariableName,
                              &VendorGuid,
                              &Attributes,
                              &DataSize,
                              (VOID*)Data
                              );
          if (EFI_ERROR(Status)) {
            Print(L"%r\n", Status);
            break;
          }
          Print(L"No. %d\n", Count);
          Print(L"Variable Name : %s\n", VariableName);
          Print(L"Variable GUID : %g\n", VendorGuid);
          Print(L"Attributes    : %d\n", Attributes);
          Print(L"Data Size     : %d\n", DataSize);
          Print(L"Data :\n");
          for (i = 0; i < DataSize; i++) {
            Print(L"%3.2x", *(Data + i));
            if ((i % 16) == 15 || i == DataSize - 1) Print(L"\n");
          }
          gST->ConOut->SetAttribute(gST->ConOut, EFI_WHITE | EFI_BACKGROUND_BLACK);
          Print(L"[Down]:Next   [Esc]:Escape\n");
          gST->ConOut->SetAttribute(gST->ConOut, EFI_LIGHTGRAY | EFI_BACKGROUND_BLACK);

        } else {
          Print(L"No. %d\n", Count);
          Print(L"Variable Name : %s\n", VariableName);
          Print(L"Variable GUID : %g\n", VendorGuid);
          Print(L"Attributes    : %d\n", Attributes);
          Print(L"Data Size     : %d\n", DataSize);
          Print(L"Data :\n");
          for (i = 0; i < DataSize; i++) {
            Print(L"%3.2x", *(Data + i));
            if ((i % 16) == 15 || i == DataSize - 1) Print(L"\n");
          }
          gST->ConOut->SetAttribute(gST->ConOut, EFI_WHITE | EFI_BACKGROUND_BLACK);
          Print(L"[Down]:Next   [Esc]:Escape\n");
          gST->ConOut->SetAttribute(gST->ConOut, EFI_LIGHTGRAY | EFI_BACKGROUND_BLACK);
        }

      } else {
        Status = gRT->GetVariable(
                              VariableName,
                              &VendorGuid,
                              &Attributes,
                              &DataSize,
                              (VOID*)Data
                              );
        if (EFI_ERROR(Status) && Status != EFI_BUFFER_TOO_SMALL) {
          Print(L"%r\n", Status);
          break;
        } 
        
        if (Status == EFI_BUFFER_TOO_SMALL) {
          Data = ReallocatePool(OldDataSize, DataSize, NULL);
          InitializeArray_8(Data, DataSize);
          gBS->CopyMem(Data, OldData, OldDataSize);
          Status = gRT->GetVariable(
                              VariableName,
                              &VendorGuid,
                              &Attributes,
                              &DataSize,
                              (VOID*)Data
                              );
          if (EFI_ERROR(Status)) {
            Print(L"%r\n", Status);
            break;
          }
          Print(L"No. %d\n", Count);
          Print(L"Variable Name : %s\n", VariableName);
          Print(L"Variable GUID : %g\n", VendorGuid);
          Print(L"Attributes    : %d\n", Attributes);
          Print(L"Data Size     : %d\n", DataSize);
          Print(L"Data :\n");
          for (i = 0; i < DataSize; i++) {
            Print(L"%3.2x", *(Data + i));
            if ((i % 16) == 15 || i == DataSize - 1) Print(L"\n");
          }
          gST->ConOut->SetAttribute(gST->ConOut, EFI_WHITE | EFI_BACKGROUND_BLACK);
          Print(L"[Down]:Next   [Esc]:Escape\n");
          gST->ConOut->SetAttribute(gST->ConOut, EFI_LIGHTGRAY | EFI_BACKGROUND_BLACK);
    
        } else {
          Print(L"No. %d\n", Count);
          Print(L"Variable Name : %s\n", VariableName);
          Print(L"Variable GUID : %g\n", VendorGuid);
          Print(L"Attributes    : %d\n", Attributes);
          Print(L"Data Size     : %d\n", DataSize);
          Print(L"Data :\n");
          for (i = 0; i < DataSize; i++) {
            Print(L"%3.2x", *(Data + i));
            if ((i % 16) == 15 || i == DataSize - 1) Print(L"\n");
          }
          gST->ConOut->SetAttribute(gST->ConOut, EFI_WHITE | EFI_BACKGROUND_BLACK);
          Print(L"[Down]:Next   [Esc]:Escape\n");
          gST->ConOut->SetAttribute(gST->ConOut, EFI_LIGHTGRAY | EFI_BACKGROUND_BLACK);
        }
      }

      while (TRUE) {
        gST->ConIn->ReadKeyStroke(gST->ConIn, &InputKey);

        if (InputKey.ScanCode == SCAN_ESC) {
          gST->ConOut->ClearScreen(gST->ConOut);
          Print(L"Press any key to back main page.\n");
          goto AllExit;
        }

        if (InputKey.ScanCode == SCAN_DOWN) {
          gST->ConOut->ClearScreen(gST->ConOut);
          Count++;
          break;
        }
      }
    }   


    AllExit:

    FreePool(VariableName);
    FreePool(Data);

    Status = EFI_SUCCESS;

    return Status;
  }

  VOID
  InitializeArray_16(
    CHAR16 *Array,
    UINT64 ArraySize
    )
  {
    UINT32  i;  // For loop count.

    for (i = 0; i < ArraySize; i++) {
      *(Array + i) = 0;
    }

    return;
  }

  VOID
  InitializeArray_8(
    CHAR8 *Array,
    UINT64 ArraySize
    )
  {
    UINT32  i;  // For loop count.

    for (i = 0; i < ArraySize; i++) {
      *(Array + i) = 0;
    }

    return;
  }

  VOID
  ShowMainPage (
    VOID
    )
  {
    gST->ConOut->ClearScreen(gST->ConOut);
    gST->ConOut->SetCursorPosition(gST->ConOut, 0, 0);
    gST->ConOut->EnableCursor(gST->ConOut, FALSE);

    Print(L"15-Variable\n\n");  
    Print(L"[F1].  Search all variable.\n");
    Print(L"[F2].  Search variable by name.\n");
    Print(L"[F3].  Search variable by GUID.\n");
    Print(L"[F4].  Set/Create variable.\n");
    Print(L"[F5].  Delete variable.\n");
    Print(L"[Esc]. Escape\n");

    return;
  }

  VOID
  PressStop (
    VOID
    )
  {
    EFI_INPUT_KEY   InputKey;

    while (TRUE) {
      gST->ConIn->ReadKeyStroke(gST->ConIn, &InputKey);
      if(InputKey.UnicodeChar != CHAR_NULL || InputKey.ScanCode != SCAN_NULL) {
        return;
      }
    }
  }
*/

/*// tool.h
  #include "_test.h"

  //
  // Tool of String
  //
  #define max(a, b) (a > b ? a : b)
  #define String Str*                   // String 為一指標

  //
  // Tool of String
  //
  typedef struct {
    UINT64 len;
    UINT64 size;
    CHAR16 *s;
  } Str;

  Str* 
  StrNew (
    VOID
    );

  VOID 
  StrAppend (
    Str *str, 
    CHAR16 *s
    );

  EFI_STATUS
  EFIAPI
  UefiMain (
    IN EFI_HANDLE ImageHandle, 
    IN EFI_SYSTEM_TABLE *SystemTable
    )
  {
    EFI_STATUS  Status;  

    String str = StrNew();

    CHAR16 *str1 = L"Hello";
    CHAR16 *str2 = L"World";

    StrAppend(str, str1);
    StrAppend(str, str2);

    Print(L"%s\n", str->s);
    
    Status = EFI_SUCCESS;

    return Status;
  }
*/

/*// tool.c
  #include "_tool.h"

  Str* 
  StrNew (
    VOID
    ) 
  {
    Str *str = AllocatePool(sizeof(Str));
    str->s = AllocatePool(sizeof(CHAR16));
    str->s[0] = (CHAR16)0;
    str->len = 0;
    str->size = 2;

    return str;
  }

  VOID 
  StrAppend (
    Str *str,
    CHAR16 *s
    )
  {
    UINT64 newLen;
    UINT64 newSize;
    CHAR16 *t;

    newLen = 0;
    newSize = 0;
    t = NULL;

    newLen = str->len + StrLen(s);
    if (newLen*2 + 2 > str->size) {
      newSize = max(str->size*2, newLen*2 + 2);
      t = AllocatePool(newSize);
      t = CatSPrint(NULL, L"%s%s", str->s, s);
      FreePool(str->s);
      str->s = t;
      str->len = newLen;
      str->size = newSize;
      FreePool(t);

    } else {
      StrCat(&str->s[str->len], s);
      str->len += StrLen(s);
    }

    return;
  }
*/

/*
  #include "PciUtilityNDMD_16.h"
  #include <Protocol/LoadedImage.h>

  EFI_PCI_UTILITY_PROTOCOL gPciUtility;
  // EFI_PCI_UTILITY_PROTOCOL *PciUtility;

  EFI_STATUS
  PciUtilityEntryPoint (
    IN EFI_HANDLE ImageHandle,
    IN EFI_SYSTEM_TABLE *SystemTable
    )
  {
    EFI_STATUS Status;
    // EFI_PCI_UTILITY_PROTOCOL gPciUtility;
    EFI_PCI_UTILITY_PROTOCOL *PciUtility;

    PciUtility = &gPciUtility;

    // EFI_LOADED_IMAGE_PROTOCOL        *Image;

    Status = gBS->LocateProtocol (
                              &gEfiPciUtilityProtocolGuid,
                              NULL,
                              &PciUtility
                              );
    if (EFI_ERROR(Status)) {
      Print(L"%r\n", Status);

    } else {
      Print(L"%r\n", Status);
      Print(L"Already exit.\n");
      return EFI_ALREADY_STARTED;
    }

    gPciUtility.Apple = 5;
    gPciUtility.MainPage = MainPage;

    Status = gBS->InstallProtocolInterface(
                                        &ImageHandle,
                                        &gEfiPciUtilityProtocolGuid, 
                                        EFI_NATIVE_INTERFACE,
                                        &gPciUtility
                                        );
    if (EFI_ERROR(Status)) {
      Print(L"%r\n", Status);
      return Status;
    }

    Print(L"Load done\n");
    return Status;
  }

  EFI_STATUS
  PciUtilityUnload (
    IN EFI_HANDLE ImageHandle
    )
  {
    EFI_STATUS Status;

    Status = gBS->UninstallProtocolInterface(
                                          ImageHandle,
                                          &gEfiPciUtilityProtocolGuid,
                                          &gPciUtility
                                          );  

    Print(L"Unload done.\n");
    
    return Status;
  }

  EFI_STATUS
  MainPage (
    IN EFI_PCI_UTILITY_PROTOCOL    *This
    )
  {
    EFI_STATUS                    Status;  
    EFI_INPUT_KEY                 InputKey;
    POSITION                      CursorPosition;
    UINT8                         Mode;
    UINT8                         AllBranchPage;
    UINT8                         ReadMode;
    ADDRESS                       Address;

    //
    // initialization and into the main page
    //
    gST->ConOut->ClearScreen(gST->ConOut);
    gST->ConOut->SetCursorPosition(gST->ConOut, 0, 0);
    gST->ConOut->EnableCursor(gST->ConOut, TRUE);
    Mode = MAIN_PAGE_MODE;
    ReadMode = BYTE;
    AllBranchPage = ShowMainPage(&CursorPosition);
    
    //
    // choose mode loop
    //
    while (TRUE) {
      
      //
      // to change mode
      //
      ChangeMode:

      //
      // MAIN_PAGE_MODE
      // with up, down, F1, Esc key response
      //
      while (Mode == MAIN_PAGE_MODE) {
        gST->ConIn->ReadKeyStroke(gST->ConIn, &InputKey);

        if (InputKey.ScanCode == SCAN_ESC) {
          gST->ConOut->ClearScreen(gST->ConOut);
          goto Exit;
        }

        switch (InputKey.ScanCode) {

        case SCAN_UP:
          CursorPosition.row--;
          if (CursorPosition.row < MainPage_ResetPosition.row) {
            CursorPosition.row = MainPage_ResetPosition.row;
          }
          gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);    
          continue;

        case SCAN_DOWN:
          CursorPosition.row++;
          if (CursorPosition.row > (AllBranchPage + MainPage_ResetPosition.row - 1)) {
            CursorPosition.row = (AllBranchPage + MainPage_ResetPosition.row - 1);
          }
          gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);
          continue;

        case SCAN_F1:
          Mode = BRANCH_PAGE_MODE;
          ShowRegistPage(&Address, &CursorPosition);
          goto ChangeMode;
        }
      }

      //
      // BRANCH_PAGE_MODE
      // with up, down, right, left, F1, F2, F3, Esc key response
      //
      while (Mode == BRANCH_PAGE_MODE) {
        gST->ConIn->ReadKeyStroke(gST->ConIn, &InputKey);

        if (InputKey.ScanCode == SCAN_ESC) {
          gST->ConOut->ClearScreen(gST->ConOut);
          goto Exit;
        }

        switch (InputKey.ScanCode) {

        case SCAN_UP:
          CursorPosition.row--;
          if (CursorPosition.row < ReadMode1_ResetPosition.row) {
            CursorPosition.row = ReadMode1_ResetPosition.row;
          }     

          DisplayPosition(ReadMode, &CursorPosition);
          
          gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);    
          continue;

        case SCAN_DOWN:
          CursorPosition.row++;
          if (CursorPosition.row > (ReadMode1_ResetPosition.row + 15)) {
            CursorPosition.row = (ReadMode1_ResetPosition.row + 15);
          }

          DisplayPosition(ReadMode, &CursorPosition);

          gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);
          continue;
        
        case SCAN_RIGHT:
          CursorPosition.column = CursorPosition.column + (ReadMode * 3);
          if (CursorPosition.column > (52 - 2 * ReadMode)) {
            CursorPosition.column = (52 - 2 * ReadMode);
          }

          DisplayPosition(ReadMode, &CursorPosition);

          gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);
          continue;

        case SCAN_LEFT:
          CursorPosition.column = CursorPosition.column - (ReadMode * 3);
          if (CursorPosition.column < (ReadMode + 4)) {
            CursorPosition.column = (ReadMode + 4);
          }

          DisplayPosition(ReadMode, &CursorPosition);

          gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);
          continue;

        case SCAN_F1:
          Mode = MAIN_PAGE_MODE;
          ReadMode = BYTE;
          ShowMainPage(&CursorPosition);
          goto ChangeMode;
        
        case SCAN_F2:
          ReadMode *= 2;
          if (ReadMode > 4) ReadMode = BYTE;
          ReadRegist(&Address, &CursorPosition, ReadMode);
          continue;
        case SCAN_F3:
          Mode = WRITE_MODE;
          break;
        }
      }

      //
      // WRITE_MODE
      // with number(0~9),alphabet(a~f) key response
      //
      if (Mode == WRITE_MODE) {
        WRITE_BUFFER ReadMode1_WriteBuffer[2];
        WRITE_BUFFER ReadMode2_WriteBuffer[4];
        WRITE_BUFFER ReadMode4_WriteBuffer[8];
        UINT8 count;
        UINT8 i;
        UINT32 WriteBufferConvert;

        //
        // initialize write buffer、count
        //
        for (i = 0; i < 2; i++) {
          ReadMode1_WriteBuffer[i].value = 0;
          ReadMode1_WriteBuffer[i].position = ReadMode1_ResetPosition;
        }
        for (i = 0; i < 4; i++) {
          ReadMode2_WriteBuffer[i].value = 0;
          ReadMode2_WriteBuffer[i].position = ReadMode2_ResetPosition;
        }
        for (i = 0; i < 8; i++) {
          ReadMode4_WriteBuffer[i].value = 0;
          ReadMode4_WriteBuffer[i].position = ReadMode4_ResetPosition;
        }
        count = 0;                // for write_buffer operation
        WriteBufferConvert = 0;   // buffer for write_buffer

        while (TRUE) {
          gST->ConIn->ReadKeyStroke(gST->ConIn, &InputKey);

          if (ReadMode == BYTE) {
            if (count == (ReadMode * 2)) {
              count = 0;
              gST->ConOut->ClearScreen(gST->ConOut);
              Address.Offset = ((ReadMode1_WriteBuffer[0].position.column -           \
                                ReadMode1_ResetPosition.column) / 3) * (ReadMode) +  \
                                16 * (ReadMode1_WriteBuffer[0].position.row -        \
                                ReadMode1_ResetPosition.row);

              WriteBufferConvert = ((ReadMode1_WriteBuffer[0].value << 4) | (ReadMode1_WriteBuffer[1].value));
              WriteRegist(&Address, WriteBufferConvert, ReadMode);
              ReadRegist(&Address, &CursorPosition, ReadMode);

              Mode = BRANCH_PAGE_MODE;
              goto ChangeMode;
            }

            if (('a' <= InputKey.UnicodeChar && InputKey.UnicodeChar <= 'f')) {
              ReadMode1_WriteBuffer[count].value = (UINT8)InputKey.UnicodeChar - 87;
              ReadMode1_WriteBuffer[count].position.column = CursorPosition.column;
              ReadMode1_WriteBuffer[count].position.row = CursorPosition.row;
              Print(L"%c", InputKey.UnicodeChar);

              CursorPosition.column = CursorPosition.column + 1;
              gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);
              count++;
              continue;

            } else if (('0' <= InputKey.UnicodeChar && InputKey.UnicodeChar <= '9')) {
              ReadMode1_WriteBuffer[count].value = (UINT8)InputKey.UnicodeChar - 48;
              ReadMode1_WriteBuffer[count].position.column = CursorPosition.column;
              ReadMode1_WriteBuffer[count].position.row = CursorPosition.row;
              Print(L"%c", InputKey.UnicodeChar);

              CursorPosition.column = CursorPosition.column + 1;
              gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);
              count++;
              continue;
            }

          } else if (ReadMode == WORD) {
            if (count == (ReadMode * 2)) {
              count = 0;
              gST->ConOut->ClearScreen(gST->ConOut);
              Address.Offset = ((ReadMode2_WriteBuffer[0].position.column -           \
                                ReadMode2_ResetPosition.column) / 6) * (ReadMode) +  \
                                16 * (ReadMode2_WriteBuffer[0].position.row -        \
                                ReadMode2_ResetPosition.row);
              
              WriteBufferConvert = ((ReadMode2_WriteBuffer[0].value << 12) | \
                                    (ReadMode2_WriteBuffer[1].value << 8)  | \
                                    (ReadMode2_WriteBuffer[2].value << 4)  | \
                                    (ReadMode2_WriteBuffer[3].value));

              WriteRegist(&Address, WriteBufferConvert, ReadMode);
              ReadRegist(&Address, &CursorPosition, ReadMode);

              Mode = BRANCH_PAGE_MODE;
              goto ChangeMode;
            }

            if (('a' <= InputKey.UnicodeChar && InputKey.UnicodeChar <= 'f')) {
              ReadMode2_WriteBuffer[count].value = (UINT8)InputKey.UnicodeChar - 87;
              ReadMode2_WriteBuffer[count].position.column = CursorPosition.column;
              ReadMode2_WriteBuffer[count].position.row = CursorPosition.row;
              Print(L"%c", InputKey.UnicodeChar);

              CursorPosition.column = CursorPosition.column + 1;
              gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);
              count++;
              continue;

            } else if (('0' <= InputKey.UnicodeChar && InputKey.UnicodeChar <= '9')) {
              ReadMode2_WriteBuffer[count].value = (UINT8)InputKey.UnicodeChar - 48;
              ReadMode2_WriteBuffer[count].position.column = CursorPosition.column;
              ReadMode2_WriteBuffer[count].position.row = CursorPosition.row;
              Print(L"%c", InputKey.UnicodeChar);

              CursorPosition.column = CursorPosition.column + 1;
              gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);
              count++;
              continue;
            }

          } else if (ReadMode == DWORD) {
            if (count == (ReadMode * 2)) {
              count = 0;
              gST->ConOut->ClearScreen(gST->ConOut);
              Address.Offset = ((ReadMode4_WriteBuffer[0].position.column -             \
                                ReadMode4_ResetPosition.column) / 12) * (ReadMode) +   \
                                16 * (ReadMode4_WriteBuffer[0].position.row -          \
                                ReadMode4_ResetPosition.row);
              
              WriteBufferConvert = ((ReadMode4_WriteBuffer[0].value << 28) | \
                                    (ReadMode4_WriteBuffer[1].value << 24) | \
                                    (ReadMode4_WriteBuffer[2].value << 20) | \
                                    (ReadMode4_WriteBuffer[3].value << 16) | \
                                    (ReadMode4_WriteBuffer[4].value << 12) | \
                                    (ReadMode4_WriteBuffer[5].value << 8)  | \
                                    (ReadMode4_WriteBuffer[6].value << 4)  | \
                                    (ReadMode4_WriteBuffer[7].value));

              WriteRegist(&Address, WriteBufferConvert, ReadMode);
              ReadRegist(&Address, &CursorPosition, ReadMode);

              Mode = BRANCH_PAGE_MODE;
              goto ChangeMode;
            }

            if (('a' <= InputKey.UnicodeChar && InputKey.UnicodeChar <= 'f')) {
              ReadMode4_WriteBuffer[count].value = (UINT8)InputKey.UnicodeChar - 87;
              ReadMode4_WriteBuffer[count].position.column = CursorPosition.column;
              ReadMode4_WriteBuffer[count].position.row = CursorPosition.row;
              Print(L"%c", InputKey.UnicodeChar);

              CursorPosition.column = CursorPosition.column + 1;
              gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);
              count++;
              continue;

            } else if (('0' <= InputKey.UnicodeChar && InputKey.UnicodeChar <= '9')) {
              ReadMode4_WriteBuffer[count].value = (UINT8)InputKey.UnicodeChar - 48;
              ReadMode4_WriteBuffer[count].position.column = CursorPosition.column;
              ReadMode4_WriteBuffer[count].position.row = CursorPosition.row;
              Print(L"%c", InputKey.UnicodeChar);

              CursorPosition.column = CursorPosition.column + 1;
              gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition.column, CursorPosition.row);
              count++;
              continue;
            }
          }

          if (InputKey.ScanCode == SCAN_ESC) {
            gST->ConOut->ClearScreen(gST->ConOut);
            goto Exit;
          }

          switch (InputKey.ScanCode) {

          case SCAN_F3:
            Mode = BRANCH_PAGE_MODE;
            break;
          }      
        }
      }
      
      
    }

    //
    // to get out
    //
    Exit:

    Status = EFI_SUCCESS;

    return Status;
  }

  /**
    Show PCI devices's Bus、Device、Function.
    
    Set cursor's position by CursorPosition.
        
    @param  CursorPosition  The cursor's position  
                                                
    @return The number of searched PCI device.

  **/
  UINT8 
  ShowMainPage (
    POSITION *CursorPosition
    )
  {
    EFI_PCI_ROOT_BRIDGE_IO_PROTOCOL      *PciRootBridgeIo;
    EFI_STATUS                           Status;
    UINT64                               PciAddress;
    UINT16                               Bus;
    UINT16                               Device;
    UINT16                               Func;
    UINT16                               Offset;
    UINT8                                PciData8;            // read buffer  
    UINT8                                Num; 
    UINT8                                Buffer[4];

    Num = 0;
    PciData8 = 0;

    gBS->LocateProtocol (&gEfiPciRootBridgeIoProtocolGuid, NULL, &PciRootBridgeIo);
    gST->ConOut->ClearScreen(gST->ConOut);

    Print(L"|====================================================|\n");
    Print(L"|                    PCI   List                      |\n");
    Print(L"|====================================================|\n");
    Print(L"|              BUS       DEV       FUN               |\n");
    Print(L"|====================================================|\n");
    for (Bus = 0; Bus <= PCI_MAX_BUS; Bus++) {
      for (Device = 0; Device <= PCI_MAX_DEVICE; Device++) {
        for (Func = 0; Func <= PCI_MAX_FUNC; Func++) {
          for (Offset = 0; Offset < 4; Offset++) {                    // just get vendor_ID & device_ID
            PciAddress = EFI_PCI_ADDRESS (Bus, Device, Func, Offset);
            Status = PciRootBridgeIo->Pci.Read (
                                        PciRootBridgeIo,              // This
                                        EfiPciWidthUint8,             // Width
                                        PciAddress,                   // Address
                                        1,                            // Count
                                        &PciData8                     // *Buffer
                                        );
            Buffer[Offset] = PciData8;                                  
          }
          if (Buffer[0] != 0xff && Buffer[1] != 0xff) {
            Num++;
            Print(L"|%17.2x%10.2x%10.2x               |\n", Bus, Device, Func);
          }
        }
      }
    }
    Print(L"|====================================================|\n");
    Print(L"| [Arrow key] : Choose                               |\n");
    Print(L"| [F1] : Enter                                       |\n");
    Print(L"| [Esc] : Escape                                     |\n");
    Print(L"|====================================================|\n");

    *CursorPosition = MainPage_ResetPosition;
    gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition->column, CursorPosition->row);

    return Num;
  }

  /**
    When the main page move into the regist page call this function.

    @param  Address         To operate Pci.Read().
    @param  CursorPosition  When the regist show finished,set the cursor's position  

  **/
  VOID 
  ShowRegistPage (
    ADDRESS *Address, 
    POSITION *CursorPosition
    )
  {
    EFI_PCI_ROOT_BRIDGE_IO_PROTOCOL      *PciRootBridgeIo;
    EFI_STATUS                           Status;
    UINT64                               PciAddress;
    UINT16                               Bus;
    UINT16                               Device;
    UINT16                               Func;
    UINT16                               Offset;
    UINT8                                PciData8;                    // read buffer
    UINT8                                Num; 
    UINT8                                Buffer[256] = {0};

    Num = 0;
    PciData8 = 0;

    gBS->LocateProtocol (&gEfiPciRootBridgeIoProtocolGuid, NULL, &PciRootBridgeIo);
    gST->ConOut->ClearScreen(gST->ConOut);

    for (Bus = 0; Bus <= PCI_MAX_BUS; Bus++) {
      for (Device = 0; Device <= PCI_MAX_DEVICE; Device++) {
        for (Func = 0; Func <= PCI_MAX_FUNC; Func++) {
          for (Offset = 0; Offset < 256; Offset++) {                   // get all register
            PciAddress = EFI_PCI_ADDRESS (Bus, Device, Func, Offset);
            Status = PciRootBridgeIo->Pci.Read (
                                        PciRootBridgeIo,               // This
                                        EfiPciWidthUint8,              // Width
                                        PciAddress,                    // Address
                                        1,                             // Count
                                        &PciData8                      // *Buffer
                                        );
            Buffer[Offset] = PciData8;

            if (Buffer[0] == 0xff && Buffer[1] == 0xff) 
              break;
          }
          if (Buffer[0] != 0xff && Buffer[1] != 0xff) {
            Num++;
            if (Num == ((CursorPosition->row) - MainPage_ResetPosition.row + 1)) {
              Address->Bus = Bus;
              Address->Device = Device;
              Address->Func = Func;
              Address->Offset = 0;

              Print(L"|  BUS:%.2x  DEV:%.2x  FUN:%.2x                            |\n", Bus, Device, Func);
              Print(L"|====================================================|\n");
              Print(L"|00| 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F |\n");
              Print(L"|====================================================|\n");

              for (Offset = 0; Offset < 256; Offset++) {
                if ((Offset % 16) == 0) 
                  Print(L"|%.2x|", Offset);

                Print(L"%3.2x", Buffer[Offset]);

                if ((Offset % 16) == 15) 
                  Print(L" |\n");
              }
            }
          }
        }
      }
    }
    Print(L"|====================================================|\n");
    Print(L"| [Arrow key]:Choose   [F1]:Back      [F2]:Read Mode |\n");
    Print(L"| [F3]:Modify          [Esc]:Escape                  |\n");
    Print(L"|====================================================|\n");

    *CursorPosition = ReadMode1_ResetPosition;
    gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition->column, CursorPosition->row);

    return;
  }

  /**
    When change read mode,call this function.

    This function is used to other function.

    @param  Address         To operate Pci.Read().
    @param  CursorPosition  When the regist show finished,set the cursor's position
    @param  ReadMode        There are threemode
                            BYTE  -> read a byte
                            WORD  -> read two bytes
                            DWORD -> read four bytes

  **/
  VOID 
  ReadRegist (
    ADDRESS *Address, 
    POSITION *CursorPosition, 
    UINT8 ReadMode
    )
  {
    EFI_PCI_ROOT_BRIDGE_IO_PROTOCOL      *PciRootBridgeIo;
    EFI_STATUS                           Status;
    UINT64                               PciAddress;
    UINT8                                PciData8;          // 8bit  read buffer
    UINT16                               PciData16;         // 16bit read buffer
    UINT32                               PciData32;         // 32bit read buffer
    UINT16                               Offset;

    gBS->LocateProtocol (&gEfiPciRootBridgeIoProtocolGuid, NULL, &PciRootBridgeIo);
    gST->ConOut->ClearScreen(gST->ConOut);

    Print(L"|  BUS:%.2x  DEV:%.2x  FUN:%.2x                            |\n", Address->Bus, 
                                                                            Address->Device, 
                                                                            Address->Func);

    Print(L"|====================================================|\n");
    if (ReadMode == BYTE) {
      Print(L"|00| 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F |\n");
      Print(L"|====================================================|\n");

      for (Offset = 0; Offset < 256; Offset++) {
        PciAddress = EFI_PCI_ADDRESS (Address->Bus, Address->Device, Address->Func, Offset);
        Status = PciRootBridgeIo->Pci.Read (
                                    PciRootBridgeIo,      // This
                                    EfiPciWidthUint8,     // Width
                                    PciAddress,           // Address
                                    1,                    // Count
                                    &PciData8             // *Buffer
                                    );
        if ((Offset % 16) == 0) 
          Print(L"|%.2x|", Offset);

        Print(L"%3.2x", PciData8);

        if ((Offset % 16) == 15) 
          Print(L" |\n");   
      }
    } else if (ReadMode == WORD) {
      Print(L"|00|  0100  0302  0504  0706  0908  0B0A  0D0C  0F0E |\n");
      Print(L"|====================================================|\n");

      for (Offset = 0; Offset < 256; Offset += 2) {
        PciAddress = EFI_PCI_ADDRESS (Address->Bus, Address->Device, Address->Func, Offset);
        Status = PciRootBridgeIo->Pci.Read (
                                    PciRootBridgeIo,      // This
                                    EfiPciWidthUint16,    // Width
                                    PciAddress,           // Address
                                    1,                    // Count
                                    &PciData16            // *Buffer
                                    );
        if ((Offset % 16) == 0) 
          Print(L"|%.2x|", Offset);

        Print(L"%6.4x", PciData16);

        if ((Offset % 16) == 14) 
          Print(L" |\n");
      }
    } else if (ReadMode == DWORD) {
      Print(L"|00|    03020100    07060504    0B0A0908    0F0E0D0C |\n");
      Print(L"|====================================================|\n");

      for (Offset = 0; Offset < 256; Offset += 4) {
        PciAddress = EFI_PCI_ADDRESS (Address->Bus, Address->Device, Address->Func, Offset);
        Status = PciRootBridgeIo->Pci.Read (
                                    PciRootBridgeIo,      // This
                                    EfiPciWidthUint32,    // Width
                                    PciAddress,           // Address
                                    1,                    // Count
                                    &PciData32            // *Buffer
                                    );

        if ((Offset % 16) == 0) 
          Print(L"|%.2x|", Offset);

        Print(L"%12.8x", PciData32);

        if ((Offset % 16) == 12) 
          Print(L" |\n");
      }
    }                     
    Print(L"|====================================================|\n");
    Print(L"| [Arrow key]:Choose   [F1]:Back      [F2]:Read Mode |\n");
    Print(L"| [F3]:Modify          [Esc]:Escape                  |\n");
    Print(L"|====================================================|\n");

    if (ReadMode == BYTE) {
      *CursorPosition = ReadMode1_ResetPosition;
      gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition->column, CursorPosition->row);
    } else if (ReadMode == WORD) {
      *CursorPosition = ReadMode2_ResetPosition;
      gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition->column, CursorPosition->row);
    } else if (ReadMode == DWORD) {
      *CursorPosition = ReadMode4_ResetPosition;
      gST->ConOut->SetCursorPosition(gST->ConOut, CursorPosition->column, CursorPosition->row);
    }                            

    return;
  }

  /**
    When the position has chosen,call this function can write data in.

    @param  Address             To operate Pci.Write().
    @param  WriteBufferConvert  The buffer of write data. 
    @param  ReadMode            There are threemode
                                BYTE  -> read a byte
                                WORD  -> read two bytes
                                DWORD -> read four bytes

  **/
  VOID 
  WriteRegist (
    ADDRESS *Address, 
    UINT32 WriteBufferConvert, 
    UINT8 ReadMode
    )
  {
    EFI_PCI_ROOT_BRIDGE_IO_PROTOCOL      *PciRootBridgeIo;
    EFI_STATUS                           Status;
    UINT64                               PciAddress; 
    UINT8                                PciData8;            // 8bit  write buffer
    UINT16                               PciData16;           // 16bit write buffer
    UINT32                               PciData32;           // 32bit write buffer

    if (ReadMode == BYTE) {

      PciData8 = (UINT8)WriteBufferConvert;

      gBS->LocateProtocol (&gEfiPciRootBridgeIoProtocolGuid, NULL, &PciRootBridgeIo);
      gST->ConOut->ClearScreen(gST->ConOut);

      PciAddress = EFI_PCI_ADDRESS (Address->Bus, Address->Device, Address->Func, Address->Offset);
      Status = PciRootBridgeIo->Pci.Write (
                                  PciRootBridgeIo,            // This
                                  EfiPciWidthUint8,           // Width
                                  PciAddress,                 // Address
                                  1,                          // Count
                                  &PciData8                   // *Buffer
                                  );                                 
      return;

    } else if (ReadMode == WORD) {

      PciData16 = (UINT16)WriteBufferConvert;

      gBS->LocateProtocol (&gEfiPciRootBridgeIoProtocolGuid, NULL, &PciRootBridgeIo);
      gST->ConOut->ClearScreen(gST->ConOut);

      PciAddress = EFI_PCI_ADDRESS (Address->Bus, Address->Device, Address->Func, Address->Offset);
      Status = PciRootBridgeIo->Pci.Write (
                                  PciRootBridgeIo,            // This
                                  EfiPciWidthUint16,          // Width
                                  PciAddress,                 // Address
                                  1,                          // Count
                                  &PciData16                  // *Buffer
                                  );                                 
      return;

    } else if (ReadMode == DWORD) {

      PciData32 = WriteBufferConvert;

      gBS->LocateProtocol (&gEfiPciRootBridgeIoProtocolGuid, NULL, &PciRootBridgeIo);
      gST->ConOut->ClearScreen(gST->ConOut);

      PciAddress = EFI_PCI_ADDRESS (Address->Bus, Address->Device, Address->Func, Address->Offset);
      Status = PciRootBridgeIo->Pci.Write (
                                  PciRootBridgeIo,            // This
                                  EfiPciWidthUint32,          // Width
                                  PciAddress,                 // Address
                                  1,                          // Count
                                  &PciData32                  // *Buffer
                                  );                                 
      return;
    }
  }

  /**
    In the show regist mode,the function will show the offset site.

    @param  ReadMode        
    @param  CursorPosition  

  **/
  VOID 
  DisplayPosition (
    UINT8 ReadMode, 
    POSITION *CursorPosition
    )
  {
    if (ReadMode == BYTE) {                                                                          
      gST->ConOut->SetCursorPosition(gST->ConOut, 1, 2);                                             
      Print(L"%.2x", (CursorPosition->column - 5) / 3 * ReadMode + (CursorPosition->row -               \
                                                                    ReadMode1_ResetPosition.row) * 16); 
    } else if (ReadMode == WORD) {                                                                   
      gST->ConOut->SetCursorPosition(gST->ConOut, 1, 2);                                             
      Print(L"%.2x", (CursorPosition->column - 6) / 6 * ReadMode + (CursorPosition->row -               \
                                                                    ReadMode2_ResetPosition.row) * 16); 
    } else if (ReadMode == DWORD) {                                                                  
      gST->ConOut->SetCursorPosition(gST->ConOut, 1, 2);                                             
      Print(L"%.2x", (CursorPosition->column - 8) / 12 * ReadMode + (CursorPosition->row -              \
                                                                    ReadMode4_ResetPosition.row) * 16); 
    }
  }
*/

/*
  #include <Uefi.h>
  #include <Library/UefiLib.h>
  #include <Library/UefiApplicationEntryPoint.h>
  #include <Library/UefiBootServicesTableLib.h>

  #include <Protocol/LoadedImage.h>
  #include <Protocol/SimpleFileSystem.h>
  #include <Protocol/EfiShellParameters.h>
  #include <Protocol/EfiShellInterface.h>
  #include <Protocol/CpuIo2.h>

  #include <Guid/FileInfo.h>
  #include <Guid/FileSystemInfo.h>

  #include <Library/MemoryAllocationLib.h>

  EFI_FILE_INFO*
  GetFileInfo (
    EFI_FILE  *Root,
    CHAR16    *FileName
    )
  {
    EFI_STATUS     Status;
    EFI_FILE       *FileHandle;
    EFI_FILE_INFO  *Buffer;
    UINT64         BufferSize;
    
    FileHandle = NULL;
    Buffer = NULL;
    BufferSize = 0;

    Status = Root->Open(
                    Root,
                    &FileHandle,
                    FileName,
                    EFI_FILE_MODE_READ,
                    0
                    );
    if (EFI_ERROR(Status)) {
      // Print(L"Open fail: %r\n", Status);
      return NULL;

    } else {
      Status = FileHandle->GetInfo(
                          FileHandle,
                          &gEfiFileInfoGuid,
                          &BufferSize,
                          Buffer
                          );
      if (Status == EFI_BUFFER_TOO_SMALL) {
        gBS->AllocatePool(
                      EfiBootServicesData,
                      BufferSize,                        
                      &Buffer
                      );
        Status = FileHandle->GetInfo(
                                  FileHandle,
                                  &gEfiFileInfoGuid,
                                  &BufferSize,
                                  Buffer
                                  );
        if (EFI_ERROR(Status)) {
          // Print(L"Get information fail: %r.\n", Status);
          gBS->FreePool(Buffer);
          return NULL;

        } else {
          Status = Root->Close(FileHandle);
          if (EFI_ERROR(Status)) {
            // Print(L"Close fail: %r.\n", Status);
            gBS->FreePool(Buffer);
            return NULL;

          } else {
            return Buffer;
          }
        }
      } else {
        Status = Root->Close(FileHandle);
        if (EFI_ERROR(Status)) {
          // Print(L"Close fail: %r.\n", Status);
          return NULL;

        } else {
          return Buffer;
        }
      }
    }
  }

  EFI_STATUS
  ReadFile (
    EFI_FILE  *Root,
    CHAR16    *FileName
    )
  {
    EFI_STATUS            Status;
    EFI_FILE              *FileHandle;
    UINT8                 *Buffer;
    UINT64                BufferSize;
    UINT64                i;
    EFI_CPU_IO2_PROTOCOL  *CpuIo2;
    
    FileHandle = NULL;
    Buffer = NULL;
    BufferSize = 0;
    i = 0;
    CpuIo2 = NULL;

    Status = gBS->LocateProtocol(
                              &gEfiCpuIo2ProtocolGuid, 
                              NULL, 
                              (VOID**)&CpuIo2
                              );
    if (Status != EFI_SUCCESS) {
      // Print (L"%r\n", Status);
      return Status;
    }

    if (GetFileInfo(Root, FileName) == NULL) {
      // Print(L"File %s not found !!!\n", FileName);
      return EFI_NOT_FOUND;

    } else {
      BufferSize = GetFileInfo(Root, FileName)->FileSize;

      // Print(L"FileSize -> %x\n", BufferSize);

      if (BufferSize == 0) {
        // Print(L"%s has no content !!!\n", FileName);
        return EFI_SUCCESS;
      }
    }

    gBS->AllocatePool(
                  EfiBootServicesData,
                  BufferSize,                        
                  &Buffer
                  );

    Status = Root->Open(
                    Root,
                    &FileHandle,
                    FileName,
                    EFI_FILE_MODE_READ,
                    0
                    );
    if (EFI_ERROR(Status)) {
      // Print(L"Open fail: %r.\n", Status);
      return Status;

    } else {
      Status = FileHandle->Read(
                            FileHandle,
                            &BufferSize,
                            Buffer
                            );
      if (EFI_ERROR(Status)) {
        // Print(L"Read fail: %r.\n", Status);
        Status = Root->Close(FileHandle);
        if (EFI_ERROR(Status)) {
          // Print(L"Close fail: %r.\n", Status);
        }
        FreePool(Buffer);
        return Status;

      } else {
        Status = Root->Close(FileHandle);
        if (EFI_ERROR(Status)) {
          // Print(L"Close fail: %r.\n", Status);
          FreePool(Buffer);
          return Status;

        } else {
          // Print(L"File content:\n");
          // gST->ConOut->SetAttribute(gST->ConOut, EFI_WHITE | EFI_BACKGROUND_BLACK);
          *Buffer = 0;
          for (i = 0; i <= 0x11cd; i++) {
            // // Print(L"%c ", *(Buffer + i));

            Status = CpuIo2->Mem.Write(
                                  CpuIo2,
                                  EfiCpuIoWidthUint8,
                                  // 0x8b67c000 + i,
                                  // 0x8abe8000 + i,
                                  0x8a2e8000 + i,
                                  1,                                
                                  Buffer
                                  );
            if (EFI_ERROR(Status)) {
              // Print(L"%r\n", Status);
            }
            //  else {
            //   // Print(L"Done %.4x\n", i);
            //   gST->ConOut->ClearScreen(gST->ConOut);
            // }
          }
          // Print(L"Done!!!\n");
          gST->ConOut->OutputString(gST->ConOut, L"Done!!!\n");
          // gST->ConOut->SetAttribute(gST->ConOut, EFI_LIGHTGRAY | EFI_BACKGROUND_BLACK);
          FreePool(Buffer);
          return Status;
        }      
      }
    }
  }

  EFI_STATUS
  EFIAPI
  UefiMain (
    IN EFI_HANDLE  ImageHandle,
    IN EFI_SYSTEM_TABLE  *SystemTable
    )
  {
    EFI_STATUS                        Status;
    EFI_LOADED_IMAGE_PROTOCOL         *Image;
    EFI_SIMPLE_FILE_SYSTEM_PROTOCOL   *SimpleFileSystem;
    EFI_FILE                          *Root;
    BOOLEAN                           OpenSuccess;

    Image = NULL;
    SimpleFileSystem = NULL;
    Root = NULL;
    OpenSuccess = FALSE;

    gST->ConOut->ClearScreen(gST->ConOut);

    Status = gBS->HandleProtocol(
                    ImageHandle,
                    &gEfiLoadedImageProtocolGuid,
                    &Image
                    );
    if (Status == EFI_SUCCESS) {
      Status = gBS->HandleProtocol(
                      Image->DeviceHandle,
                      &gEfiSimpleFileSystemProtocolGuid,
                      &SimpleFileSystem
                      );
      if (Status == EFI_SUCCESS) {
        Status = SimpleFileSystem->OpenVolume(
                            SimpleFileSystem,
                            &Root
                            );
        if (Status == EFI_SUCCESS) {        
          OpenSuccess = TRUE;
        }
      }
    }

    ReadFile(Root, L"SmbiosTable-M000000008B67C000_Insyde_En.bin");

    Status = EFI_SUCCESS;
    return Status;
  }
*/

/*
  #include <Uefi.h>
  #include <Library/UefiLib.h>
  #include <Library/UefiApplicationEntryPoint.h>
  #include <Library/UefiBootServicesTableLib.h>
  #include <Library/MemoryAllocationLib.h>

  #include <Protocol/LoadedImage.h>
  #include <Protocol/SimpleFileSystem.h>
  #include <Protocol/EfiShellParameters.h>
  #include <Protocol/EfiShellInterface.h>
  #include <Protocol/CpuIo2.h>
  #include <Protocol/MebxProtocol.h>

  #include <Guid/FileInfo.h>
  #include <Guid/FileSystemInfo.h>

  EFI_STATUS
  EFIAPI
  UefiMain (
    IN EFI_HANDLE  ImageHandle,
    IN EFI_SYSTEM_TABLE  *SystemTable
    )
  {
    EFI_STATUS          Status;
    EFI_MEBX_PROTOCOL   *MebxProtocol;
    
    CHAR16              *String;
    // CHAR16              Buffer = 97;

    MebxProtocol = NULL;

    String = AllocateZeroPool(9 * sizeof(CHAR16));

    Status = gBS->LocateProtocol(&gEfiMebxProtocolGuid, NULL, &MebxProtocol);
    if (EFI_ERROR(Status)) {
      gST->ConOut->OutputString(gST->ConOut, L"Locate fail!!!\n");
      return Status;
    }

    String[0] = MebxProtocol->MebxVersion.Major + 48;
    String[1] = '.';
    String[2] = MebxProtocol->MebxVersion.Minor + 48;
    String[3] = '.';
    String[4] = MebxProtocol->MebxVersion.Hotfix + 48;
    String[5] = '.';
    String[6] = MebxProtocol->MebxVersion.Build + 48;
    String[7] = '\n';
    String[8] = '0';

    gST->ConOut->OutputString(gST->ConOut, String);

    Status = EFI_SUCCESS;
    return Status;
  }
*/

/*
  Author: Jared_Lin
*/

/**/

/**/

/**/